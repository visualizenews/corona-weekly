{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/axios/lib/helpers/bind.js","../../node_modules/axios/lib/utils.js","../../node_modules/axios/lib/helpers/buildURL.js","../../node_modules/axios/lib/core/InterceptorManager.js","../../node_modules/axios/lib/core/transformData.js","../../node_modules/axios/lib/cancel/isCancel.js","../../node_modules/axios/lib/helpers/normalizeHeaderName.js","../../node_modules/axios/lib/core/createError.js","../../node_modules/axios/lib/core/enhanceError.js","../../node_modules/axios/lib/helpers/cookies.js","../../node_modules/axios/lib/helpers/parseHeaders.js","../../node_modules/axios/lib/helpers/isURLSameOrigin.js","../../node_modules/axios/lib/adapters/xhr.js","../../node_modules/axios/lib/core/buildFullPath.js","../../node_modules/axios/lib/helpers/isAbsoluteURL.js","../../node_modules/axios/lib/helpers/combineURLs.js","../../node_modules/axios/lib/core/settle.js","../../node_modules/axios/lib/defaults.js","../../node_modules/axios/lib/core/dispatchRequest.js","../../node_modules/axios/lib/core/mergeConfig.js","../../node_modules/axios/lib/core/Axios.js","../../node_modules/axios/lib/cancel/Cancel.js","../../node_modules/axios/lib/cancel/CancelToken.js","../../node_modules/axios/lib/axios.js","../../node_modules/axios/lib/helpers/spread.js","../../node_modules/axios/lib/helpers/isAxiosError.js","../../node_modules/axios/index.js","../../node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-axis/dist/chrt-axis.esm.js","../../node_modules/chrt-grid/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-grid/dist/chrt-grid.esm.js","../../node_modules/chrt-line/dist/chrt-line.esm.js","../../node_modules/chrt-bars/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-bars/dist/chrt-bars.esm.js","../../node_modules/chrt-points/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-points/dist/chrt-points.esm.js","../../node_modules/chrt-label/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-label/dist/chrt-label.esm.js","../../node_modules/chrt-markers/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-markers/dist/chrt-markers.esm.js","../../node_modules/chrt-annotation/dist/chrt-annotation.esm.js","../../src/Chart.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.37.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to seperate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, update_slot_spread, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n","module.exports = require('./lib/axios');","// chrt-core v0.0.26 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNull(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNull(value);\n  });\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(name, \"fixedDomain\", fixedDomain);\n  // console.log(name, \"domainExtent\", domainExtent);\n  // console.log(name, \"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.26 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction generateTicks(ticks, name, callback) {\n  var _this = this;\n\n  ticks.forEach(function (tick, i, arr) {\n    var tickGroup = _this.g.querySelector(\"[data-id='tick-\".concat(name, \"-\").concat(tick.value, \"']\"));\n\n    if (!tickGroup) {\n      tickGroup = createSVG('g');\n      tickGroup.setAttribute('data-id', \"tick-\".concat(name, \"-\").concat(tick.value));\n\n      if (tick.isMinor) {\n        tickGroup.classList.add('tick-minor');\n      }\n\n      _this.g.appendChild(tickGroup);\n\n      if (_this.showAxisLine) {\n        var tickLine = createSVG('line');\n        tickLine.setAttribute('stroke', _this.stroke);\n        tickLine.setAttribute('stroke-width', _this.strokeWidth);\n        tickGroup.appendChild(tickLine);\n      }\n    }\n\n    if (callback) {\n      callback.call(null, tickGroup, tick, i, arr);\n    }\n  });\n}\n\nvar TICKS_DEFAULT = 10;\nvar ORIENTATIONS = {\n  x: ['top', 'bottom'],\n  y: ['left', 'right']\n};\nvar DEFAULT_ORIENTATION = {\n  x: 'bottom',\n  y: 'left'\n};\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction lineColor(value) {\n  if (isNull(value)) {\n    return this.stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.stroke = value;\n  }\n\n  return this;\n}\n\nfunction lineWidth(value) {\n  if (isNull(value)) {\n    return this.strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction setTickLength(value) {\n  if (isNull(value)) {\n    return this.tickLength;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.tickLength = value;\n  }\n\n  return this;\n}\n\nfunction setTickPosition(value) {\n  if (isNull(value)) {\n    return this.tickPosition;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.tickPosition = value;\n  }\n\n  return this;\n}\n\nfunction setTickPosition$1(value) {\n  if (isNull(value)) {\n    return this.labelPosition;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.labelPosition = value;\n  }\n\n  return this;\n}\n\nfunction showAxis(value) {\n  if (typeof value === 'function') ; else {\n    this.showAxisLine = isNull(value) ? true : value;\n  }\n\n  return this;\n}\nfunction hideAxis() {\n  return showAxis.call(this, false);\n}\n\nfunction ticks(ticks) {\n  if (isNull(ticks)) {\n    return this._ticks;\n  }\n\n  this._fixedTicks = ticks;\n  return this;\n} // showTicks and hideTicks can get different type of parameters and they filter the ticks based on the parameters\n\nfunction showTicks(filter) {\n  // default true\n  if (isNull(filter)) {\n    this.ticksFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showTicks((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.ticksFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all ticks\n  // showTicks(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.ticksFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one tick\n  // showTicks(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.ticksFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showTicks([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.ticksFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n} // hideTicks is the opposite of showTicks and it filters out\n\nfunction hideTicks(filter) {\n  showTicks.call(this, filter);\n  var ticksFilter = this.ticksFilter;\n\n  this.ticksFilter = function (d, i, arr) {\n    return !ticksFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  // // console.log('FIRST TICK', this, show)\n  if (show) {\n    showTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\nfunction firstAndLastTicks() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showTicks.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  } else {\n    hideTicks.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nfunction orient(value) {\n  if (isNull(value)) {\n    return this.orientation;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.orientation = ORIENTATIONS[this._name].indexOf(value) > -1 ? value : DEFAULT_ORIENTATION[this.name]; // // console.log('SETTING ORIENTATION', this.name, value, '->', this.orientation)\n  }\n\n  return this;\n}\n\nfunction format(format) {\n  if (isNull(format)) {\n    return this;\n  }\n\n  if (typeof format === 'function') {\n    this.labelFormat = format;\n  }\n\n  return this;\n}\n\nfunction minor() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (isNull(value)) {\n    return this.showMinorTicks;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.showMinorTicks = value;\n  }\n\n  return this;\n}\n\nfunction zero(value) {\n  if (isNull(value)) {\n    return this._zero;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._zero = value;\n  }\n\n  return this;\n}\nfunction hideZero() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (typeof value === 'function') ; else {\n    this.showZero = !value;\n  }\n\n  return this;\n}\n\nfunction label(text) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (isNull(text)) {\n    return this._label;\n  }\n\n  this._label = Object.assign({\n    position: 'last'\n  }, options, {\n    text: text\n  });\n  return this;\n}\n\nfunction interval(value) {\n  // console.log('INTERVAL', value)\n  if (isNull(value)) {\n    return this._interval;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._interval = value;\n  }\n\n  return this;\n}\n\nfunction title(value) {\n  return this.attr('title', value);\n}\n\nfunction labels(labels) {\n  if (isNull(labels)) {\n    return this._labels;\n  }\n\n  this._fixedLabels = labels;\n  return this;\n} // showLabels and hideLabels can get different type of parameters and they filter the labels based on the parameters\n\nfunction showLabels(filter) {\n  // default true\n  if (isNull(filter)) {\n    this.labelsFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showLabels((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.labelsFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all labels\n  // showLabels(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.labelsFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one label\n  // showLabels(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.labelsFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showLabels([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.labelsFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n} // hideLabels is the opposite of showLabels and it filters out\n\nfunction hideLabels(filter) {\n  showLabels.call(this, filter);\n  var labelsFilter = this.labelsFilter;\n\n  this.labelsFilter = function (d, i, arr) {\n    return !labelsFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstLabel() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showLabels.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideLabels.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastLabel() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showLabels.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideLabels.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\nfunction firstAndLastLabels() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showLabels.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  } else {\n    hideLabels.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nvar DEFAULT_LINE_WIDTH = 1;\nvar DEAULT_LINE_COLOR = '#000';\nvar DEAULT_TICK_TEXT_COLOR = '#000';\nvar TICK_LENGTH = 5;\nvar TICK_POSITION = 'outside';\nvar LABEL_POSITION = 'outside';\n\nfunction chrtAxis(name) {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'axis';\n  this.updater = true;\n  this.name = name;\n  this.strokeWidth = DEFAULT_LINE_WIDTH;\n  this.stroke = DEAULT_LINE_COLOR;\n  this.tickTextColor = DEAULT_TICK_TEXT_COLOR;\n  this.showAxisLine = true;\n  this.ticksFilter = null;\n  this.labelsFilter = null;\n  this.tickLength = TICK_LENGTH;\n  this.tickPosition = TICK_POSITION;\n  this.labelPosition = LABEL_POSITION;\n\n  this.labelFormat = function (d) {\n    return d;\n  };\n\n  this.showMinorTicks = false;\n  this._zero = null;\n  this.showZero = true;\n  this._label = null;\n  this._ticks = [];\n  this._fixedTicks = null;\n  this._interval = null;\n  this._classNames = ['chrt-axis'];\n\n  this.draw = function () {\n    if (!_this.parentNode.scales[_this._coordinates][name]) {\n      return _this.parentNode;\n    }\n\n    return _this.parentNode;\n  };\n}\n\nchrtAxis.prototype = Object.create(chrtGeneric.prototype);\nchrtAxis.prototype.constructor = chrtAxis;\nchrtAxis.parent = chrtGeneric.prototype;\nchrtAxis.prototype = Object.assign(chrtAxis.prototype, {\n  width: lineWidth,\n  color: lineColor,\n  setTickLength: setTickLength,\n  setTickPosition: setTickPosition,\n  setLabelPosition: setTickPosition$1,\n  showAxis: showAxis,\n  hideAxis: hideAxis,\n  ticks: ticks,\n  filterTicks: showTicks,\n  filter: showTicks,\n  showTicks: showTicks,\n  hideTicks: hideTicks,\n  firstTick: firstTick,\n  lastTick: lastTick,\n  firstAndLastTicks: firstAndLastTicks,\n  labels: labels,\n  filterLabels: showTicks,\n  showLabels: showLabels,\n  hideLabels: hideLabels,\n  firstLabel: firstLabel,\n  lastLabel: lastLabel,\n  firstAndLastLabels: firstAndLastLabels,\n  orient: orient,\n  format: format,\n  minor: minor,\n  zero: zero,\n  hideZero: hideZero,\n  label: label,\n  interval: interval,\n  title: title\n});\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction generateLabels(labels, name, callback) {\n  var _this = this;\n\n  // console.log('generateLabels', labels, name)\n  labels.forEach(function (d, i, arr) {\n    var labelGroup = _this.g.querySelector(\"[data-id='label-\".concat(name, \"-\").concat(d.value, \"']\"));\n\n    if (!labelGroup) {\n      labelGroup = createSVG('g');\n      labelGroup.setAttribute('data-id', \"label-\".concat(name, \"-\").concat(d.value));\n\n      if (d.isMinor) {\n        labelGroup.classList.add('label-minor');\n      }\n\n      _this.g.appendChild(labelGroup);\n\n      var label = createSVG('text');\n      label.textContent = _this.labelFormat(d.value, i, arr);\n      label.setAttribute('fill', _this.labelTextColor);\n\n      if (label.label) {\n        label.textContent = \"\".concat(_this.labelFormat(label.value, i, arr)).concat(d.label.text);\n      }\n\n      labelGroup.appendChild(label);\n    }\n\n    if (callback) {\n      callback.call(null, labelGroup, d, i, arr);\n    }\n  });\n}\n\nfunction xAxis() {\n  var _this = this;\n\n  var ticksNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n  var customName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n\n  if (typeof arguments[0] === 'string') {\n    customName = arguments[0];\n    ticksNumber = TICKS_DEFAULT;\n  }\n\n  chrtAxis.call(this, customName);\n  var name = this.name;\n  this._name = 'x';\n  this._coordinates = 'x';\n  this.orientation = DEFAULT_ORIENTATION[this._name];\n  var coords = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [].concat(_toConsumableArray(this._classNames), ['chrt-x-axis']);\n\n  var xAxisTick = function xAxisTick(tickGroup, visible) {\n    _this._name = coords.x;\n    name = _this.parentNode.scales[coords.x][_this.name].getName();\n    tickGroup.style.display = visible ? 'block' : 'none';\n    var tickLine = tickGroup.querySelector('line');\n    var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? 1 : -1;\n\n    if (tickLine) {\n      tickLine.setAttribute('x1', 0);\n      tickLine.setAttribute('x2', 0);\n      tickLine.setAttribute('y1', 0);\n      tickLine.setAttribute('y2', (_this.tickPosition === 'outside' ? _this.tickLength : -_this.tickLength) * orientation);\n    }\n\n    var label = tickGroup.querySelector('text');\n\n    if (label) {\n      label.setAttribute('text-anchor', 'middle'); // label.setAttribute('y', this.tickLength * orientation);\n\n      label.setAttribute('y', (_this.labelPosition === 'outside' ? _this.tickLength : -_this.tickLength) * orientation);\n      label.setAttribute('data-orientation', orientation);\n\n      if (orientation > 0) {\n        label.setAttribute('dy', \"\".concat(_this.labelPosition === 'outside' ? 1 : -0.25, \"em\"));\n      } else {\n        label.setAttribute('dy', \"\".concat(_this.labelPosition === 'outside' ? -0.25 : 1, \"em\"));\n      }\n\n      label.setAttribute('fill', _this.stroke);\n    }\n  };\n\n  this.draw = function () {\n    _this._name = coords.x; // TODO: needs improvement, name and this.name will be the same\n\n    name = _this.parentNode.scales[coords.x][_this.name].getName(); // console.log('this.name vs name', this.name, name)\n\n    if (!_this.parentNode.scales[coords.x][name]) {\n      return _this.parentNode;\n    }\n\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        width = _this$parentNode.width,\n        height = _this$parentNode.height,\n        scales = _this$parentNode.scales;\n\n    if (_this._label) {\n      _this._label.tickIndex = -1;\n    }\n\n    var ticks = scales[coords.x][name].ticks(_this._fixedTicks || ticksNumber * 2, _this._interval);\n\n    if (_this._label && _this._label.position === 'last') {\n      ticks.reverse();\n    }\n\n    _this._ticks = ticks.map(function (tick, i, arr) {\n      tick.position = scales[coords.x][name](tick.value);\n      var visible = tick.position >= _margins.left && tick.position <= width - _margins.right;\n      visible = visible && (_this.showMinorTicks || tick.isZero && _this.showZero || !tick.isMinor);\n      visible = visible && (!isLog || isLog && !tick.isMinor);\n      tick.visible = visible;\n\n      if (_this.ticksFilter) {\n        tick.visible = tick.visible && _this.ticksFilter(tick.value, i, arr);\n      }\n\n      tick.visibleLabel = visible;\n\n      if (_this.labelsFilter) {\n        tick.visibleLabel = tick.visibleLabel && _this.labelsFilter(tick.value, i, arr);\n      }\n\n      tick.label = null;\n\n      if (tick.visibleLabel && _this._label) {\n        if (!isNull(_this._label.value) && _this._label.value === tick.value) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      if (tick.visibleLabel && _this._label && isNull(_this._label.value) && (_this._label.position === 'all' || _this._label.tickIndex === -1)) {\n        if (!isNull(_this._label.position)) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      return tick;\n    }).filter(function (d) {\n      return d.visible || d.visibleLabel;\n    }); // decrease the number of ticks rendered in the DOM\n\n    _this.g.setAttribute('id', \"\".concat(name, \"Axis-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var axisY = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? height - _margins.bottom : _margins.top;\n\n    _this.g.setAttribute('transform', \"translate(0,\".concat(axisY, \")\"));\n\n    var axisLine = _this.g.querySelector(\"[data-id='tick-\".concat(name, \"-axis-line']\"));\n\n    if (!axisLine) {\n      axisLine = createSVG('line');\n      axisLine.setAttribute('data-id', \"tick-\".concat(name, \"-axis-line\"));\n\n      _this.g.appendChild(axisLine);\n    }\n\n    axisLine.setAttribute('stroke', _this.stroke);\n    axisLine.setAttribute('stroke-width', _this.strokeWidth);\n    axisLine.setAttribute('x1', _margins.left);\n    axisLine.setAttribute('x2', width - _margins.right);\n    var scaleY = scales[coords.y][coords.y] || Object.values(scales[coords.y])[0];\n    var zero = isNull(_this._zero) ? scaleY.domain[0] : _this._zero;\n    var axisLineY = scaleY.isLog() ? scaleY.range[1] : scaleY(zero) - (height - _margins.bottom);\n\n    if (scaleY.transformation === 'ordinal' && !~scaleY.domain.indexOf(zero)) {\n      axisLineY = 0;\n    } // console.log(this._zero, '->', scaleY(this._zero),'- (',height,'-',_margins.bottom,')')\n    // console.log('axisLineY', axisLineY)\n\n\n    axisLine.setAttribute('y1', !isNaN(axisLineY) ? axisLineY : 0);\n    axisLine.setAttribute('y2', !isNaN(axisLineY) ? axisLineY : 0); // if no axis remove the axis line after creating it\n\n    if (!_this.showAxisLine) {\n      axisLine.remove();\n    }\n\n    var title = _this.attr('title') ? _this.attr('title')() : null;\n\n    if (!isNull(title)) {\n      var axisTitleText = _this.g.querySelector('text.title');\n\n      if (isNull(axisTitleText)) {\n        axisTitleText = createSVG('text');\n        axisTitleText.classList.add('title');\n      }\n\n      axisTitleText.textContent = title;\n      var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? -1 : 1;\n      var y = (5 + _this.strokeWidth) * orientation;\n      axisTitleText.setAttribute('x', width - _margins.right);\n      axisTitleText.setAttribute('y', y);\n      axisTitleText.setAttribute('dy', \"\".concat(0.9 * ~orientation, \"em\")); // axisTitleText.setAttribute('dx', this.tickPosition === 'outside' ? `${5 * orientation}px` : `${-2 * orientation}px`)\n\n      axisTitleText.setAttribute('text-anchor', 'end'); // axisTitleText.setAttribute(\n      //   'text-anchor',\n      //   this.tickPosition === 'outside'\n      //     ? ~orientation\n      //       ? 'end'\n      //       : 'start'\n      //     : ~orientation\n      //     ? 'start'\n      //     : 'end'\n      // );\n\n      _this.g.appendChild(axisTitleText);\n    }\n\n    var isLog = scales[coords.x][name].isLog();\n\n    _this.g.querySelectorAll('g').forEach(function (d) {\n      var tickName = d.getAttribute('data-id');\n\n      var tick = _this._ticks.find(function (tick) {\n        return tickName === \"tick-\".concat(name, \"-\").concat(tick);\n      });\n\n      if (!tick) {\n        d.remove();\n      }\n    });\n\n    generateTicks.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(\".concat(tick.position, \", 0)\"));\n      xAxisTick(tickGroup, tick.visible);\n    });\n    generateLabels.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(\".concat(tick.position, \", 0)\"));\n      xAxisTick(tickGroup, tick.visibleLabel);\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nxAxis.prototype = Object.create(chrtAxis.prototype);\nxAxis.prototype.constructor = xAxis;\nxAxis.parent = chrtAxis.prototype; // export default xAxis;\n\nfunction xAxis$1 (ticksNumber, customName) {\n  return new xAxis(ticksNumber, customName);\n}\n\nfunction yAxis() {\n  var _this = this;\n\n  var ticksNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n  var customName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';\n\n  // ticksNumber = isNull(ticksNumber) ? TICKS_DEFAULT : ticksNumber;\n  // console.log('Y AXIS', arguments)\n  if (typeof arguments[0] === 'string') {\n    customName = arguments[0];\n    ticksNumber = TICKS_DEFAULT;\n  }\n\n  chrtAxis.call(this, customName, 'y');\n  var name = this.name;\n  this._name = 'y';\n  this._coordinates = 'y';\n  this.orientation = DEFAULT_ORIENTATION[this._name];\n  this._classNames = [].concat(_toConsumableArray(this._classNames), ['chrt-y-axis']);\n  var coords = {\n    x: 'x',\n    y: 'y'\n  };\n\n  var yAxisTick = function yAxisTick(tickGroup, visible) {\n    _this._name = coords.y;\n    name = _this.parentNode.scales[coords.y][_this.name].getName();\n    tickGroup.style.display = visible ? 'block' : 'none';\n    var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? 1 : -1;\n    var tickLine = tickGroup.querySelector('line');\n\n    if (tickLine) {\n      tickLine.setAttribute('x1', 0);\n      tickLine.setAttribute('x2', (_this.tickPosition === 'outside' ? -_this.tickLength : _this.tickLength) * orientation);\n    }\n\n    var label = tickGroup.querySelector('text');\n\n    if (label) {\n      label.setAttribute('text-anchor', _this.labelPosition === 'outside' ? ~orientation ? 'end' : 'start' : ~orientation ? 'start' : 'end');\n      label.setAttribute('x', (_this.labelPosition === 'outside' ? -_this.tickLength : 0) * orientation);\n      label.setAttribute('dx', \"\".concat((_this.labelPosition === 'outside' ? -5 : 5) * orientation, \"px\"));\n      label.setAttribute('dy', _this.labelPosition === 'outside' ? '0.25em' : '-0.3em');\n      label.setAttribute('fill', _this.stroke);\n    }\n  };\n\n  this.draw = function () {\n    _this._name = coords.y; // console.log('Y AXIS this.name', this.name)\n\n    name = _this.parentNode.scales[coords.y][_this.name].getName();\n\n    if (!_this.parentNode.scales[coords.y][name]) {\n      return _this.parentNode;\n    }\n\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        scales = _this$parentNode.scales,\n        width = _this$parentNode.width,\n        height = _this$parentNode.height;\n\n    _this.g.setAttribute('id', \"\".concat(name, \"Axis-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var axisX = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? _margins.left : width - _margins.right;\n\n    _this.g.setAttribute('transform', \"translate(\".concat(axisX, \",0)\"));\n\n    if (_this._label) {\n      _this._label.tickIndex = -1;\n    }\n\n    var ticks = scales[coords.y][name].ticks(_this._fixedTicks || ticksNumber * 2, _this._interval);\n\n    if (_this._label && _this._label.position === 'last') {\n      ticks.reverse();\n    }\n\n    _this._ticks = ticks.map(function (tick, i, arr) {\n      tick.position = scales[coords.y][name](tick.value);\n      var visible = tick.position >= _margins.top && tick.position <= height - _margins.bottom;\n      visible = visible && (_this.showMinorTicks || tick.isZero && _this.showZero || !tick.isMinor);\n      visible = visible && (!isLog || isLog && !tick.isMinor);\n      tick.visible = visible;\n\n      if (_this.ticksFilter) {\n        tick.visible = tick.visible && _this.ticksFilter(tick.value, i, arr);\n      }\n\n      tick.visibleLabel = visible;\n\n      if (_this.labelsFilter) {\n        tick.visibleLabel = tick.visibleLabel && _this.labelsFilter(tick.value, i, arr);\n      } // console.log('---->','tick.visibleLabel', tick.visibleLabel, tick)\n\n\n      tick.label = null;\n\n      if (tick.visibleLabel && _this._label) {\n        if (!isNull(_this._label.value) && _this._label.value === tick.value) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      if (tick.visibleLabel && _this._label && isNull(_this._label.value) && (_this._label.position === 'all' || _this._label.tickIndex === -1)) {\n        if (!isNull(_this._label.position)) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      return tick;\n    }).filter(function (d) {\n      return d.visible || d.visibleLabel;\n    }); // decrease the number of ticks rendered in the DOM\n    // console.log('Y AXIS TICKS', ticks)\n\n    var axisLine = _this.g.querySelector(\"[data-id='tick-\".concat(name, \"-axis-line']\"));\n\n    if (!axisLine) {\n      axisLine = createSVG('line');\n      axisLine.setAttribute('data-id', \"tick-\".concat(name, \"-axis-line\"));\n\n      _this.g.appendChild(axisLine);\n    }\n\n    axisLine.setAttribute('stroke', _this.stroke);\n    axisLine.setAttribute('stroke-width', _this.labelPosition === 'outside' ? _this.strokeWidth : 0);\n    axisLine.setAttribute('x1', 0);\n    axisLine.setAttribute('x2', 0);\n    axisLine.setAttribute('y1', _margins.top);\n    axisLine.setAttribute('y2', height - _margins.bottom); // if no axis remove the axis line after creating it\n\n    if (!_this.showAxisLine) {\n      axisLine.remove();\n    }\n\n    var title = _this.attr('title') ? _this.attr('title')() : null;\n\n    if (!isNull(title)) {\n      var axisTitleText = _this.g.querySelector('text.title');\n\n      if (isNull(axisTitleText)) {\n        axisTitleText = createSVG('text');\n        axisTitleText.classList.add('title');\n      }\n\n      axisTitleText.textContent = title;\n      var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? 1 : -1;\n      var x = (_this.labelPosition === 'outside' ? _this.tickLength : 0) * orientation;\n      axisTitleText.setAttribute('x', x);\n      axisTitleText.setAttribute('y', _margins.top);\n      axisTitleText.setAttribute('dy', _this.labelPosition === 'outside' ? '0.9em' : '-0.9em');\n      axisTitleText.setAttribute('dx', _this.labelPosition === 'outside' ? \"\".concat(5 * orientation, \"px\") : \"\".concat(-2 * orientation, \"px\"));\n      axisTitleText.setAttribute('text-anchor', ~orientation ? 'start' : 'end'); // axisTitleText.setAttribute('text-anchor','start');\n      // axisTitleText.setAttribute(\n      //   'text-anchor',\n      //   this.tickPosition === 'outside'\n      //     ? ~orientation\n      //       ? 'end'\n      //       : 'start'\n      //     : ~orientation\n      //     ? 'start'\n      //     : 'end'\n      // );\n\n      _this.g.appendChild(axisTitleText);\n    }\n\n    var isLog = scales[coords.y][name].isLog();\n\n    _this.g.querySelectorAll('g').forEach(function (d) {\n      var tickName = d.getAttribute('data-id');\n\n      var tick = _this._ticks.find(function (tick) {\n        return tickName === \"tick-\".concat(name, \"-\").concat(tick);\n      });\n\n      if (!tick) {\n        d.remove();\n      }\n    });\n\n    generateTicks.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(0, \".concat(tick.position, \")\"));\n      yAxisTick(tickGroup, tick.visible);\n    });\n    generateLabels.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(0, \".concat(tick.position, \")\"));\n      yAxisTick(tickGroup, tick.visibleLabel);\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nyAxis.prototype = Object.create(chrtAxis.prototype);\nyAxis.prototype.constructor = yAxis;\nyAxis.parent = chrtAxis.prototype; // export default yAxis;\n\nfunction yAxis$1 (ticksNumber, customName) {\n  return new yAxis(ticksNumber, customName);\n}\n\nfunction index (name) {\n  return new chrtAxis(name);\n}\n\nfunction color(value) {\n  return this.attr('fill', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction range(values) {\n  if (isNull(values)) {\n    return this;\n  }\n\n  if (typeof values === 'function') ; else {\n    this._range = Object.assign({}, this._range, values);\n  }\n\n  return this;\n}\nfunction from(value) {\n  return range.call(this, {\n    from: value\n  });\n}\nfunction to(value) {\n  return range.call(this, {\n    to: value\n  });\n}\n\nfunction stroke(value) {\n  return this.attr('stroke', value); // if(!value) {\n  //   return this._stroke;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._stroke = value;\n  // }\n  // return this;\n}\n\nfunction strokeWidth(value) {\n  return this.attr('strokeWidth', value); // if(!value) {\n  //   return this._strokeWidth;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._strokeWidth = value;\n  // }\n  // return this;\n}\n\nfunction lineStyle(value) {\n  return this.attr('lineStyle', value); // return;\n  // if(!value) {\n  //   return this._strokeStyle;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   const strokeWidth = this.attr('strokeWidth')();\n  //   switch(value) {\n  //     case 'dashed':\n  //       this._strokeStyle = `${strokeWidth * 4} ${strokeWidth * 4}`;\n  //       break;\n  //     case 'dotted':\n  //       this._strokeStyle = `${strokeWidth} ${strokeWidth}`;\n  //       break;\n  //     case 'solid':\n  //     default:\n  //       this._strokeStyle = null;\n  //   }\n  // }\n  // return this;\n}\n\nfunction fillOpacity(value) {\n  return this.attr('fillOpacity', value); // if(!value) {\n  //   return this._strokeWidth;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._strokeWidth = value;\n  // }\n  // return this;\n}\n\nvar DEFAULT_FILL_COLOR = '#ddd';\nvar DEFAULT_STROKE = '#000';\nvar DEFAULT_STROKE_OPACITY = 1;\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtAxisRange() {\n  var _this = this;\n\n  // console.log('chrtAxisRange', this)\n  chrtGeneric.call(this);\n  this.type = 'axis-range';\n  this.g = null;\n  this.attr('fill', DEFAULT_FILL_COLOR);\n  this.attr('stroke', DEFAULT_STROKE);\n  this.attr('fillOpacity', DEFAULT_FILL_OPACITY);\n  this.attr('strokeOpacity', DEFAULT_STROKE_OPACITY);\n  this.attr('strokeWidth', DEFAULT_STROKE_WIDTH);\n  this.attr('lineStyle', 'solid');\n  this._range = {};\n  this._classNames = ['chrt-axis-range'];\n\n  this.draw = function () {\n    return _this.parentNode;\n  };\n\n  this.solid = function () {\n    return lineStyle.call(_this, 'solid');\n  };\n\n  this.dashed = function () {\n    return lineStyle.call(_this, 'dashed');\n  };\n\n  this.dotted = function () {\n    return lineStyle.call(_this, 'dotted');\n  };\n\n  this.strokeOpacity = function (value) {\n    return _this.attr('strokeOpacity', value);\n  };\n\n  return this.parentNode;\n}\n\nchrtAxisRange.prototype = Object.create(chrtGeneric.prototype);\nchrtAxisRange.prototype.constructor = chrtAxisRange;\nchrtAxisRange.parent = chrtGeneric.prototype;\nchrtAxisRange.prototype = Object.assign(chrtAxisRange.prototype, {\n  color: color,\n  fill: color,\n  stroke: stroke,\n  strokeWidth: strokeWidth,\n  fillOpacity: fillOpacity,\n  lineStyle: lineStyle,\n  range: range,\n  from: from,\n  to: to\n});\n//   return new chrtAxisRange();\n// }\n\nfunction yAxisRange() {\n  var _this = this;\n\n  chrtAxisRange.call(this);\n  this[\"class\"]('chrt-y-axis-range');\n\n  this.draw = function () {\n    // console.log('chrtAxisRange draw', this);\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.g.setAttribute('data-id', _this._id);\n\n      _this.g.setAttribute('data-name', 'axis-range');\n    }\n\n    if (!_this.parentNode.g.querySelector(\"\".concat(name, \"AxisRange-\").concat(_this.id()))) {\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', \"\".concat(name, \"AxisRange-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var fill = _this.attr('fill')();\n\n    var fillOpacity = _this.attr('fillOpacity')();\n\n    var stroke = _this.attr('stroke')();\n\n    var strokeOpacity = _this.attr('strokeOpacity')();\n\n    var strokeWidth = _this.attr('strokeWidth')();\n\n    var orientation = _this.parentNode.orientation === DEFAULT_ORIENTATION[_this.parentNode._name] ? 1 : -1;\n    var _this$parentNode$pare = _this.parentNode.parentNode,\n        scales = _this$parentNode$pare.scales,\n        width = _this$parentNode$pare.width,\n        _margins = _this$parentNode$pare._margins;\n    var from = null;\n    var to = null;\n\n    if (scales && scales.y[_this.parentNode.name]) {\n      var _scale = scales.y[_this.parentNode.name];\n      from = isNull(_this._range.from) ? from : _scale(_this._range.from);\n      to = isNull(_this._range.to) ? to : _scale(_this._range.to);\n    }\n\n    if (!_this.path) {\n      _this.path = createSVG('path');\n\n      _this.g.appendChild(_this.path);\n    }\n\n    if (isNull(from) && isNull(to)) {\n      return;\n    }\n\n    _this.g.setAttribute('transform', \"translate(\".concat(orientation > 0 ? 0 : -(width - (_margins.right + _margins.left)), \",0)\")); // the range should be at least 1px thick\n\n\n    from = isNull(from) ? to : from;\n    to = isNull(to) ? from : to;\n\n    if (from === to) {\n      _this.path.remove();\n\n      _this.path = null;\n    } else {\n      var d = [[_this.parentNode.strokeWidth, from], [_this.parentNode.strokeWidth, to], [width - (_margins.right + _margins.left), to], [width - (_margins.right + _margins.left), from]];\n\n      _this.path.setAttribute('d', \"M\".concat(d.join('L'), \"z\"));\n\n      _this.path.setAttribute('fill', fill);\n\n      _this.path.setAttribute('fill-opacity', fillOpacity);\n    }\n\n    var strokeStyle = _this.attr('lineStyle')();\n\n    if (!isNull(strokeStyle)) {\n      switch (strokeStyle) {\n        case 'dashed':\n          _this._strokeStyle = \"\".concat(strokeWidth * 4, \" \").concat(strokeWidth * 4);\n          break;\n\n        case 'dotted':\n          _this._strokeStyle = \"\".concat(strokeWidth, \" \").concat(strokeWidth);\n          break;\n\n        case 'solid':\n        default:\n          _this._strokeStyle = null;\n      }\n    }\n\n    var lines = _toConsumableArray(new Set([from, to]));\n\n    if (isNull(_this.lines)) {\n      _this.lines = [];\n    }\n\n    lines.forEach(function (position, index) {\n      if (!_this.lines[index]) {\n        _this.lines[index] = createSVG('line');\n\n        _this.g.appendChild(_this.lines[index]);\n      }\n\n      var line = _this.lines[index];\n      line.setAttribute('x1', _this.parentNode.strokeWidth);\n      line.setAttribute('x2', width - (_margins.left + _margins.right));\n      line.setAttribute('y1', position);\n      line.setAttribute('y2', position);\n      line.setAttribute('stroke', stroke);\n      line.setAttribute('stroke-width', strokeWidth);\n      line.setAttribute('stroke-opacity', strokeOpacity);\n\n      if (!isNull(_this._strokeStyle)) {\n        line.setAttribute('stroke-dasharray', _this._strokeStyle);\n      }\n    });\n    return _this.parentNode;\n  };\n}\n\nyAxisRange.prototype = Object.create(chrtAxisRange.prototype);\nyAxisRange.prototype.constructor = yAxisRange;\nyAxisRange.parent = chrtAxisRange.prototype;\nfunction yAxisRange$1 () {\n  return new yAxisRange();\n}\n\nfunction xAxisRange() {\n  var _this = this;\n\n  chrtAxisRange.call(this);\n  this[\"class\"]('chrt-y-axis-range');\n\n  this.draw = function () {\n    // console.log('chrtAxisRange draw', this);\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.g.setAttribute('data-id', _this._id);\n\n      _this.g.setAttribute('data-name', 'axis-range');\n    }\n\n    if (!_this.parentNode.g.querySelector(\"\".concat(name, \"AxisRange-\").concat(_this.id()))) {\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', \"\".concat(name, \"AxisRange-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var fill = _this.attr('fill')();\n\n    var fillOpacity = _this.attr('fillOpacity')();\n\n    var stroke = _this.attr('stroke')();\n\n    var strokeOpacity = _this.attr('strokeOpacity')();\n\n    var strokeWidth = _this.attr('strokeWidth')();\n\n    var orientation = _this.parentNode.orientation === DEFAULT_ORIENTATION[_this.parentNode._name] ? 1 : -1;\n    var _this$parentNode$pare = _this.parentNode.parentNode,\n        scales = _this$parentNode$pare.scales,\n        height = _this$parentNode$pare.height,\n        _margins = _this$parentNode$pare._margins;\n    var from = null;\n    var to = null;\n\n    if (scales && scales.x[_this.parentNode.name]) {\n      var _scale = scales.x[_this.parentNode.name];\n      from = isNull(_this._range.from) ? from : _scale(_this._range.from);\n      to = isNull(_this._range.to) ? to : _scale(_this._range.to);\n    }\n\n    if (!_this.path) {\n      _this.path = createSVG('path');\n\n      _this.g.appendChild(_this.path);\n    }\n\n    if (isNull(from) && isNull(to)) {\n      return;\n    }\n\n    _this.g.setAttribute('transform', \"translate(0, \".concat(orientation > 0 ? 0 : height - (_margins.top + _margins.bottom) + _this.parentNode.strokeWidth, \")\")); // the range should be at least 1px thick\n\n\n    from = isNull(from) ? to : from;\n    to = isNull(to) ? from : to;\n\n    if (from === to) {\n      _this.path.remove();\n\n      _this.path = null;\n    } else {\n      var d = [[from, -_this.parentNode.strokeWidth], [to, -_this.parentNode.strokeWidth], [to, -(height - (_margins.top + _margins.bottom))], [from, -(height - (_margins.top + _margins.bottom))]];\n\n      _this.path.setAttribute('d', \"M\".concat(d.join('L'), \"z\"));\n\n      _this.path.setAttribute('fill', fill);\n\n      _this.path.setAttribute('fill-opacity', fillOpacity);\n    }\n\n    var strokeStyle = _this.attr('lineStyle')();\n\n    if (!isNull(strokeStyle)) {\n      switch (strokeStyle) {\n        case 'dashed':\n          _this._strokeStyle = \"\".concat(strokeWidth * 4, \" \").concat(strokeWidth * 4);\n          break;\n\n        case 'dotted':\n          _this._strokeStyle = \"\".concat(strokeWidth, \" \").concat(strokeWidth);\n          break;\n\n        case 'solid':\n        default:\n          _this._strokeStyle = null;\n      }\n    }\n\n    var lines = _toConsumableArray(new Set([from, to]));\n\n    if (isNull(_this.lines)) {\n      _this.lines = [];\n    }\n\n    lines.forEach(function (position, index) {\n      if (!_this.lines[index]) {\n        _this.lines[index] = createSVG('line');\n\n        _this.g.appendChild(_this.lines[index]);\n      }\n\n      var line = _this.lines[index];\n      line.setAttribute('x1', position);\n      line.setAttribute('x2', position);\n      line.setAttribute('y1', -_this.parentNode.strokeWidth);\n      line.setAttribute('y2', -(height - (_margins.top + _margins.bottom)));\n      line.setAttribute('stroke', stroke);\n      line.setAttribute('stroke-width', strokeWidth);\n      line.setAttribute('stroke-opacity', strokeOpacity);\n\n      if (!isNull(_this._strokeStyle)) {\n        line.setAttribute('stroke-dasharray', _this._strokeStyle);\n      }\n    });\n    return _this.parentNode;\n  };\n}\n\nxAxisRange.prototype = Object.create(chrtAxisRange.prototype);\nxAxisRange.prototype.constructor = xAxisRange;\nxAxisRange.parent = chrtAxisRange.prototype;\nfunction xAxisRange$1 () {\n  return new xAxisRange();\n}\n\nfunction index$1 () {\n  return new chrtAxisRange();\n}\n\nfunction color$1(value) {\n  return this.attr('fill', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction align(value) {\n  return this.attr('align', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction valign(value) {\n  return this.attr('valign', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction offset(value) {\n  var currentOffset = this.attr('offset')();\n  return this.attr('offset', Object.assign({}, currentOffset || {}, value)); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nvar DEFAULT_COLOR = '#000';\nvar DEFAULT_ALIGNMENT = 'right';\nvar DEFAULT_VERTICAL_ALIGNMENT = 'top';\n\nfunction chrtAxisTitle(text) {\n  var _this = this;\n\n  // console.log('chrtAxisTitle', this, 'text ->', text);\n  chrtGeneric.call(this);\n  this.type = 'axis-title';\n  this.g = null;\n  this.attr('fill', DEFAULT_COLOR);\n  this.attr('align', DEFAULT_ALIGNMENT);\n  this.attr('valign', DEFAULT_VERTICAL_ALIGNMENT);\n  this.attr('offset', {\n    x: 0,\n    y: 0\n  });\n  this._classNames = ['chrt-axis-title'];\n\n  var xAxisDraw = function xAxisDraw() {\n    var fill = _this.attr('fill')(); // const fillOpacity = this.attr('fillOpacity')();\n    // const stroke = this.attr('stroke')();\n    // const strokeOpacity = this.attr('strokeOpacity')();\n    // const strokeWidth = this.attr('strokeWidth')();\n\n\n    var _this$parentNode$pare = _this.parentNode.parentNode,\n        width = _this$parentNode$pare.width,\n        _margins = _this$parentNode$pare._margins;\n    var x = 0;\n    var textAnchor = 'start';\n\n    switch (_this.attr('align')()) {\n      case 'left':\n        x = _margins.left;\n        textAnchor = 'start';\n        break;\n\n      case 'center':\n        x = width / 2;\n        textAnchor = 'middle';\n        break;\n\n      case 'right':\n      default:\n        x = width - _margins.right;\n        textAnchor = 'end';\n    }\n\n    var dy = '0.25em';\n    var y = 0;\n\n    switch (_this.attr('valign')()) {\n      case 'bottom':\n        y = 0;\n        dy = '1em';\n        break;\n\n      case 'middle':\n        y = 0;\n        dy = '0.25em';\n        break;\n\n      case 'top':\n      default:\n        y = 0;\n        dy = '-1em';\n    }\n\n    var offset = _this.attr('offset')();\n\n    _this.text.textContent = text;\n\n    _this.text.setAttribute('text-anchor', textAnchor);\n\n    _this.text.setAttribute('x', x + offset.x);\n\n    _this.text.setAttribute('y', y + offset.y);\n\n    _this.text.setAttribute('dy', dy);\n\n    _this.text.setAttribute('fill', fill);\n  };\n\n  var yAxisDraw = function yAxisDraw() {\n    var fill = _this.attr('fill')(); // const fillOpacity = this.attr('fillOpacity')();\n    // const stroke = this.attr('stroke')();\n    // const strokeOpacity = this.attr('strokeOpacity')();\n    // const strokeWidth = this.attr('strokeWidth')();\n\n\n    var _this$parentNode$pare2 = _this.parentNode.parentNode,\n        height = _this$parentNode$pare2.height,\n        _margins = _this$parentNode$pare2._margins;\n    var x = 0;\n    var textAnchor = 'start';\n\n    switch (_this.attr('align')()) {\n      case 'left':\n        x = -5;\n        textAnchor = 'end';\n        break;\n\n      case 'center':\n      case 'middle':\n        x = 0;\n        textAnchor = 'middle';\n        break;\n\n      case 'right':\n      default:\n        x = 5;\n        textAnchor = 'start';\n    }\n\n    var dy = '0.25em';\n    var y = 0;\n\n    switch (_this.attr('valign')()) {\n      case 'bottom':\n        y = height - _margins.bottom;\n        dy = '0';\n        break;\n\n      case 'center':\n      case 'middle':\n        y = 0;\n        dy = '0.25em';\n        break;\n\n      case 'top':\n      default:\n        y = _margins.top - 1;\n        dy = '0';\n    }\n\n    var offset = _this.attr('offset')();\n\n    _this.text.textContent = text;\n\n    _this.text.setAttribute('text-anchor', textAnchor);\n\n    _this.text.setAttribute('x', x + offset.x);\n\n    _this.text.setAttribute('y', y + offset.y);\n\n    _this.text.setAttribute('dy', dy);\n\n    _this.text.setAttribute('fill', fill);\n  };\n\n  this.draw = function () {\n    // console.log('chrtAxisTitle draw', this);\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.g.setAttribute('data-id', _this._id);\n\n      _this.g.setAttribute('data-name', 'axis-title');\n    }\n\n    if (!_this.parentNode.g.querySelector(\"\".concat(name, \"AxisTitle-\").concat(_this.id()))) {\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', \"\".concat(name, \"AxisTitle-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    }); // if (scales && scales.x[this.parentNode.name]) {\n    //   const _scale = scales.x[this.parentNode.name];\n    //   from = isNull(this._range.from) ? from : _scale(this._range.from);\n    //   to = isNull(this._range.to) ? to : _scale(this._range.to);\n    // }\n\n\n    if (!_this.text) {\n      _this.text = createSVG('text');\n\n      _this.g.appendChild(_this.text);\n    }\n\n    if (_this.parentNode._name === 'x') {\n      xAxisDraw();\n    } else {\n      yAxisDraw();\n    }\n\n    return _this.parentNode;\n  };\n}\n\nchrtAxisTitle.prototype = Object.create(chrtGeneric.prototype);\nchrtAxisTitle.prototype.constructor = chrtAxisTitle;\nchrtAxisTitle.parent = chrtGeneric.prototype;\nchrtAxisTitle.prototype = Object.assign(chrtAxisTitle.prototype, {\n  color: color$1,\n  fill: color$1,\n  align: align,\n  valign: valign,\n  offset: offset\n});\n//   return new chrtAxisTitle();\n// }\n\nfunction index$2 (text) {\n  return new chrtAxisTitle(text);\n}\n\nexport { index as chrtAxis, index$1 as chrtAxisRange, index$2 as chrtAxisTitle, xAxis$1 as xAxis, xAxisRange$1 as xAxisRange, yAxis$1 as yAxis, yAxisRange$1 as yAxisRange };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.13 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nvar TICKS_DEFAULT = 10;\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction lineWidth(value) {\n  if (!value) {\n    return this.strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction lineColor(value) {\n  if (!value) {\n    return this.stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.stroke = value;\n  }\n\n  return this;\n}\n\nfunction lineStyle(value) {\n  this._lineStyle = value;\n\n  if (!value) {\n    return this.strokeStyle;\n  }\n\n  if (typeof value === 'function') ; else {\n    switch (value) {\n      case 'dashed':\n        this.strokeStyle = \"\".concat(this.strokeWidth * 4, \" \").concat(this.strokeWidth * 4);\n        break;\n\n      case 'dotted':\n        this.strokeStyle = \"\".concat(this.strokeWidth, \" \").concat(this.strokeWidth);\n        break;\n\n      case 'solid':\n      default:\n        this.strokeStyle = null;\n    }\n  }\n\n  return this;\n}\n\nfunction minor() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (typeof value === 'function') ; else {\n    this.showMinorTicks = value;\n  }\n\n  return this;\n}\n\nfunction showTicks(filter) {\n  this._filter = filter; // default true\n\n  if (isNull(filter)) {\n    this.ticksFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showTicks((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.ticksFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all ticks\n  // showTicks(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.ticksFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one tick\n  // showTicks(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.ticksFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showTicks([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.ticksFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n} // hideTicks is the opposite of showTicks and it filters out\n\nfunction hideTicks(filter) {\n  showTicks.call(this, filter);\n  var ticksFilter = this.ticksFilter;\n\n  this.ticksFilter = function (d, i, arr) {\n    return !ticksFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  // // console.log('FIRST TICK', this, show)\n  if (show) {\n    showTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nvar DEFAULT_LINE_WIDTH = 1;\nvar DEAULT_LINE_COLOR = '#000';\n\nfunction chrtGrid(type) {\n  var _this = this;\n\n  var ticksNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var name = arguments.length > 2 ? arguments[2] : undefined;\n  chrtGeneric.call(this);\n  this.type = 'grid'; // ticksNumber *= 2;\n  // console.log('GRID', type, ticksNumber, name);\n  // this.type = type;\n\n  this.name = name || type;\n  this.strokeWidth = DEFAULT_LINE_WIDTH;\n  this.stroke = DEAULT_LINE_COLOR;\n  this.showMinorTicks = false;\n  this.ticksFilter = null;\n  this._interval = null;\n\n  var verticalGridLine = function verticalGridLine(gridLine, position, y1, y2) {\n    var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    gridLine.style.display = visible ? 'block' : 'none';\n    gridLine.setAttribute('x1', position);\n    gridLine.setAttribute('x2', position);\n    gridLine.setAttribute('y1', y1);\n    gridLine.setAttribute('y2', y2);\n  };\n\n  var horizontalGridLine = function horizontalGridLine(gridLine, position, x1, x2) {\n    var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    gridLine.style.display = visible ? 'block' : 'none';\n    gridLine.setAttribute('x1', x1);\n    gridLine.setAttribute('x2', x2);\n    gridLine.setAttribute('y1', position);\n    gridLine.setAttribute('y2', position);\n  };\n\n  this.draw = function () {\n    if (!_this.parentNode.scales[type][_this.name]) {\n      return;\n    }\n\n    var _scale = _this.parentNode.scales[type][_this.name];\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        width = _this$parentNode.width,\n        height = _this$parentNode.height;\n\n    var isLog = _scale.isLog();\n\n    var interval = _this._interval;\n\n    var axis = _this.parentNode.getAxis(type);\n\n    if (axis) {\n      interval = axis.interval();\n    }\n\n    var ticks = _scale.ticks(ticksNumber * 2, interval).map(function (tick, i, arr) {\n      tick.position = _scale(tick.value);\n      var visible = tick.position >= _margins.top && tick.position <= height - _margins.bottom;\n\n      if (type === 'x') {\n        visible = tick.position >= _margins.left && tick.position <= width - _margins.right;\n      }\n\n      visible = visible && (_this.showMinorTicks || tick.isZero && _this.showZero || !tick.isMinor);\n      visible = visible && (!isLog || isLog && !tick.isMinor);\n\n      if (_this.ticksFilter) {\n        visible = visible && _this.ticksFilter(tick.value, i, arr);\n      }\n\n      tick.visible = visible;\n      return tick;\n    }); // console.log('GRID!', type, name, 'TICKS', ticks)\n    // .filter(tick => tick.visible) // TO BE REVIEWED\n    // .filter((tick, i, arr) => this.ticksFilter ? this.ticksFilter(tick.value, i, arr) : true);\n    // const ticks = this.parentNode.scales[type].ticks(\n    //   //ticksNumber * (this.showMinorTicks ? 2 : 1)\n    //   ticksNumber * 2\n    // )\n    // // .filter((tick, i, arr) => this.ticksFilter(tick.value, i, arr));\n    // .filter((tick, i, arr) => this.ticksFilter ? this.ticksFilter(tick.value, i, arr) : true);\n    // console.log('got this ticks', type, ticksNumber, ticks);\n\n\n    _this.g.setAttribute('id', \"\".concat(type, \"Grid-\").concat(_this.id()));\n\n    _this.g.querySelectorAll('line').forEach(function (gridLine) {\n      return gridLine.setAttribute('toBeHidden', true);\n    });\n\n    ticks.forEach(function (tick) {\n      var gridLine = _this.g.querySelector(\"[data-id='gridLine-\".concat(type, \"-\").concat(tick.value, \"']\"));\n\n      if (!gridLine) {\n        gridLine = createSVG('line');\n        gridLine.setAttribute('data-id', \"gridLine-\".concat(type, \"-\").concat(tick.value));\n\n        if (tick.isMinor) {\n          gridLine.classList.add('tick-minor');\n        }\n\n        _this.g.appendChild(gridLine);\n      }\n\n      gridLine.setAttribute('stroke', _this.stroke);\n      gridLine.setAttribute('stroke-width', _this.strokeWidth);\n      gridLine.setAttribute('shape-rendering', 'crispEdges');\n\n      if (!isNull(_this.strokeStyle)) {\n        gridLine.setAttribute('stroke-dasharray', _this.strokeStyle);\n      }\n\n      gridLine.removeAttribute('toBeHidden');\n\n      var position = _scale(tick.value);\n\n      if (type === 'x') {\n        // const isLog = this.parentNode.scales[type][name].isLog();\n        // const visible =\n        //   this.showMinorTicks || (!isLog && !tick.isMinor) || (isLog && !tick.isMinor); // TODO: improve this check\n        verticalGridLine(gridLine, position, height - _margins.bottom, _margins.top, tick.visible);\n      }\n\n      if (type === 'y') {\n        // const isLog = this.parentNode.scales[type][name].isLog();\n        // let visible =\n        //   position >= _margins.top && position <= height - _margins.bottom;\n        // visible = visible && (this.showMinorTicks || (tick.isZero && this.showZero) || !tick.isMinor);\n        // visible = visible && ((!isLog) || (isLog && !tick.isMinor));\n        // if(this.ticksFilter) {\n        //   visible = this.ticksFilter(tick.value, i, arr);\n        // }\n        horizontalGridLine(gridLine, position, _margins.left, width - _margins.right, tick.visible);\n      }\n    });\n\n    _this.g.querySelectorAll('line[toBeHidden=true]').forEach(function (gridLine) {\n      return gridLine.remove();\n    });\n\n    return _this.parentNode;\n  };\n\n  this.solid = function () {\n    return lineStyle.call(_this, 'solid');\n  };\n\n  this.dashed = function () {\n    return lineStyle.call(_this, 'dashed');\n  };\n\n  this.dotted = function () {\n    return lineStyle.call(_this, 'dotted');\n  };\n}\n\nfunction grid(type, ticksNumber) {\n  return new chrtGrid(type, ticksNumber);\n}\n\nchrtGrid.prototype = Object.create(chrtGeneric.prototype);\nchrtGrid.prototype.constructor = chrtGrid;\nchrtGrid.parent = chrtGeneric.prototype;\nchrtGrid.prototype = Object.assign(chrtGrid.prototype, {\n  //chrtGrid.prototype = grid.prototype = {\n  width: lineWidth,\n  color: lineColor,\n  minor: minor,\n  firstTick: firstTick,\n  lastTick: lastTick,\n  filter: showTicks\n});\n // export default chrtGrid;\n\nfunction verticalGrid(ticksNumber, name) {\n  return grid.call(this, 'x', ticksNumber, name);\n}\nfunction horizontalGrid(ticksNumber, name) {\n  return grid.call(this, 'y', ticksNumber, name);\n}\n\nexport { grid as chrtGrid, horizontalGrid, verticalGrid };\n","// chrt-line v0.0.17 Copyright 2020-2021 chrt chrt.io\nimport { chrtGeneric } from 'chrt-core';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction lineWidth(value) {\n  if (isNull(value)) {\n    return this.strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction lineColor(value) {\n  if (isNull(value)) {\n    return this.stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.stroke = value;\n  }\n\n  return this;\n}\n\nfunction lineOpacity(value) {\n  if (isNull(value)) {\n    return this.strokeOpacity;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeOpacity = value;\n  }\n\n  return this;\n}\n\nfunction fillColor(value) {\n  if (isNull(value)) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction fillOpacity(value) {\n  if (isNull(value)) {\n    return this._fillOpacity;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fillOpacity = value;\n  }\n\n  return this;\n}\n\nfunction area() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'bottom';\n\n  if (typeof value === 'function') ; else {\n    this._area = value;\n  }\n\n  return this;\n}\n\nfunction zero(value) {\n  if (isNull(value)) {\n    return this._zero;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._zero = value;\n  }\n\n  return this;\n}\n\nfunction sort(value) {\n  if (isNull(value)) {\n    return this._sortedData;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._sortedData = value;\n  }\n\n  return this;\n}\n\nvar DEFAULT_LINE_WIDTH = 1;\nvar DEAULT_LINE_COLOR = '#000';\nvar DEFAULT_LINE_OPACITY = 1;\nvar DEAULT_FILL_COLOR = '#000';\nvar DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtLine() {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log(chrtGeneric)\n  // console.log(this.render)\n\n  this.type = 'series';\n  this._area = false;\n  this._stacked = null;\n  this._sortedData = true;\n  var coords = {\n    x: 'x',\n    y: 'y',\n    x0: 'x0',\n    y0: 'y0'\n  }; // this.fields.y0 = 'y0';\n\n  this.strokeWidth = DEFAULT_LINE_WIDTH;\n  this.stroke = DEAULT_LINE_COLOR;\n  this.strokeOpacity = DEFAULT_LINE_OPACITY;\n  this._fill = DEAULT_FILL_COLOR;\n  this._fillOpacity = DEFAULT_FILL_OPACITY;\n  this.paths = [];\n  this.areaPaths = [];\n  this._classNames = ['chrt-line'];\n\n  this.draw = function () {\n    var _data = _this._data.length ? _this._data : _this.parentNode._data;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    }); //console.log('LINECHART FIELDS', this.fields)\n\n\n    if (isNull(_this.fields[coords.x])) {\n      _this.fields[coords.x] = _this.parentNode.scales[coords.x][_this.scales[coords.x]].field;\n    }\n\n    if (isNull(_this.fields[coords.y])) {\n      //console.log('this.scales', this.scales)\n      //console.log('this.parentNode.scales', this.parentNode.scales)\n      _this.fields[coords.y] = _this.parentNode.scales[coords.y][_this.scales[coords.y]].field;\n    }\n\n    if (isNull(_this.fields[coords.y0])) {\n      _this.fields[coords.y0] = \"\".concat(_this.parentNode.scales[coords.y][_this.scales[coords.y]].field, \"0\");\n    } // console.log('LINECHART FIELDS', this.fields)\n    // console.log('LINECHART COORDS:', coords)\n\n\n    if (!isNull(_data)) {\n      var yDomain = _this.parentNode.scales[coords.y][_this.scales[coords.y]].domain;\n      var xDomain = _this.parentNode.scales[coords.x][_this.scales[coords.x]].domain; // console.log(this.fields.x,coords.x,this.scales,'---->',this.scales[coords.x])\n\n      var _zero = 0;\n\n      switch (_this._area) {\n        case 'left':\n          _zero = xDomain[0] < 0 || xDomain[1] < 0 ? 0 : Math.min.apply(Math, _toConsumableArray(xDomain));\n          break;\n\n        case 'right':\n          _zero = xDomain[0] < 0 || xDomain[1] < 0 ? 0 : Math.max.apply(Math, _toConsumableArray(xDomain));\n          break;\n\n        case 'top':\n          _zero = yDomain[0] < 0 || yDomain[1] < 0 ? 0 : Math.max.apply(Math, _toConsumableArray(yDomain));\n          break;\n\n        case 'bottom':\n        default:\n          _zero = yDomain[0] < 0 || yDomain[1] < 0 ? 0 : Math.min.apply(Math, _toConsumableArray(yDomain));\n      } // let zero = yDomain[0] < 0 || yDomain[1] < 0 ? 0 : Math.min(...yDomain);\n\n\n      _zero = !isNull(_this._zero) ? _this._zero : _zero;\n      _this.hasCustomBaseline = _this._area && _data.some(function (d) {\n        return !isNull(d[_this.fields[coords.y0]]);\n      }); // console.log('hasCustomBaseline', this.hasCustomBaseline)\n\n      var datasetsForLine = _data.reduce(function (acc, d) {\n        var _ref;\n\n        if (isNull(d[_this.fields[coords.y]])) {\n          acc.push([]);\n          return acc;\n        }\n\n        if (!acc.length) {\n          acc.push([]);\n        }\n\n        var datumForLine = _this._stacked || _this.hasCustomBaseline ? (_ref = {}, _defineProperty(_ref, _this.fields[coords.x], d[_this.fields[coords.x]]), _defineProperty(_ref, _this.fields[coords.y], d[_this.fields[coords.y]]), _defineProperty(_ref, \"x\", d[_this.fields[coords.x]]), _defineProperty(_ref, \"y\", _this._stacked ? d[\"stacked_\".concat(_this.fields[coords.y])] : d[_this.fields[coords.y]]), _defineProperty(_ref, \"y0\", !isNull(d[_this.fields[coords.y0]]) ? d[_this.fields[coords.y0]] : _zero), _ref) : d;\n        acc[acc.length - 1].push(datumForLine);\n        return acc;\n      }, []);\n\n      if (_this._sortedData) {\n        var _scaleX = _this.parentNode.scales[coords.x][_this.scales[coords.x]];\n        datasetsForLine.forEach(function (dataset) {\n          dataset.sort(function (a, b) {\n            if (_scaleX.transformation === 'ordinal') {\n              return ( 1) * (_scaleX.domain.indexOf(a[_this.fields[coords.x]]) - _scaleX.domain.indexOf(b[_this.fields[coords.x]]));\n            } else {\n              return ( 1) * (a[_this.fields[coords.x]] - b[_this.fields[coords.x]]);\n            }\n          });\n        });\n      }\n\n      var datasetsForPoints = datasetsForLine.filter(function (dataset) {\n        return dataset.length === 1;\n      });\n      datasetsForLine = datasetsForLine.filter(function (dataset) {\n        return dataset.length > 1;\n      });\n      datasetsForLine.forEach(function (dataset, i) {\n        if (!_this.paths[i]) {\n          _this.paths[i] = createSVG('path');\n\n          _this.paths[i].setAttribute('data-id', \"path-\".concat(i));\n\n          _this.g.appendChild(_this.paths[i]);\n        }\n\n        if (_this._area && !_this.areaPaths[i]) {\n          _this.areaPaths[i] = createSVG('path');\n\n          _this.areaPaths[i].setAttribute('data-id', \"area-path-\".concat(i));\n\n          _this.g.appendChild(_this.areaPaths[i]);\n        }\n      });\n      var datasetsForArea = [];\n\n      if (_this._area) {\n        var horizontalArea = ['left', 'right'].indexOf(_this._area) > -1; // console.log(\n        //   \"AREA\",\n        //   this._area,\n        //   \"zero\",\n        //   zero,\n        //   \"xDomain:\",\n        //   xDomain,\n        //   \"yDomain:\",\n        //   yDomain\n        // );\n\n        datasetsForLine.forEach(function (dataset) {\n          var _ref4, _ref5, _ref6, _ref7;\n\n          var dataForAreaBaseline = _this._stacked || _this.hasCustomBaseline ? _toConsumableArray(dataset).reverse().map(function (d) {\n            var _ref2, _ref3;\n\n            return horizontalArea ? (_ref2 = {\n              x: d[_this.fields[coords.x0]],\n              y: d[_this.fields[coords.y]]\n            }, _defineProperty(_ref2, _this.fields[coords.x0], d[_this.fields[coords.x0]]), _defineProperty(_ref2, _this.fields[coords.y], d[_this.fields[coords.y]]), _ref2) : (_ref3 = {\n              x: d[_this.fields[coords.x]],\n              y: d[_this.fields[coords.y0]]\n            }, _defineProperty(_ref3, _this.fields[coords.x], d[_this.fields[coords.x]]), _defineProperty(_ref3, _this.fields[coords.y0], d[_this.fields[coords.y0]]), _ref3);\n          }) : [horizontalArea ? (_ref4 = {\n            x: _zero,\n            y: dataset[dataset.length - 1][_this.fields[coords.y]]\n          }, _defineProperty(_ref4, _this.fields[coords.x], _zero), _defineProperty(_ref4, _this.fields[coords.y], dataset[dataset.length - 1][_this.fields[coords.y]]), _ref4) : (_ref5 = {\n            x: dataset[dataset.length - 1][_this.fields[coords.x]],\n            y: _zero\n          }, _defineProperty(_ref5, _this.fields[coords.x], dataset[dataset.length - 1][_this.fields[coords.x]]), _defineProperty(_ref5, _this.fields[coords.y], _zero), _ref5), horizontalArea ? (_ref6 = {\n            x: _zero,\n            y: dataset[0][_this.fields[coords.y]]\n          }, _defineProperty(_ref6, _this.fields[coords.x], _zero), _defineProperty(_ref6, _this.fields[coords.y], dataset[0][_this.fields[coords.y]]), _ref6) : (_ref7 = {\n            x: dataset[0][_this.fields[coords.x]],\n            y: _zero\n          }, _defineProperty(_ref7, _this.fields[coords.x], dataset[0][_this.fields[coords.x]]), _defineProperty(_ref7, _this.fields[coords.y], _zero), _ref7)];\n          datasetsForArea.push(dataForAreaBaseline);\n        });\n      }\n\n      if (_this._area && _this.areaPaths.length > 0) {\n        // console.log(\"datasetsForArea\", datasetsForArea);\n        datasetsForArea.forEach(function (dataset, i) {\n          var areaPath = _this.areaPaths[i]; // console.log(\"areaPath\", areaPath);\n\n          var dArea = _this.interpolationFunction([].concat(datasetsForLine[i], dataset)); // console.log(\"dArea\", dArea, 'from', datasetsForLine[i], dataset);\n\n\n          areaPath.setAttribute('d', dArea.join(''));\n          areaPath.setAttribute('fill', _this._fill);\n          areaPath.setAttribute('fill-opacity', _this._fillOpacity);\n          areaPath.setAttribute('stroke', 'none');\n        });\n      } // console.log('LINE CHART', datasetsForLine)\n      // console.log(this)\n\n\n      datasetsForLine.forEach(function (dataset, i) {\n        // console.log('interpolationFunction', this.interpolationFunction)\n        var d = _this.interpolationFunction([].concat(dataset)); // console.log('d', d)\n\n\n        var path = _this.paths[i];\n        path.setAttribute('d', d.join(''));\n        path.setAttribute('stroke', _this.stroke);\n        path.setAttribute('stroke-width', _this.strokeWidth);\n        path.setAttribute('stroke-opacity', _this.strokeOpacity);\n        path.setAttribute('stroke-linejoin', 'round');\n        path.setAttribute('fill', 'none');\n      });\n      datasetsForPoints.forEach(function (dataset) {\n        var singlePoints = dataset.filter(function (d, i, points) {\n          return (isNull(points[i - 1]) || isNull(points[i - 1][_this.fields[coords.y]])) && !isNull(d[_this.fields[coords.y]]) && (isNull(points[i + 1]) || isNull(points[i + 1][_this.fields[coords.y]]));\n        }); // TODO: if the data changes and new single points are added they won't be rendered\n\n        if (!_this.points) {\n          _this.points = [];\n          singlePoints.forEach(function (point) {\n            var circle = createSVG('circle');\n\n            _this.points.push({\n              circle: circle,\n              point: point\n            });\n\n            _this.g.appendChild(circle);\n          });\n        }\n\n        _this.points.forEach(function (d) {\n          d.circle.setAttribute('cx', _this.parentNode.scales[coords.x][_this.scales[coords.x]](d.point[_this.fields[coords.x]]));\n          d.circle.setAttribute('cy', _this.parentNode.scales[coords.y][_this.scales[coords.y]](d.point[_this.fields[coords.y]]));\n          d.circle.setAttribute('fill', _this.stroke);\n          d.circle.setAttribute('r', _this.strokeWidth);\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtLine.prototype = Object.create(chrtGeneric.prototype);\nchrtLine.prototype.constructor = chrtLine;\nchrtLine.parent = chrtGeneric.prototype;\nchrtLine.prototype = Object.assign(chrtLine.prototype, {\n  width: lineWidth,\n  color: lineColor,\n  opacity: lineOpacity,\n  area: area,\n  fill: fillColor,\n  fillOpacity: fillOpacity,\n  zero: zero,\n  sort: sort\n}); // export default chrtLine;\n\nfunction chrtLine$1 () {\n  return new chrtLine();\n}\n\nexport { chrtLine$1 as chrtLine };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.17 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction isInfinity(value) {\n  return !isFinite(value);\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction lineWidth(value) {\n  return this.attr('strokeWidth', value, function (value) {\n    return Math.max(0, value);\n  });\n}\n\nfunction lineColor(value) {\n  return this.attr('stroke', value);\n}\n\nfunction fillColor(value) {\n  return this.attr('fill', value);\n}\n\n// export default function width(value) {\n//   if(!value) {\n//     return this.barRatioWidth;\n//   }\n//\n//   if (typeof value === 'function') {\n//     // something will go here\n//   } else {\n//     this.barRatioWidth = value;\n//   }\n//   return this;\n// }\nfunction width(value) {\n  return this.attr('barRatioWidth', value, function (value) {\n    return Math.max(0, Math.min(value, 1));\n  });\n}\n\nvar DEFAULT_STROKE_WIDTH = 0;\nvar DEAULT_LINE_COLOR = '#000';\nvar DEAULT_FILL_COLOR = '#ddd';\nvar DEFAULT_BAR_WIDTH = 3;\nvar DEFAULT_BAR_RADIO_WIDTH = 1;\n\nfunction chrtBars() {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'series';\n  this._stacked = null;\n  this._grouped = 1;\n  this._groupIndex = 0; //this.strokeWidth = DEFAULT_STROKE_WIDTH;\n\n  var _barWidth = DEFAULT_BAR_WIDTH;\n  this.attr('barRatioWidth', DEFAULT_BAR_RADIO_WIDTH);\n  this.attr('stroke', DEAULT_LINE_COLOR);\n  this.attr('fill', DEAULT_FILL_COLOR);\n  this.attr('strokeWidth', DEFAULT_STROKE_WIDTH);\n  this._classNames = ['chrt-bars'];\n\n  this.getXScale = function () {\n    if (isNull(_this.fields.x)) {\n      _this.fields.x = _this.parentNode.scales.x[_this.scales.x].field;\n    }\n\n    return _this.parentNode.scales.x[_this.scales.x];\n  };\n\n  this.barWidth = function () {\n    return _barWidth;\n  };\n\n  this.draw = function () {\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        scales = _this$parentNode.scales;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    if (isNull(_this.fields.y)) {\n      _this.fields.y = scales.y[_this.scales.y].field;\n    }\n\n    if (isNull(_this.fields.x)) {\n      //console.log('this.scales', this.scales)\n      //console.log('this.parentNode.scales', this.parentNode.scales)\n      _this.fields.x = scales.x[_this.scales.x].field;\n    }\n\n    if (isNull(_this.fields.x0)) {\n      _this.fields.x0 = \"\".concat(scales.x[_this.scales.x].field, \"0\");\n    }\n\n    var _scaleX = scales.x[_this.scales.x];\n    var _scaleY = scales.y[_this.scales.y]; // console.log('_scaleY.barwidth', _scaleY.barwidth)\n\n    var _data = _this._data.length ? _this._data : _this.parentNode._data;\n\n    if (!isNull(_data)) {\n      _barWidth = _data.reduce(function (acc, d, i, arr) {\n        var next = arr[i + 1];\n\n        if (!isNull(d) && !isNull(d[_this.fields.y]) && !isNull(next) && !isNull(next[_this.fields.y])) {\n          var y1 = _scaleY(d[_this.fields.y]);\n\n          var y2 = _scaleY(next[_this.fields.y]);\n\n          var delta = Math.abs(y2 - y1);\n          acc = delta < acc ? delta : acc;\n        }\n\n        return acc;\n      }, Math.abs(_scaleY.barwidth)); // console.log('_barWidth', _barWidth)\n\n      var flooredBarWidth = Math.floor(_barWidth);\n      var barWidth = flooredBarWidth || _barWidth || 0;\n\n      if (isNaN(barWidth) || isInfinity(barWidth)) {\n        barWidth = 1;\n      }\n\n      barWidth = barWidth * (_this._group ? _this._group.width() : 1); //console.log('GROUP WIDTH', this._group ? this._group.width() : 1)\n\n      var _grouped = _this._stacked ? _this._stacked._grouped : _this._grouped || _this._grouped;\n\n      var _groupIndex = _this._stacked ? _this._stacked._groupIndex : _this._groupIndex || _this._groupIndex;\n\n      _barWidth = barWidth / _grouped * _this.attr('barRatioWidth')(); // this.g.setAttribute('transform', `translate(${barWidth / _grouped * _groupIndex + (barWidth/_grouped)/2 - barWidth/2}, 0)`)\n\n      _this.g.setAttribute('transform', \"translate(0, \".concat(barWidth / _grouped * _groupIndex + barWidth / _grouped / 2 - barWidth / 2, \")\")); // console.log(barWidth, _grouped, _groupIndex)\n\n\n      var yAxis = _this.parentNode.getAxis('y');\n\n      var axisLineWidth = yAxis ? yAxis.width() : 0;\n\n      _data.forEach(function (d, i, arr) {\n        // const point = points.find(p => )\n        var rect = _this.g.querySelector(\"[data-id='rect-\".concat(name, \"-\").concat(i, \"']\"));\n\n        if (!rect) {\n          rect = createSVG('rect');\n          rect.setAttribute('data-id', \"rect-\".concat(name, \"-\").concat(i)); // rect.setAttribute('shape-rendering', 'crispEdges');\n\n          _this.g.appendChild(rect);\n        }\n\n        var y = _scaleY(d[_this.fields.y]) - _barWidth / 2;\n\n        if (isNaN(y)) {\n          return;\n        }\n\n        var x = _scaleX(d[_this._stacked ? \"stacked_\".concat(_this.fields.x) : _this.fields.x]); // const y0 = _scaleY(0);\n\n\n        var x0 = !isNull(d[_this.fields.x0]) ? _scaleX.isLog() ? _scaleX.range[0] + _margins.left : _scaleX(d[_this.fields.x0]) : null;\n\n        if (isNull(x0)) {\n          x0 = _scaleX.isLog() ? _scaleX.range[0] + _margins.left : _scaleX(0);\n        }\n\n        x0 = !isNull(d[_this.fields.x0]) ? _scaleX(d[_this.fields.x0]) : _scaleX(_scaleX.domain[0]); // console.log('isLog', _scaleX.isLog(), x0,'<',x)\n        // console.log('--->', d, y0)\n\n        rect.setAttribute('x', x0); // > x0 ? x0 : x);\n\n        rect.setAttribute('y', y);\n        rect.setAttribute('width', Math.max(Math.abs(x - x0), Math.abs(x - x0) - axisLineWidth / 2));\n        rect.setAttribute('height', _barWidth);\n        rect.setAttribute('fill', _this.attr('fill')(d, i, arr));\n        rect.setAttribute('stroke', _this.attr('stroke')(d, i, arr));\n        rect.setAttribute('stroke-width', _this.attr('strokeWidth')(d, i, arr));\n      }); // // // console.log('points', points);\n\n    }\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtBars.prototype = Object.create(chrtGeneric.prototype);\nchrtBars.prototype.constructor = chrtBars;\nchrtBars.parent = chrtGeneric.prototype;\nchrtBars.prototype = Object.assign(chrtBars.prototype, {\n  width: width,\n  strokeWidth: lineWidth,\n  color: lineColor,\n  fill: fillColor\n}); // export default chrtBars;\n\nfunction chrtBars$1 () {\n  return new chrtBars();\n}\n\nvar DEFAULT_STROKE_WIDTH$1 = 0;\nvar DEAULT_LINE_COLOR$1 = '#000';\nvar DEAULT_FILL_COLOR$1 = '#ddd';\nvar DEFAULT_BAR_WIDTH$1 = 3;\nvar DEFAULT_BAR_RADIO_WIDTH$1 = 1;\n\nfunction chrtColumns() {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'series';\n  this._stacked = null;\n  this._grouped = 1;\n  this._groupIndex = 0; //this.strokeWidth = DEFAULT_STROKE_WIDTH;\n\n  var _barWidth = DEFAULT_BAR_WIDTH$1;\n  this.attr('barRatioWidth', DEFAULT_BAR_RADIO_WIDTH$1);\n  this.attr('stroke', DEAULT_LINE_COLOR$1);\n  this.attr('fill', DEAULT_FILL_COLOR$1);\n  this.attr('strokeWidth', DEFAULT_STROKE_WIDTH$1);\n  this._classNames = ['chrt-columns'];\n\n  this.getXScale = function () {\n    if (isNull(_this.fields.x)) {\n      _this.fields.x = _this.parentNode.scales.x[_this.scales.x].field;\n    }\n\n    return _this.parentNode.scales.x[_this.scales.x];\n  };\n\n  this.draw = function () {\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        scales = _this$parentNode.scales;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    if (isNull(_this.fields.x)) {\n      _this.fields.x = scales.x[_this.scales.x].field;\n    }\n\n    if (isNull(_this.fields.y)) {\n      //console.log('this.scales', this.scales)\n      //console.log('this.parentNode.scales', this.parentNode.scales)\n      _this.fields.y = scales.y[_this.scales.y].field;\n    }\n\n    if (isNull(_this.fields.y0)) {\n      _this.fields.y0 = \"\".concat(scales.y[_this.scales.y].field, \"0\");\n    }\n\n    var _scaleX = scales.x[_this.scales.x];\n    var _scaleY = scales.y[_this.scales.y];\n\n    var _data = _this._data.length ? _this._data : _this.parentNode._data;\n\n    if (!isNull(_data)) {\n      _barWidth = _data.reduce(function (acc, d, i, arr) {\n        var next = arr[i + 1];\n\n        if (!isNull(d) && !isNull(d[_this.fields.x]) && !isNull(next) && !isNull(next[_this.fields.x])) {\n          var x1 = _scaleX(d[_this.fields.x]);\n\n          var x2 = _scaleX(next[_this.fields.x]);\n\n          var delta = Math.abs(x2 - x1);\n          acc = delta < acc ? delta : acc;\n        }\n\n        return acc;\n      }, _scaleX.barwidth);\n      var flooredBarWidth = Math.floor(_barWidth);\n      var barWidth = flooredBarWidth || _barWidth || 0;\n\n      if (isNaN(barWidth) || isInfinity(barWidth)) {\n        barWidth = 1;\n      }\n\n      barWidth = barWidth * (_this._group ? _this._group.width() : 1); // console.log('GROUP WIDTH', this._group ? this._group.width() : 1)\n\n      var _grouped = _this._stacked ? _this._stacked._grouped : _this._grouped || _this._grouped;\n\n      var _groupIndex = _this._stacked ? _this._stacked._groupIndex : _this._groupIndex || _this._groupIndex;\n\n      _barWidth = barWidth / _grouped * _this.attr('barRatioWidth')();\n      var deltaX = barWidth / _grouped * _groupIndex + barWidth / _grouped / 2 - barWidth / 2;\n\n      _this.g.setAttribute('transform', \"translate(\".concat(deltaX, \", 0)\"));\n\n      var xAxis = _this.parentNode.getAxis('x');\n\n      var axisLineWidth = xAxis ? xAxis.width() : 0;\n\n      _data.forEach(function (d, i, arr) {\n        // const point = points.find(p => )\n        var rect = _this.g.querySelector(\"[data-id='rect-\".concat(name, \"-\").concat(i, \"']\"));\n\n        if (!rect) {\n          rect = createSVG('rect');\n          rect.setAttribute('data-id', \"rect-\".concat(name, \"-\").concat(i)); // rect.setAttribute('shape-rendering', 'crispEdges');\n\n          _this.g.appendChild(rect);\n        }\n\n        var x = _scaleX(d[_this.fields.x]) - _barWidth / 2;\n\n        if (isNaN(x)) {\n          return;\n        }\n\n        var y = _scaleY(d[_this._stacked ? \"stacked_\".concat(_this.fields.y) : _this.fields.y]); // const y0 = _scaleY(0);\n\n\n        var y0 = !isNull(d[_this.fields.y0]) ? _scaleY(d[_this.fields.y0]) : null;\n\n        if (isNull(y0)) {\n          y0 = _scaleY.isLog() ? _scaleY.range[0] - _margins.bottom : _scaleY(0);\n        } // console.log('--->', d, y0)\n\n\n        rect.setAttribute('x', x);\n        rect.setAttribute('y', y > y0 ? y0 : y);\n        rect.setAttribute('width', _barWidth);\n        rect.setAttribute('height', Math.max(Math.abs(y - y0), Math.abs(y - y0) - axisLineWidth / 2));\n        rect.setAttribute('fill', _this.attr('fill')(d, i, arr));\n        rect.setAttribute('stroke', _this.attr('stroke')(d, i, arr));\n        rect.setAttribute('stroke-width', _this.attr('strokeWidth')(d, i, arr));\n      }); // // // console.log('points', points);\n\n    }\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtColumns.prototype = Object.create(chrtGeneric.prototype);\nchrtColumns.prototype.constructor = chrtColumns;\nchrtColumns.parent = chrtGeneric.prototype;\nchrtColumns.prototype = Object.assign(chrtColumns.prototype, {\n  width: width,\n  strokeWidth: lineWidth,\n  color: lineColor,\n  fill: fillColor\n});\nfunction chrtColumns$1 () {\n  return new chrtColumns();\n}\n\nexport { chrtBars$1 as chrtBars, chrtColumns$1 as chrtColumns };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.10 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction pointSize(value) {\n  return this.attr('radius', value);\n}\n\nfunction pointColor(value) {\n  return this.attr('fill', value);\n}\n\nfunction pointStroke(value) {\n  return this.attr('stroke', value);\n}\n\nfunction pointStrokeWidth(value) {\n  return this.attr('strokeWidth', value);\n}\n\nfunction pointOpacity(value) {\n  return this.attr('fillOpacity', value);\n}\n\nfunction strokeOpacity(value) {\n  return this.attr('strokeOpacity', value);\n}\n\nvar DEFAULT_POINT_SIZE = 3;\nvar DEFAULT_POINT_COLOR = '#000';\n\nfunction chrtPoints() {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'series'; // this.size = DEFAULT_POINT_SIZE;\n  // this.fill = DEFAULT_POINT_COLOR;\n  // this.stroke = DEFAULT_POINT_COLOR;\n  // this.strokeWidth = 0;\n  // this._opacity = 1;\n\n  this.attr('radius', DEFAULT_POINT_SIZE);\n  this.attr('stroke', DEFAULT_POINT_COLOR);\n  this.attr('fill', DEFAULT_POINT_COLOR);\n  this.attr('strokeWidth', 0);\n  this.attr('strokeOpacity', 1);\n  this.attr('fillOpacity', 1);\n  this._classNames = ['chrt-points'];\n\n  this.draw = function () {\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    if (!isNull(_this._data)) {\n      if (isNull(_this.fields.x)) {\n        _this.fields.x = _this.parentNode.scales.x[_this.scales.x].field;\n      }\n\n      if (isNull(_this.fields.y)) {\n        //console.log('this.scales', this.scales)\n        //console.log('this.parentNode.scales', this.parentNode.scales)\n        _this.fields.y = _this.parentNode.scales.y[_this.scales.y].field;\n      }\n\n      _this._data.forEach(function (d, i, arr) {\n        // const point = points.find(p => )\n        var circle = _this.g.querySelector(\"[data-id='circle-\".concat(name, \"-\").concat(i, \"']\"));\n\n        if (!circle) {\n          circle = createSVG('circle');\n          circle.setAttribute('data-id', \"circle-\".concat(name, \"-\").concat(i));\n\n          _this.g.appendChild(circle);\n        }\n\n        if (!isNull(_this.parentNode.scales.x[_this.scales.x]) && !isNull(_this.parentNode.scales.y[_this.scales.y])) {\n          var x = _this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]);\n\n          var y = _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y]);\n\n          circle.setAttribute('cx', !isNaN(x) ? x : 0);\n          circle.setAttribute('cy', !isNaN(y) ? y : 0);\n          circle.setAttribute('r', _this.attr('radius')(d, i, arr));\n          circle.setAttribute('fill', _this.attr('fill')(d, i, arr));\n          circle.setAttribute('fill-opacity', _this.attr('fillOpacity')(d, i, arr) || 1);\n          circle.setAttribute('stroke', _this.attr('stroke')(d, i, arr));\n          circle.setAttribute('stroke-width', _this.attr('strokeWidth')(d, i, arr));\n          circle.setAttribute('stroke-opacity', _this.attr('strokeOpacity')(d, i, arr));\n        }\n      }); // // // console.log('points', points);\n\n    }\n\n    return _this.parentNode;\n  };\n}\n\nchrtPoints.prototype = Object.create(chrtGeneric.prototype);\nchrtPoints.prototype.constructor = chrtPoints;\nchrtPoints.parent = chrtGeneric.prototype;\nchrtPoints.prototype = Object.assign(chrtPoints.prototype, {\n  pointSize: pointSize,\n  size: pointSize,\n  radius: pointSize,\n  color: pointColor,\n  stroke: pointStroke,\n  width: pointStrokeWidth,\n  strokeWidth: pointStrokeWidth,\n  opacity: pointOpacity,\n  strokeOpacity: strokeOpacity\n}); // export default chrtPoints;\n\nfunction chrtPoints$1 () {\n  return new chrtPoints();\n}\n\nexport { chrtPoints$1 as chrtPoints };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt-label v0.0.17 Copyright 2020-2021 chrt chrt.io\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction color(value) {\n  if (isNull(value)) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction position(coords) {\n  if (isNull(coords)) {\n    return this._position;\n  }\n\n  if (typeof coords === 'function') ; else {\n    this._position = Object.assign({}, this._position, coords);\n  }\n\n  return this;\n}\nfunction top(y) {\n  if (isNull(y)) {\n    return this.position().y;\n  }\n\n  return position.call(this, {\n    y: y\n  });\n}\nfunction left(x) {\n  if (isNull(x)) {\n    return this.position().x;\n  }\n\n  return position.call(this, {\n    x: x\n  });\n}\n\nfunction alignment(align) {\n  if (isNull(align)) {\n    return this._alignment;\n  }\n\n  if (typeof coords === 'function') ; else {\n    this._alignment = Object.assign({}, this._alignment, align);\n  }\n\n  return this;\n}\nfunction valign(position) {\n  if (isNull(position)) {\n    return this._alignment.vertical;\n  }\n\n  var vertical = this._alignment.vertical;\n\n  switch (position) {\n    case 'top':\n      vertical = '-0.7em';\n      break;\n\n    case 'bottom':\n      vertical = '1em';\n      break;\n\n    case 'middle':\n    default:\n      vertical = '0.25em';\n  }\n\n  this._vposition = position;\n  return alignment.call(this, {\n    vertical: vertical\n  });\n}\nfunction align(position) {\n  if (isNull(position)) {\n    return this._alignment.horizontal;\n  }\n\n  var horizontal = this._alignment.horizontal;\n\n  switch (position) {\n    case 'end':\n    case 'right':\n      this._alignment.horizontal = 'end';\n      horizontal = 'end';\n      break;\n\n    case 'middle':\n    case 'center':\n      this._alignment.horizontal = 'middle';\n      horizontal = 'middle';\n      break;\n\n    case 'left':\n    default:\n      horizontal = 'start';\n  }\n\n  this._hposition = position;\n  return alignment.call(this, {\n    horizontal: horizontal\n  });\n}\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this;\n}\n\nfunction offset() {\n  for (var _len = arguments.length, offsets = new Array(_len), _key = 0; _key < _len; _key++) {\n    offsets[_key] = arguments[_key];\n  }\n\n  if (isNull(offsets)) {\n    return this._offsets;\n  }\n\n  var topOffset = offsets[0],\n      leftOffset = offsets[1];\n  var top = this._offsets[0];\n\n  if (!isNull(topOffset)) {\n    top = typeof topOffset === 'function' ? topOffset : function () {\n      return topOffset;\n    };\n  }\n\n  var left = this._offsets[1];\n\n  if (!isNull(leftOffset)) {\n    left = typeof leftOffset === 'function' ? leftOffset : function () {\n      return leftOffset;\n    };\n  }\n\n  this._offsets = [top, left];\n  /*\n  console.log('!!! offset', top, left)\n  if(!isNull(top) && typeof top === 'function') {\n   } else {\n    console.log('offset.top is not a f')\n    top = () => 123;\n  }\n  if(!isNull(left) && typeof left === 'function') {\n   } else {\n    left = () => left;\n  }\n  this._offsets[0] = !isNull(top) ? top  : this._offsets[0];\n  this._offsets[1] = !isNull(left) ? left  : this._offsets[1];\n   console.log('SO OFFSET', this._offsets)\n  */\n\n  return this;\n}\n\nfunction outside(value) {\n  return this.attr('outside', value);\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nvar DEFAULT_FILL_COLOR = '#000';\n\nfunction chrtLabel(text) {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log('chrtLabel', this);\n\n  this.type = 'label';\n  this.g = null;\n  this._fill = null;\n  this._position = {};\n  this._alignment = {\n    horizontal: 'start',\n    vertical: '0.25em'\n  };\n  this._vposition = 'middle';\n  this._hposition = 'start';\n  this._margins = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  this._offsets = [function () {\n    return 0;\n  }, function () {\n    return 0;\n  }];\n  this._classNames = ['chrt-label'];\n\n  this.value = function (text) {\n    return _this.attr('text', text);\n  };\n\n  this.value(text);\n\n  this.draw = function () {\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', _this.id());\n\n    var scales = _this.parentNode.parentNode.scales;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var getPosition = function getPosition(position) {\n      return function (field) {\n        // console.log('getPosition', position, field)\n        if (isNull(position[field])) {\n          if (!isNull(_this.parentNode._data) && _this.parentNode._data.length) {\n            // console.log('--->', this.parentNode._data)\n            return _this.parentNode._data[_this.parentNode._data.length - 1][field];\n          } else {\n            return 0;\n          }\n        }\n\n        return position[field];\n      };\n    };\n\n    if (scales && scales.x[_this.parentNode.scales.x]) {\n      var x = scales.x[_this.parentNode.scales.x](getPosition(_this._position)(_this.parentNode.fields.x)) + _this._margins.left - _this._margins.right + _this._offsets[1](); // console.log('x', x, this._margins)\n      // if y is not defined by the user, it should be calculated based on the closest Y value based on X\n\n\n      var y = scales.y[_this.parentNode.scales.y](getPosition(_this._position)(_this.parentNode.fields.y)) + _this._margins.top - _this._margins.bottom + _this._offsets[0]();\n\n      _this.g.setAttribute('transform', \"translate(\".concat(isNaN(x) ? 0 : x, \",\").concat(isNaN(y) ? 0 : y, \")\")); // console.log('drawing label', this._offsets[0](), this._offsets[1]())\n\n    }\n\n    var label = _this.g.querySelector('text');\n\n    if (!label) {\n      label = createSVG('text');\n      label.setAttribute('data-id', \"label-\".concat(_this.attr('text')()));\n\n      _this.g.appendChild(label);\n    }\n\n    label.setAttribute('fill', _this._fill || _this.parentNode.stroke || DEFAULT_FILL_COLOR);\n    label.textContent = _this.attr('text')();\n    var textAnchor = _this._alignment.horizontal;\n\n    if (_this.outside() && _this.outside()()) {\n      textAnchor = textAnchor === 'start' ? 'end' : 'start';\n    }\n\n    label.setAttribute('text-anchor', textAnchor);\n    label.setAttribute('dy', _this._alignment.vertical); // console.log('---->', chrtGeneric.prototype)\n    // console.log('--->', chrtGeneric.hasData.call(this))\n  };\n}\n\nchrtLabel.prototype = Object.create(chrtGeneric.prototype); // console.log('WHAT IS THIS?')\n// console.log(Object.create(chrtGeneric.prototype))\n\nchrtLabel.prototype.constructor = chrtLabel; // chrtLabel.parent = chrtGeneric.prototype;\n\nchrtLabel.prototype = Object.assign(chrtLabel.prototype, {\n  color: color,\n  position: position,\n  top: top,\n  left: left,\n  align: align,\n  valign: valign,\n  margins: setMargins,\n  offset: offset,\n  outside: outside\n}); // export default chrtLabel;\n\nfunction chrtLabel$1 (text) {\n  return new chrtLabel(text);\n}\n\n// const DEFAULT_FILL_COLOR = '#000';\n// const DEFAULT_STROKE = '#000';\n// const DEFAULT_STROKE_OPACITY = 1;\n// const DEFAULT_STROKE_WIDTH = 1;\n// const DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtLabels() {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log(\"HI WE ARE LABELS\", this);\n\n  this.type = 'labels';\n  this.labels = [];\n  this.g = null;\n\n  this.labelsFilter = function () {\n    return true;\n  };\n\n  this._alignment = {\n    horizontal: 'end',\n    vertical: 'middle'\n  };\n  this._hposition = 'middle';\n  this._vposition = 'top'; // const isOutside = () => {\n  //   return this.attrs['outside'];\n  // }\n\n  this.value = function (field) {\n    return _this.attr('textField', field);\n  };\n\n  this.position = function (position) {\n    return _this.attr('position', position);\n  };\n\n  this.draw = function () {\n    var parentData = _this.parentNode.data();\n\n    var data = parentData.length ? parentData : _this.parentNode.parentNode._data || [];\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    var isBars = _this.parentNode.constructor.name === 'chrtBars';\n    data.forEach(function (label, i) {\n      // console.log(this._alignment.horizontal, label);\n      // console.log(this.parentNode.fields.x0)\n      // console.log(this.parentNode.getXScale())\n      var top = label[_this.parentNode.fields.y];\n      var x0 = !isNull(label[_this.parentNode.fields.x0]) ? label[_this.parentNode.fields.x0] : _this.parentNode.getXScale().domain[0];\n      var left = x0;\n\n      switch (_this._alignment.horizontal) {\n        case 'start':\n          break;\n\n        case 'end':\n          left = label[_this.parentNode.fields.x] + x0;\n          break;\n\n        case 'center':\n        case 'middle':\n          left = (label[_this.parentNode.fields.x] + x0) / 2;\n          break;\n      }\n\n      left = isBars ? left : label[_this.parentNode.fields.x];\n      var offsets = {\n        top: function top() {\n          switch (_this._vposition) {\n            case 'top':\n              return isBars ? -(_this.parentNode.barWidth() || 0) / 2 : 0;\n\n            case 'bottom':\n              return isBars ? (_this.parentNode.barWidth() || 0) / 2 : 0;\n\n            case 'center':\n            case 'middle':\n              return 0;\n          }\n        }\n      };\n\n      if (!_this.labels[i]) {\n        // if the marker exists, just update its data\n        // this.markers[i].marker = marker;\n        _this.labels[i] = chrtLabel$1();\n\n        _this.parentNode.add(_this.labels[i]);\n      }\n\n      var textFieldAccessor = _this.attr('textField');\n\n      var textField = !isNull(textFieldAccessor) ? textFieldAccessor(label) : label[_this.parentNode.fields.y]; // console.log('LABELS CLASS', this.class().join(' '), this.class());\n\n      var classNames = _this[\"class\"]();\n\n      if (classNames.length) {\n        _this.labels[i][\"class\"](classNames.join(' '));\n      }\n\n      _this.labels[i].value(textField).top(top).left(left).align(_this._hposition).valign(_this._vposition).offset(offsets.top || 0,  0).outside(_this.outside());\n    });\n    return _this.parentNode;\n  };\n}\n\nchrtLabels.prototype = Object.create(chrtGeneric.prototype);\nchrtLabels.prototype.constructor = chrtLabels;\nchrtLabels.parent = chrtGeneric.prototype;\nchrtLabels.prototype = Object.assign(chrtLabels.prototype, {\n  align: align,\n  valign: valign,\n  outside: outside\n});\nfunction chrtLabels$1 () {\n  return new chrtLabels();\n}\n\nexport { chrtLabel$1 as chrtLabel, chrtLabels$1 as chrtLabels };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt-markers v0.0.11 Copyright 2020-2021 chrt chrt.io\nimport { chrtGeneric } from 'chrt-core';\n\nfunction size(value) {\n  if (!value) {\n    return this._radius * 2;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._radius = value / 2;\n  }\n\n  return this;\n}\n\nfunction fill(value) {\n  if (!value) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction stroke(value) {\n  if (!value) {\n    return this._stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._stroke = value;\n  }\n\n  return this;\n}\n\nfunction strokeWidth(value) {\n  if (!value) {\n    return this._strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction showMarkers(filter) {\n  // default true\n  if (isNull(filter)) {\n    this.markersFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showMarkers((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.markersFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all markers\n  // showMarkers(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.markersFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one marker\n  // showMarkers(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.markersFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showMarkers([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.markersFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n}\nfunction hideMarkers(filter) {\n  showMarkers.call(this, filter);\n  var markersFilter = this.markersFilter;\n\n  this.markersFilter = function (d, i, arr) {\n    return !markersFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstMarker() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  // // console.log('FIRST TICK', this, show)\n  if (show) {\n    showMarkers.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideMarkers.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastMarker() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showMarkers.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideMarkers.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\nfunction firstAndLastMarkers() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showMarkers.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  } else {\n    hideMarkers.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nvar DEFAULT_RADIUS = 2;\nvar DEFAULT_FILL_COLOR = '#000';\nvar DEFAULT_STROKE = '#000';\nvar DEFAULT_STROKE_OPACITY = 1;\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtMarkers() {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log('HI WE ARE MARKERS', this);\n\n  this.type = 'markers';\n  this.markers = [];\n  this.g = null;\n\n  this.markersFilter = function () {\n    return true;\n  };\n\n  this.draw = function () {\n    // console.log('DRAW MARKERS', this.parentNode.data(), this.parentNode.parentNode._data);\n    // console.log(this)\n    var parentData = _this.parentNode.data(); // this might be broken when only local data to the component is updated - to be tested\n\n\n    var data = parentData.length ? parentData : _this.parentNode.parentNode._data || [];\n    var radius = _this._radius || DEFAULT_RADIUS;\n    var fill = _this._fill || _this.parentNode.stroke || DEFAULT_FILL_COLOR;\n    var opacity = _this._opacity || _this.parentNode.strokeOpacity || DEFAULT_FILL_OPACITY;\n    var stroke = _this._stroke || _this.parentNode.stroke || DEFAULT_STROKE;\n    var strokeOpacity = _this._strokeOpacity || _this.parentNode.strokeOpacity || DEFAULT_STROKE_OPACITY;\n    var strokeWidth = _this._strokeWidth || _this.parentNode.strokeWidth || DEFAULT_STROKE_WIDTH;\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    data.forEach(function (marker, i) {\n      if (_this.markers[i]) {\n        // if the marker exists, just update its data\n        _this.markers[i].marker = marker;\n      } else {\n        // if the marker does not exists, create a new one\n        var circle = createSVG('circle');\n\n        _this.markers.push({\n          circle: circle,\n          marker: marker\n        });\n\n        _this.g.appendChild(circle);\n      }\n    });\n\n    _this.markers.filter(function (marker, i, arr) {\n      return _this.markersFilter(marker.marker, i, arr);\n    }).forEach(function (d) {\n      var cx = _this.parentNode.parentNode.scales.x[_this.parentNode.scales.x](d.marker[_this.parentNode.fields.x]);\n\n      d.circle.setAttribute('cx', isNaN(cx) ? 0 : cx);\n\n      var cy = _this.parentNode.parentNode.scales.y[_this.parentNode.scales.y](d.marker[_this.parentNode.fields.y]);\n\n      d.circle.setAttribute('cy', isNaN(cy) ? 0 : cy);\n      d.circle.setAttribute('fill', fill);\n      d.circle.setAttribute('fill-opacity', opacity);\n      d.circle.setAttribute('r', radius);\n      d.circle.setAttribute('stroke', stroke);\n      d.circle.setAttribute('stroke-width', strokeWidth);\n      d.circle.setAttribute('stroke-opacity', strokeOpacity);\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtMarkers.prototype = Object.create(chrtGeneric.prototype);\nchrtMarkers.prototype.constructor = chrtMarkers;\nchrtMarkers.parent = chrtGeneric.prototype;\nchrtMarkers.prototype = Object.assign(chrtMarkers.prototype, {\n  fill: fill,\n  size: size,\n  stroke: stroke,\n  strokeWidth: strokeWidth,\n  showMarkers: showMarkers,\n  hideMarkers: hideMarkers,\n  firstMarker: firstMarker,\n  lastMarker: lastMarker,\n  firstAndLastMarkers: firstAndLastMarkers\n}); // export default chrtMarkers;\n\nfunction chrtMarkers$1 () {\n  return new chrtMarkers();\n}\n\nexport { chrtMarkers$1 as chrtMarkers };\n","// chrt.io v0.0.11 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction color(value) {\n  if (!value) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction position(coords) {\n  if (isNull(coords)) {\n    return this;\n  } // console.log('position', coords)\n\n\n  if (typeof coords === 'function') ; else {\n    this._position = Object.assign({}, this._position, coords);\n  }\n\n  return this;\n}\nfunction top(y) {\n  return position.call(this, {\n    y: y\n  });\n}\nfunction left(x) {\n  return position.call(this, {\n    x: x\n  });\n}\n\nfunction alignment(align) {\n  if (isNull(align)) {\n    return this;\n  }\n\n  console.log('alignment', align);\n\n  if (typeof coords === 'function') ; else {\n    this._alignment = Object.assign({}, this._alignment, align);\n  }\n\n  return this;\n}\nfunction valign(position) {\n  var vertical = this._alignment.vertical;\n\n  switch (position) {\n    case 'top':\n      vertical = '-0.7em';\n      break;\n\n    case 'bottom':\n      vertical = '1em';\n      break;\n\n    default:\n      vertical = '0.25em';\n  }\n\n  return alignment.call(this, {\n    vertical: vertical\n  });\n}\nfunction align(position) {\n  var horizontal = this._alignment.horizontal;\n\n  switch (position) {\n    case 'right':\n      horizontal = 'end';\n      break;\n\n    case 'center':\n      horizontal = 'middle';\n      break;\n\n    default:\n      horizontal = 'start';\n  }\n\n  return alignment.call(this, {\n    horizontal: horizontal\n  });\n}\n\nfunction offset() {\n  for (var _len = arguments.length, offsets = new Array(_len), _key = 0; _key < _len; _key++) {\n    offsets[_key] = arguments[_key];\n  }\n\n  if (isNull(offsets)) {\n    return this._offsets;\n  }\n\n  var top = offsets[0],\n      left = offsets[1];\n  this._offsets[0] = !isNull(top) ? top : this._offsets[0];\n  this._offsets[1] = !isNull(left) ? left : this._offsets[1];\n  return this;\n}\n\nfunction create(tag) {\n  return document.createElement(tag);\n}\n\nfunction chrtAnnotation(text) {\n  var _this = this;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    x: 'x',\n    y: 'y'\n  };\n  chrtGeneric.call(this);\n  this.type = 'annnotation';\n  this.div = null;\n  this.text = text;\n  this._fill = null;\n  this._position = {};\n  this._alignment = {\n    horizontal: 'start',\n    vertical: '0.25em'\n  };\n  this._offsets = [0, 0];\n  this._classNames = ['chrt-annotation']; // console.log('chrtAnnotation', options)\n\n  this.draw = function () {\n    if (!_this.parentNode.scales) {\n      return _this.parentNode;\n    } // TODO: probably should be the last one\n\n\n    var scales = {\n      x: _this.parentNode.scales.x[options.x] || Object.values(_this.parentNode.scales.x)[0],\n      y: _this.parentNode.scales.y[options.y] || Object.values(_this.parentNode.scales.y)[0]\n    }; // console.log('options', options)\n    // console.log('scales', scales)\n\n    if (!_this.div) {\n      _this.div = create('div');\n\n      _this.parentNode.root.appendChild(_this.div);\n\n      _this.div.style.position = 'absolute';\n    }\n\n    _this.div.setAttribute('id', _this.id());\n\n    _this._classNames.forEach(function (d) {\n      return _this.div.classList.add(d);\n    });\n\n    if (scales && scales['x']) {\n      var x = isNull(_this._position.x) ? 0 : scales.x(_this._position.x); // if y is not defined by the user, it should be calculated based on the closest Y value based on X\n\n      var y = isNull(_this._position.y) ? 0 : scales.y(_this._position.y);\n      _this.div.style.left = \"\".concat(x + _this._offsets[0], \"px\");\n      _this.div.style.top = \"\".concat(y + _this._offsets[1], \"px\");\n    }\n\n    var label = _this.div.querySelector('span');\n\n    if (!label) {\n      label = create('span');\n\n      _this.div.appendChild(label);\n    }\n\n    label.innerHTML = text;\n  };\n}\n\nchrtAnnotation.prototype = Object.create(chrtGeneric.prototype);\nchrtAnnotation.prototype.constructor = chrtAnnotation;\nchrtAnnotation.parent = chrtGeneric.prototype;\nchrtAnnotation.prototype = Object.assign(chrtAnnotation.prototype, {\n  color: color,\n  position: position,\n  top: top,\n  left: left,\n  align: align,\n  valign: valign,\n  offset: offset\n}); // export default chrtAnnotation;\n\nfunction chrtAnnotation$1 (text, options) {\n  return new chrtAnnotation(text, options);\n}\n\nexport { chrtAnnotation$1 as chrtAnnotation };\n","<script>\n  import { onMount } from \"svelte\";\n  \n  import * as chrt from \"chrt\";\n  import {yAxis, xAxis, yAxisRange} from 'chrt-axis';\n  import { chrtAnnotation } from \"chrt-annotation\";\n  \n  export let data;\n  export let id;\n  export let label;\n  // export let title;\n  export let charts;\n  export let position;\n\n  const W = 750;\n  const H = 150;\n  const MONTHS = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'];\n\n  let el;\n\n  const chart = chrt.Chrt();\n\n  const labelFormat = (d) => `Week ${new Date(data[id][d].startDay).getMonth() + 1}/${new Date(data[id][d].startDay).getDate()}`;\n\n  onMount(() => {\n    const max = Math.max(... data[id].map(d => d.value));\n    const maxObj = data[id].find(d => d.value === max);\n    const maxIndex = data[id].findIndex(d => d.value === max);\n    const min = Math.min(... data[id].map(d => d.value));\n    const minObj = data[id].find(d => d.value === min);\n    const minIndex = data[id].findIndex(d => d.value === min);\n    \n    // console.log('CHART', id, data[id], max, maxObj);\n\n    chart\n      .node(el)\n      .svg()\n      .size(W, H)\n      .margins({\n        bottom: 30,\n        left: 0,\n        right: 0,\n      })\n      .padding({\n        left: 30,\n        right: 30,\n        top: 30,\n      })\n      .x(null, null)\n      .y([Math.min(0, ...data[id].map(d => d.value)), null]);\n\n    chart.add(\n      chrt\n        .chrtColumns()\n        .fill(d => ((d.value === max) ? 'url(#stripes2)' : ((d.value === min) ? 'url(#stripes3)' : 'url(#stripes)')))\n        .color(d => ((d.value === max) ? '#444' : '#444'))\n        .strokeWidth(1)\n        .width(.6)\n        .data(data[id], (d, i) => ({\n          x: i, //new Date(d.startDay),\n          y: d.value,\n          startDay: new Date(d.startDay),\n          endDay: new Date(d.endDay),\n        }))\n    );\n    if (position == 0) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('top')\n          .setTickPosition(\"outside\")\n          .setLabelPosition('outside')\n          .class('axis-label')\n          .format((d) => labelFormat(d))\n          .color('#444')\n          .width(1)\n      ).add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .hideTicks()\n          .hideLabels()\n          .color('#444')\n          .width(1)\n      );\n    }\n    if (position < charts - 1 && position > 0) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .hideTicks()\n          .hideLabels()\n          .color('#444')\n          .width(1)\n      )\n    } \n    if (position == charts - 1) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .setTickPosition(\"outside\")\n          .setLabelPosition('outside')\n          .class('axis-label')\n          .format((d) => labelFormat(d))\n          .color('#444')\n          .width(1)\n      );\n    }\n\n    chart.add(\n      yAxis()\n        .hideAxis()\n        .hideLabels()\n        .hideTicks()\n        .add(yAxisRange()\n          .dashed()\n          .stroke('#444')\n          .strokeWidth(1)\n          .from(max)\n        )\n        // ).add(\n        //   chrt.chrtAxisTitle(title)\n        //   .class('title')\n        //   .offset({ x:5, y:-5 })\n        //   .align('right')\n        // )\n    );\n\n    chart.add(\n      chrtAnnotation(`<div>${label}: ${new Intl.NumberFormat('en-EN').format(maxObj.value)}</div>`)\n      .top(max)\n      .left(maxIndex)\n    );\n\n    chart.add(\n      chrtAnnotation(`<div>${new Intl.NumberFormat('en-EN').format(data[id][data[id].length -1].value)}</div>`)\n      .top(data[id][data[id].length -1].value)\n      .left(data[id].length -1)\n      .class('thisWeek')\n    );\n  });\n</script>\n\n<div class=\"chart\" id=\"{id}\" bind:this={el}>\n  <div class=\"axis-label\"><g><text /></g></div>\n</div>\n\n<style>\n  .chart {\n    display: block;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n  }\n</style>\n","<script>\n\timport { onMount } from 'svelte';\n\timport axios from 'axios';\n\n\timport Chart from './Chart.svelte';\n\n\tconst DATA_SOURCE = 'https://corona.elezioni.io/data';\n\tconst START_DATE = '2020-12-25'; // First Friday of the year\n\tconst CHARTS = [\n\t\t{\n\t\t\tid: 'cases',\n\t\t\tlabel: 'Highest Number of<br /><span>New Cases</span>',\n\t\t\ttitle: 'New Cases',\n\t\t},\n\t\t{\n\t\t\tid: 'hospitals',\n\t\t\tlabel: 'Highest Increment of<br /><span>Hospital Bed occupancy</span>',\n\t\t\ttitle: 'Hospital Bed occupancy',\n\t\t},\n\t\t{\n\t\t\tid: 'icus',\n\t\t\tlabel: 'Highest Increment of<br /><span>ICU Beds occupancy</span>',\n\t\t\ttitle: 'ICU Bed occupancy',\n\t\t},\n\t\t{\n\t\t\tid: 'fatalities',\n\t\t\tlabel: 'Highest Number of<br /><span>Fatalities</span>',\n\t\t\ttitle: 'Fatalities',\n\t\t},\n\t\t{\n\t\t\tid: 'tests',\n\t\t\tlabel: 'Highest Number of<br /><span>Tests Performed</span>',\n\t\t\ttitle: 'Tests',\n\t\t},\n\t];\n\t\n\tlet data;\n\n\tonMount(async () => {\n\t\tconst rawData = {\n\t\t\tepicenters: [],\n\t\t\tgenerated: '',\n\t\t\titaly: {\n\t\t\t\tglobal: [],\n\t\t\t\tprovinces: [],\n\t\t\t\tregions: [],\n\t\t\t},\n\t\t\ttested: [],\n\t\t};\n\n\t\tconst italy = {\n\t\t\tcases: [],\n\t\t\tfatalities: [],\n\t\t\ttests: [],\n\t\t\ticus: [],\n\t\t\thospitals: [],\n\t\t};\n\n\t\tconst fetchData = async () => {\n\t\t\tconst getItalia = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/italia`);\n\t\t\t}\n\n\t\t\tconst getRegioni = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/regioni`);\n\t\t\t}\n\n\t\t\tconst getRegioni2020 = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/regioni2020`);\n\t\t\t}\n\n\t\t\tconst getProvince = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/province`);\n\t\t\t}\n\n      Promise.all([getItalia(), getRegioni(), getProvince(), getRegioni2020()]).then((results) => {\n\t\t\t\tif (!results[0].data.error) {\n\t\t\t\t\t\trawData.italy.global = results[0].data.data.italy.global;\n\t\t\t\t\t\trawData.tested = results[0].data.data.tested;\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\t\t\t\tif (!results[1].data.error) {\n\t\t\t\t\t\trawData.italy.regions = results[1].data.data.italy.regions;\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\t\t\t\tif (!results[2].data.error) {\n\t\t\t\t\t\trawData.italy.provinces = results[2].data.data.italy.provinces;\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\t\t\t\tif (!results[3].data.error) {\n\t\t\t\t\t\trawData.italy.regions = rawData.italy.regions.concat(results[3].data.data.italy.regions).sort((a,b) => a.datetime > b.datetime ? 1 : -1);\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\n\n\n\t\t\t\tconst italy_filtered = rawData.italy.global.filter(d => d.datetime >= START_DATE);\n\t\t\t\tlet tmpCases = {};\n\t\t\t\tlet tmpFatalities = {};\n\t\t\t\tlet tmpIcus = {};\n\t\t\t\tlet tmpHospitals = {};\n\t\t\t\tlet tmpTests = {};\n\n\t\t\t\t// console.log('italy_filtered', italy_filtered);\n\n\t\t\t\titaly_filtered.forEach((d, i) => {\n\t\t\t\t\tconst startDay = new Date(d.datetime);\n\t\t\t\t\tconst thisDay = startDay.getDay();\n\t\t\t\t\tif (thisDay === 5) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\titaly.cases.push(tmpCases);\n\t\t\t\t\t\t\titaly.fatalities.push(tmpFatalities);\n\t\t\t\t\t\t\titaly.icus.push(tmpIcus);\n\t\t\t\t\t\t\titaly.hospitals.push(tmpHospitals);\n\t\t\t\t\t\t\titaly.tests.push(tmpTests);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst endDay = new Date(d.datetime);\n\t\t\t\t\t\tendDay.setDate(endDay.getDate() + 6);\n\t\t\t\t\t\ttmpCases = {\n\t\t\t\t\t\t\tavg: d.new_tested_positive,\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: d.new_tested_positive,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpFatalities = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.deaths : d.deaths - (italy_filtered[i -1].deaths),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.deaths : d.deaths - (italy_filtered[i -1].deaths),\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpIcus = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.icu : d.icu - (italy_filtered[i -1].icu),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.icu : d.icu - (italy_filtered[i -1].icu),\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpHospitals = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.hospital : d.hospital - (italy_filtered[i -1].hospital),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.hospital : d.hospital - (italy_filtered[i -1].hospital),\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpTests = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.tested : d.tested - (italy_filtered[i -1].tested),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.tested : d.tested - (italy_filtered[i -1].tested),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmpCases.avg = (tmpCases.avg + d.new_tested_positive) / 7;\n\t\t\t\t\t\ttmpCases.value = tmpCases.value + d.new_tested_positive;\n\t\t\t\t\t\ttmpFatalities.avg = (tmpFatalities.avg + d.deaths - (italy_filtered[i -1].deaths)) / 7;\n\t\t\t\t\t\ttmpFatalities.value = tmpFatalities.value + d.deaths - (italy_filtered[i -1].deaths);\n\t\t\t\t\t\ttmpIcus.avg = (tmpIcus.avg + d.icu - (italy_filtered[i -1].icu)) / 7;\n\t\t\t\t\t\ttmpIcus.value = tmpIcus.value + d.icu - (italy_filtered[i -1].icu);\n\t\t\t\t\t\ttmpHospitals.avg = (tmpHospitals.avg + d.hospital - (italy_filtered[i -1].hospital)) / 7;\n\t\t\t\t\t\ttmpHospitals.value = tmpHospitals.value + d.hospital - (italy_filtered[i -1].hospital);\n\t\t\t\t\t\ttmpTests.avg = (tmpTests.avg + d.tested - (italy_filtered[i -1].tested)) / 7;\n\t\t\t\t\t\ttmpTests.value = tmpTests.value + d.tested - (italy_filtered[i -1].tested);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// console.log('italy', italy);\n\n\t\t\t\titaly.cases.shift();\n\t\t\t\titaly.hospitals.shift();\n\t\t\t\titaly.icus.shift();\n\t\t\t\titaly.fatalities.shift();\n\t\t\t\titaly.tests.shift();\n\t\t\t\tdata = JSON.parse(JSON.stringify(italy));\n      }).catch((e) => {\n\t\t\t\tconsole.log(\"error\", e);\n\t\t\t});\n\t\t}\n\n\t\tfetchData();\n  });\n</script>\n\n<main>\n\t<div class=\"wrapper\">\n\t\t<h1>Weekly Progression since January 1<span>st</span>, 2021</h1>\n\t\t{#if data !== undefined}\n\t\t\t{#each CHARTS as chart, i}\n\t\t\t\t<div class=\"chart\" id=\"wrapper-{chart.id}\">\n\t\t\t\t\t<Chart id=\"{chart.id}\" data=\"{data}\" title=\"{chart.title}\" label=\"{chart.label}\" position=\"{i}\" charts=\"{CHARTS.length}\" />\n\t\t\t\t</div>\n\t\t\t{/each}\n\t\t{/if}\n\t\t<h4>Data from Italian Civil Protection.\n\t\t\tWeeks are computed from Friday to Friday, the day the Italian Government and the Italian Scientific Committee review COVID-Related Data.</h4>\n\t</div>\n\t<div class=\"assets\">\n\t\t<svg>\n\t\t\t<defs>\n\t\t\t\t<pattern\n\t\t\t\t\tid=\"stripes\"\n\t\t\t\t\twidth=\"5px\"\n\t\t\t\t\theight=\"5px\"\n\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\tpatternContentUnits=\"userSpaceOnUse\"\n\t\t\t\t\tviewBox=\"0 0 100 100\"\n\t\t\t\t\tpreserveAspectRatio=\"none\"\n\t\t\t\t\tpatternTransform=\"rotate(-45)\"\n\t\t\t\t>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"100\"\n\t\t\t\t\t\ty1=\"46\"\n\t\t\t\t\t\ty2=\"46\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"100\"\n\t\t\t\t\t\ty1=\"92\"\n\t\t\t\t\t\ty2=\"92\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"46\"\n\t\t\t\t\t\tx2=\"46\"\n\t\t\t\t\t\ty1=\"0\"\n\t\t\t\t\t\ty2=\"100\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"92\"\n\t\t\t\t\t\tx2=\"92\"\n\t\t\t\t\t\ty1=\"0\"\n\t\t\t\t\t\ty2=\"100\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t</pattern>\n\t\t\t\t<pattern\n\t\t\t\t\tid=\"stripes2\"\n\t\t\t\t\twidth=\"5px\"\n\t\t\t\t\theight=\"5px\"\n\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\tpatternContentUnits=\"userSpaceOnUse\"\n\t\t\t\t\tviewBox=\"0 0 140 140\"\n\t\t\t\t\tpreserveAspectRatio=\"none\"\n\t\t\t\t\tpatternTransform=\"rotate(-45)\"\n\t\t\t\t>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"140\"\n\t\t\t\t\t\ty1=\"70\"\n\t\t\t\t\t\ty2=\"70\"\n\t\t\t\t\t\tstroke-width=\"30\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t</pattern>\n\t\t\t\t<pattern\n\t\t\t\t\tid=\"stripes3\"\n\t\t\t\t\twidth=\"5px\"\n\t\t\t\t\theight=\"5px\"\n\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\tpatternContentUnits=\"userSpaceOnUse\"\n\t\t\t\t\tviewBox=\"0 0 140 140\"\n\t\t\t\t\tpreserveAspectRatio=\"none\"\n\t\t\t\t\tpatternTransform=\"rotate(45)\"\n\t\t\t\t>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"140\"\n\t\t\t\t\t\ty1=\"70\"\n\t\t\t\t\t\ty2=\"70\"\n\t\t\t\t\t\tstroke-width=\"30\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t</pattern>\n\t\t\t</defs>\n\t\t</svg>\n\t</div>\n</main>\n\n<style>\n\n\t.wrapper {\n\t\tbackground: #fff;\n\t\tborder: 1px solid #444;\n\t\tdisplay: block;\n\t\theight: auto;\n\t\tmargin: 40px auto;\n\t\tposition: relative;\n\t\twidth: 750px;\n\t}\n\n\th1 {\n\t\tdisplay: block;\n\t\tfont-size: 18px;\n\t\tfont-weight: 400;\n\t\theight: 50px;\n\t\tletter-spacing: .1em;\n\t\tline-height: 30px;\n\t\tmargin:0;\n\t\ttext-align: center;\n\t\ttext-transform: uppercase;\n\t}\n\n\th4 {\n\t\tdisplay: block;\n\t\tfont-size: 10px;\n\t\tfont-weight: 400;\n\t\tletter-spacing: .1em;\n\t\tline-height: 1.25;\n\t\tmargin: 0;\n\t\tpadding: 20px 40px;\n\t\ttext-align: center;\n\t}\n\n\th1 span {\n\t\ttext-transform: lowercase;\n\t}\n\n\t.chart {\n\t\t/* border-bottom: 1px solid #444; */\n\t\tdisplay: block;\n\t\theight: 150px;\n\t\tposition: relative;\n\t\twidth: 750px;\n\t}\n\n\t.chart:nth-child(odd) {\n\t\tbackground: #fcfcfc;\n\t}\n\n\t.chart:last-child {\n\t\tborder-bottom: inherit;\n\t}\n\n\t.assets {\n\t\theight: 0;\n\t\topacity: 0;\n\t\toverflow: hidden;\n\t\twidth: 0;\n\t}\n</style>","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","attr","attribute","value","removeAttribute","getAttribute","setAttribute","current_component","set_current_component","component","onMount","Error","get_current_component","$$","on_mount","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","i","length","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","d","mount_component","customElement","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","[object Object]","this","$destroy","type","index","indexOf","splice","$$props","obj","$$set","keys","thisArg","args","arguments","apply","toString","prototype","isArray","val","call","isUndefined","isObject","isPlainObject","getPrototypeOf","isFunction","key","hasOwnProperty","isArrayBuffer","isBuffer","constructor","isFormData","FormData","isArrayBufferView","ArrayBuffer","isView","buffer","isString","isNumber","isDate","isFile","isBlob","isStream","pipe","isURLSearchParams","URLSearchParams","isStandardBrowserEnv","navigator","product","window","merge","result","assignValue","slice","extend","bind","trim","str","replace","stripBOM","content","charCodeAt","encode","encodeURIComponent","url","params","paramsSerializer","serializedParams","utils","parts","v","toISOString","JSON","stringify","join","hashmarkIndex","InterceptorManager","handlers","use","fulfilled","rejected","eject","id","h","headers","__CANCEL__","normalizedName","toUpperCase","message","config","code","request","response","error","isAxiosError","toJSON","description","number","fileName","lineNumber","columnNumber","stack","enhanceError","write","expires","path","domain","secure","cookie","Date","toGMTString","read","match","RegExp","decodeURIComponent","remove","now","ignoreDuplicateOf","originURL","msie","test","userAgent","urlParsingNode","resolveURL","href","protocol","host","search","hash","hostname","port","pathname","charAt","location","requestURL","parsed","reject","requestData","requestHeaders","XMLHttpRequest","auth","username","password","unescape","Authorization","btoa","baseURL","requestedURL","fullPath","relativeURL","combineURLs","open","method","buildURL","timeout","onreadystatechange","readyState","status","responseURL","responseHeaders","getAllResponseHeaders","split","line","substr","toLowerCase","concat","responseType","responseText","statusText","validateStatus","createError","settle","onabort","onerror","ontimeout","timeoutErrorMessage","xsrfValue","withCredentials","isURLSameOrigin","xsrfCookieName","cookies","undefined","xsrfHeaderName","setRequestHeader","e","onDownloadProgress","addEventListener","onUploadProgress","upload","cancelToken","promise","cancel","abort","send","DEFAULT_CONTENT_TYPE","Content-Type","setContentTypeIfUnset","adapter","defaults","process","require$$0","transformRequest","normalizeHeaderName","transformResponse","parse","maxContentLength","maxBodyLength","common","Accept","throwIfCancellationRequested","throwIfRequested","transformData","reason","isCancel","config1","config2","valueFromConfig2Keys","mergeDeepPropertiesKeys","defaultToConfig2Keys","directMergeKeys","getMergedValue","source","mergeDeepProperties","prop","axiosKeys","otherKeys","Axios","instanceConfig","interceptors","mergeConfig","chain","dispatchRequest","interceptor","unshift","shift","getUri","Cancel","CancelToken","executor","TypeError","resolvePromise","token","createInstance","defaultConfig","axios","require$$1","require$$2","all","promises","spread","arr","payload","baseLog","base","Math","E","log","log10","log2","y","getBaseLog","x","LOG10E","LOG2E","pow10","isFinite","basePow","exp","pow","DEFAULT_WIDTH","TICKS_DEFAULT","COMPONENTS_W_DATA","isNull","hasNull","values","some","hasNaN","isNaN","uuid","random","substring","hasData","arraysEqual","array1","array2","every","console","warn","accessor","_data","_accessor","_orginalData","accessorFunction","assign","root","currentNode","g","memoize","func","cache","size","_len","dimensions","_key","width","height","oldWidth","oldHeight","svg","querySelector","style","_slicedToArray","_arrayWithHoles","Symbol","iterator","_arr","_n","_d","_e","_s","_i","next","done","err","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayLikeToArray","_arrayWithoutHoles","iter","_iterableToArray","_nonIterableSpread","minLen","n","len","arr2","_createForOfIteratorHelper","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","return","createSVG","tag","createElementNS","ExtendedWilkinson","_ref","_this","_ref2","dmin","dmax","ticksN","Q","onlyLoose","w","nice","eps","Number","EPSILON","_ticks","temp","best","score","ticks","ticksNumber","range","j","Infinity","_step","_iterator","q","sm","simplicity","max","k","dm","density","delta","z","ceil","cm","coverage","min_start","floor","max_start","start","lmin","lmax","lstep","legibility","getMin","getMax","getStep","rt","min","span","half","scale","field","_scale","scales","fixedDomain","copyOfFixedDomain","_padding","left","bottom","right","top","currentDomain","isLog","domainExtent","objects","fields","eNumScale","domainWidth","direction","rangeWidth","_margins","startCoord","scalingFunction","valueToDomain","fixedTicks","isMinor","isZero","getName","getType","transformation","getField","barwidth","logTicks","improveRange","ticksRange","tick","_k","_tick","scale$1","numScale","getTransformation","scale$2","UNITS","second","minute","DURATION_SECOND","hour","day","unit","LONGER_UNITS","bidiurnal","week","fortnight","month","year","scale$3","calculateTimeDomain","interval","_domainExtent","seconds","abs","d0","d1","getFullYear","getMonth","roundedDomainExtent","setTimeInterval","_domainWidth","startingYear","_startingYear","Chrt","_node","_scaleLinear","oldDomain","oldRange","_scaleLog","_scaleOrdinal","_scaleTime","getAxis","orientation","find","prefix","_css","classList","css","chrt","add$1","prepend","_id","parent","linearInterpolation","points","command","paths","lineCommand","reduce","acc","point","render","_stacked","_group","rollup","svgNode","border","setWidth","setHeight","margins","padding","chrtGeneric","_classNames","interpolationFunction","attrs","className","classNames","setScale","scaleName","chrtStack","_grouped","_groupIndex","_orientation","_dataMap","chart","dataFunction","y0","x0","stacked_y","stacked_x","draw","chrtGroup","generateTicks","tickGroup","showAxisLine","tickLine","stroke","strokeWidth","group","curve","ORIENTATIONS","DEFAULT_ORIENTATION","showAxis","showTicks","ticksFilter","hideTicks","showLabels","labelsFilter","hideLabels","chrtAxis","updater","tickTextColor","tickLength","tickPosition","labelPosition","labelFormat","showMinorTicks","_zero","showZero","_label","_fixedTicks","_interval","_coordinates","generateLabels","labels","labelGroup","label","textContent","labelTextColor","xAxis","customName","_name","coords","xAxisTick","visible","display","_this$parentNode","tickIndex","position","reverse","visibleLabel","axisY","axisLine","scaleY","zero","axisLineY","title","axisTitleText","querySelectorAll","tickName","xAxis$1","yAxis","yAxisTick","axisX","color","_range","lineStyle","setTickLength","setTickPosition","setLabelPosition","hideAxis","filterTicks","firstTick","show","lastTick","firstAndLastTicks","_labels","_fixedLabels","filterLabels","firstLabel","lastLabel","firstAndLastLabels","orient","format","minor","hideZero","chrtAxisRange","solid","dashed","dotted","strokeOpacity","yAxisRange","fillOpacity","_this$parentNode$pare","to","strokeStyle","_strokeStyle","lines","xAxisRange","color$1","chrtAxisTitle","textAnchor","dy","offset","xAxisDraw","_this$parentNode$pare2","yAxisDraw","align","valign","currentOffset","_lineStyle","_filter","DEAULT_LINE_COLOR","chrtGrid","verticalGridLine","gridLine","y1","y2","horizontalGridLine","x1","x2","axis","_defineProperty","defineProperty","enumerable","configurable","writable","chrtLine","_area","_sortedData","_fill","_fillOpacity","areaPaths","yDomain","xDomain","hasCustomBaseline","datasetsForLine","datumForLine","_scaleX","dataset","sort","datasetsForPoints","datasetsForArea","horizontalArea","_ref4","_ref5","_ref6","_ref7","dataForAreaBaseline","_ref3","areaPath","dArea","singlePoints","circle","opacity","area","isInfinity","lineWidth","lineColor","fillColor","chrtBars","_barWidth","getXScale","barWidth","_scaleY","axisLineWidth","rect","chrtColumns","deltaX","pointSize","pointStrokeWidth","DEFAULT_POINT_COLOR","chrtPoints","radius","_position","alignment","_alignment","vertical","_vposition","horizontal","_hposition","outside","chrtLabel","_offsets","getPosition","chrtLabels","parentData","isBars","offsets","chrtLabel$1","textFieldAccessor","textField","topOffset","leftOffset","showMarkers","markersFilter","hideMarkers","chrtMarkers","markers","_radius","_opacity","_stroke","_strokeOpacity","_strokeWidth","marker","cx","cy","chrtAnnotation","div","innerHTML","chrtAnnotation$1","firstMarker","lastMarker","firstAndLastMarkers","el","charts","chrt.Chrt","startDay","getDate","maxObj","maxIndex","findIndex","endDay","class","Intl","NumberFormat","iterations","DATA_SOURCE","rawData","epicenters","generated","italy","global","provinces","regions","tested","cases","fatalities","tests","icus","hospitals","get","results","datetime","italy_filtered","tmpCases","tmpFatalities","tmpIcus","tmpHospitals","tmpTests","getDay","setDate","avg","new_tested_positive","deaths","icu","hospital","catch","fetchData","body"],"mappings":"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"}