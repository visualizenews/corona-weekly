{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/axios/lib/helpers/bind.js","../../node_modules/axios/lib/utils.js","../../node_modules/axios/lib/helpers/buildURL.js","../../node_modules/axios/lib/core/InterceptorManager.js","../../node_modules/axios/lib/core/transformData.js","../../node_modules/axios/lib/cancel/isCancel.js","../../node_modules/axios/lib/helpers/normalizeHeaderName.js","../../node_modules/axios/lib/core/createError.js","../../node_modules/axios/lib/core/enhanceError.js","../../node_modules/axios/lib/helpers/cookies.js","../../node_modules/axios/lib/helpers/parseHeaders.js","../../node_modules/axios/lib/helpers/isURLSameOrigin.js","../../node_modules/axios/lib/adapters/xhr.js","../../node_modules/axios/lib/core/buildFullPath.js","../../node_modules/axios/lib/helpers/isAbsoluteURL.js","../../node_modules/axios/lib/helpers/combineURLs.js","../../node_modules/axios/lib/core/settle.js","../../node_modules/axios/lib/defaults.js","../../node_modules/axios/lib/core/dispatchRequest.js","../../node_modules/axios/lib/core/mergeConfig.js","../../node_modules/axios/lib/core/Axios.js","../../node_modules/axios/lib/cancel/Cancel.js","../../node_modules/axios/lib/cancel/CancelToken.js","../../node_modules/axios/lib/axios.js","../../node_modules/axios/lib/helpers/spread.js","../../node_modules/axios/lib/helpers/isAxiosError.js","../../node_modules/axios/index.js","../../node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-axis/dist/chrt-axis.esm.js","../../node_modules/chrt-grid/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-grid/dist/chrt-grid.esm.js","../../node_modules/chrt-line/dist/chrt-line.esm.js","../../node_modules/chrt-bars/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-bars/dist/chrt-bars.esm.js","../../node_modules/chrt-points/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-points/dist/chrt-points.esm.js","../../node_modules/chrt-label/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-label/dist/chrt-label.esm.js","../../node_modules/chrt-markers/node_modules/chrt-core/dist/chrt-core.esm.js","../../node_modules/chrt-markers/dist/chrt-markers.esm.js","../../node_modules/chrt-annotation/dist/chrt-annotation.esm.js","../../src/Chart.svelte","../../src/Line.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.37.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to seperate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, update_slot_spread, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n","module.exports = require('./lib/axios');","// chrt-core v0.0.26 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNull(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNull(value);\n  });\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(name, \"fixedDomain\", fixedDomain);\n  // console.log(name, \"domainExtent\", domainExtent);\n  // console.log(name, \"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.26 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction generateTicks(ticks, name, callback) {\n  var _this = this;\n\n  ticks.forEach(function (tick, i, arr) {\n    var tickGroup = _this.g.querySelector(\"[data-id='tick-\".concat(name, \"-\").concat(tick.value, \"']\"));\n\n    if (!tickGroup) {\n      tickGroup = createSVG('g');\n      tickGroup.setAttribute('data-id', \"tick-\".concat(name, \"-\").concat(tick.value));\n\n      if (tick.isMinor) {\n        tickGroup.classList.add('tick-minor');\n      }\n\n      _this.g.appendChild(tickGroup);\n\n      if (_this.showAxisLine) {\n        var tickLine = createSVG('line');\n        tickLine.setAttribute('stroke', _this.stroke);\n        tickLine.setAttribute('stroke-width', _this.strokeWidth);\n        tickGroup.appendChild(tickLine);\n      }\n    }\n\n    if (callback) {\n      callback.call(null, tickGroup, tick, i, arr);\n    }\n  });\n}\n\nvar TICKS_DEFAULT = 10;\nvar ORIENTATIONS = {\n  x: ['top', 'bottom'],\n  y: ['left', 'right']\n};\nvar DEFAULT_ORIENTATION = {\n  x: 'bottom',\n  y: 'left'\n};\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction lineColor(value) {\n  if (isNull(value)) {\n    return this.stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.stroke = value;\n  }\n\n  return this;\n}\n\nfunction lineWidth(value) {\n  if (isNull(value)) {\n    return this.strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction setTickLength(value) {\n  if (isNull(value)) {\n    return this.tickLength;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.tickLength = value;\n  }\n\n  return this;\n}\n\nfunction setTickPosition(value) {\n  if (isNull(value)) {\n    return this.tickPosition;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.tickPosition = value;\n  }\n\n  return this;\n}\n\nfunction setTickPosition$1(value) {\n  if (isNull(value)) {\n    return this.labelPosition;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.labelPosition = value;\n  }\n\n  return this;\n}\n\nfunction showAxis(value) {\n  if (typeof value === 'function') ; else {\n    this.showAxisLine = isNull(value) ? true : value;\n  }\n\n  return this;\n}\nfunction hideAxis() {\n  return showAxis.call(this, false);\n}\n\nfunction ticks(ticks) {\n  if (isNull(ticks)) {\n    return this._ticks;\n  }\n\n  this._fixedTicks = ticks;\n  return this;\n} // showTicks and hideTicks can get different type of parameters and they filter the ticks based on the parameters\n\nfunction showTicks(filter) {\n  // default true\n  if (isNull(filter)) {\n    this.ticksFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showTicks((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.ticksFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all ticks\n  // showTicks(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.ticksFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one tick\n  // showTicks(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.ticksFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showTicks([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.ticksFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n} // hideTicks is the opposite of showTicks and it filters out\n\nfunction hideTicks(filter) {\n  showTicks.call(this, filter);\n  var ticksFilter = this.ticksFilter;\n\n  this.ticksFilter = function (d, i, arr) {\n    return !ticksFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  // // console.log('FIRST TICK', this, show)\n  if (show) {\n    showTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\nfunction firstAndLastTicks() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showTicks.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  } else {\n    hideTicks.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nfunction orient(value) {\n  if (isNull(value)) {\n    return this.orientation;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.orientation = ORIENTATIONS[this._name].indexOf(value) > -1 ? value : DEFAULT_ORIENTATION[this.name]; // // console.log('SETTING ORIENTATION', this.name, value, '->', this.orientation)\n  }\n\n  return this;\n}\n\nfunction format(format) {\n  if (isNull(format)) {\n    return this;\n  }\n\n  if (typeof format === 'function') {\n    this.labelFormat = format;\n  }\n\n  return this;\n}\n\nfunction minor() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (isNull(value)) {\n    return this.showMinorTicks;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.showMinorTicks = value;\n  }\n\n  return this;\n}\n\nfunction zero(value) {\n  if (isNull(value)) {\n    return this._zero;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._zero = value;\n  }\n\n  return this;\n}\nfunction hideZero() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (typeof value === 'function') ; else {\n    this.showZero = !value;\n  }\n\n  return this;\n}\n\nfunction label(text) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (isNull(text)) {\n    return this._label;\n  }\n\n  this._label = Object.assign({\n    position: 'last'\n  }, options, {\n    text: text\n  });\n  return this;\n}\n\nfunction interval(value) {\n  // console.log('INTERVAL', value)\n  if (isNull(value)) {\n    return this._interval;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._interval = value;\n  }\n\n  return this;\n}\n\nfunction title(value) {\n  return this.attr('title', value);\n}\n\nfunction labels(labels) {\n  if (isNull(labels)) {\n    return this._labels;\n  }\n\n  this._fixedLabels = labels;\n  return this;\n} // showLabels and hideLabels can get different type of parameters and they filter the labels based on the parameters\n\nfunction showLabels(filter) {\n  // default true\n  if (isNull(filter)) {\n    this.labelsFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showLabels((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.labelsFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all labels\n  // showLabels(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.labelsFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one label\n  // showLabels(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.labelsFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showLabels([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.labelsFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n} // hideLabels is the opposite of showLabels and it filters out\n\nfunction hideLabels(filter) {\n  showLabels.call(this, filter);\n  var labelsFilter = this.labelsFilter;\n\n  this.labelsFilter = function (d, i, arr) {\n    return !labelsFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstLabel() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showLabels.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideLabels.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastLabel() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showLabels.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideLabels.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\nfunction firstAndLastLabels() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showLabels.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  } else {\n    hideLabels.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nvar DEFAULT_LINE_WIDTH = 1;\nvar DEAULT_LINE_COLOR = '#000';\nvar DEAULT_TICK_TEXT_COLOR = '#000';\nvar TICK_LENGTH = 5;\nvar TICK_POSITION = 'outside';\nvar LABEL_POSITION = 'outside';\n\nfunction chrtAxis(name) {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'axis';\n  this.updater = true;\n  this.name = name;\n  this.strokeWidth = DEFAULT_LINE_WIDTH;\n  this.stroke = DEAULT_LINE_COLOR;\n  this.tickTextColor = DEAULT_TICK_TEXT_COLOR;\n  this.showAxisLine = true;\n  this.ticksFilter = null;\n  this.labelsFilter = null;\n  this.tickLength = TICK_LENGTH;\n  this.tickPosition = TICK_POSITION;\n  this.labelPosition = LABEL_POSITION;\n\n  this.labelFormat = function (d) {\n    return d;\n  };\n\n  this.showMinorTicks = false;\n  this._zero = null;\n  this.showZero = true;\n  this._label = null;\n  this._ticks = [];\n  this._fixedTicks = null;\n  this._interval = null;\n  this._classNames = ['chrt-axis'];\n\n  this.draw = function () {\n    if (!_this.parentNode.scales[_this._coordinates][name]) {\n      return _this.parentNode;\n    }\n\n    return _this.parentNode;\n  };\n}\n\nchrtAxis.prototype = Object.create(chrtGeneric.prototype);\nchrtAxis.prototype.constructor = chrtAxis;\nchrtAxis.parent = chrtGeneric.prototype;\nchrtAxis.prototype = Object.assign(chrtAxis.prototype, {\n  width: lineWidth,\n  color: lineColor,\n  setTickLength: setTickLength,\n  setTickPosition: setTickPosition,\n  setLabelPosition: setTickPosition$1,\n  showAxis: showAxis,\n  hideAxis: hideAxis,\n  ticks: ticks,\n  filterTicks: showTicks,\n  filter: showTicks,\n  showTicks: showTicks,\n  hideTicks: hideTicks,\n  firstTick: firstTick,\n  lastTick: lastTick,\n  firstAndLastTicks: firstAndLastTicks,\n  labels: labels,\n  filterLabels: showTicks,\n  showLabels: showLabels,\n  hideLabels: hideLabels,\n  firstLabel: firstLabel,\n  lastLabel: lastLabel,\n  firstAndLastLabels: firstAndLastLabels,\n  orient: orient,\n  format: format,\n  minor: minor,\n  zero: zero,\n  hideZero: hideZero,\n  label: label,\n  interval: interval,\n  title: title\n});\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction generateLabels(labels, name, callback) {\n  var _this = this;\n\n  // console.log('generateLabels', labels, name)\n  labels.forEach(function (d, i, arr) {\n    var labelGroup = _this.g.querySelector(\"[data-id='label-\".concat(name, \"-\").concat(d.value, \"']\"));\n\n    if (!labelGroup) {\n      labelGroup = createSVG('g');\n      labelGroup.setAttribute('data-id', \"label-\".concat(name, \"-\").concat(d.value));\n\n      if (d.isMinor) {\n        labelGroup.classList.add('label-minor');\n      }\n\n      _this.g.appendChild(labelGroup);\n\n      var label = createSVG('text');\n      label.textContent = _this.labelFormat(d.value, i, arr);\n      label.setAttribute('fill', _this.labelTextColor);\n\n      if (label.label) {\n        label.textContent = \"\".concat(_this.labelFormat(label.value, i, arr)).concat(d.label.text);\n      }\n\n      labelGroup.appendChild(label);\n    }\n\n    if (callback) {\n      callback.call(null, labelGroup, d, i, arr);\n    }\n  });\n}\n\nfunction xAxis() {\n  var _this = this;\n\n  var ticksNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n  var customName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n\n  if (typeof arguments[0] === 'string') {\n    customName = arguments[0];\n    ticksNumber = TICKS_DEFAULT;\n  }\n\n  chrtAxis.call(this, customName);\n  var name = this.name;\n  this._name = 'x';\n  this._coordinates = 'x';\n  this.orientation = DEFAULT_ORIENTATION[this._name];\n  var coords = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [].concat(_toConsumableArray(this._classNames), ['chrt-x-axis']);\n\n  var xAxisTick = function xAxisTick(tickGroup, visible) {\n    _this._name = coords.x;\n    name = _this.parentNode.scales[coords.x][_this.name].getName();\n    tickGroup.style.display = visible ? 'block' : 'none';\n    var tickLine = tickGroup.querySelector('line');\n    var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? 1 : -1;\n\n    if (tickLine) {\n      tickLine.setAttribute('x1', 0);\n      tickLine.setAttribute('x2', 0);\n      tickLine.setAttribute('y1', 0);\n      tickLine.setAttribute('y2', (_this.tickPosition === 'outside' ? _this.tickLength : -_this.tickLength) * orientation);\n    }\n\n    var label = tickGroup.querySelector('text');\n\n    if (label) {\n      label.setAttribute('text-anchor', 'middle'); // label.setAttribute('y', this.tickLength * orientation);\n\n      label.setAttribute('y', (_this.labelPosition === 'outside' ? _this.tickLength : -_this.tickLength) * orientation);\n      label.setAttribute('data-orientation', orientation);\n\n      if (orientation > 0) {\n        label.setAttribute('dy', \"\".concat(_this.labelPosition === 'outside' ? 1 : -0.25, \"em\"));\n      } else {\n        label.setAttribute('dy', \"\".concat(_this.labelPosition === 'outside' ? -0.25 : 1, \"em\"));\n      }\n\n      label.setAttribute('fill', _this.stroke);\n    }\n  };\n\n  this.draw = function () {\n    _this._name = coords.x; // TODO: needs improvement, name and this.name will be the same\n\n    name = _this.parentNode.scales[coords.x][_this.name].getName(); // console.log('this.name vs name', this.name, name)\n\n    if (!_this.parentNode.scales[coords.x][name]) {\n      return _this.parentNode;\n    }\n\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        width = _this$parentNode.width,\n        height = _this$parentNode.height,\n        scales = _this$parentNode.scales;\n\n    if (_this._label) {\n      _this._label.tickIndex = -1;\n    }\n\n    var ticks = scales[coords.x][name].ticks(_this._fixedTicks || ticksNumber * 2, _this._interval);\n\n    if (_this._label && _this._label.position === 'last') {\n      ticks.reverse();\n    }\n\n    _this._ticks = ticks.map(function (tick, i, arr) {\n      tick.position = scales[coords.x][name](tick.value);\n      var visible = tick.position >= _margins.left && tick.position <= width - _margins.right;\n      visible = visible && (_this.showMinorTicks || tick.isZero && _this.showZero || !tick.isMinor);\n      visible = visible && (!isLog || isLog && !tick.isMinor);\n      tick.visible = visible;\n\n      if (_this.ticksFilter) {\n        tick.visible = tick.visible && _this.ticksFilter(tick.value, i, arr);\n      }\n\n      tick.visibleLabel = visible;\n\n      if (_this.labelsFilter) {\n        tick.visibleLabel = tick.visibleLabel && _this.labelsFilter(tick.value, i, arr);\n      }\n\n      tick.label = null;\n\n      if (tick.visibleLabel && _this._label) {\n        if (!isNull(_this._label.value) && _this._label.value === tick.value) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      if (tick.visibleLabel && _this._label && isNull(_this._label.value) && (_this._label.position === 'all' || _this._label.tickIndex === -1)) {\n        if (!isNull(_this._label.position)) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      return tick;\n    }).filter(function (d) {\n      return d.visible || d.visibleLabel;\n    }); // decrease the number of ticks rendered in the DOM\n\n    _this.g.setAttribute('id', \"\".concat(name, \"Axis-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var axisY = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? height - _margins.bottom : _margins.top;\n\n    _this.g.setAttribute('transform', \"translate(0,\".concat(axisY, \")\"));\n\n    var axisLine = _this.g.querySelector(\"[data-id='tick-\".concat(name, \"-axis-line']\"));\n\n    if (!axisLine) {\n      axisLine = createSVG('line');\n      axisLine.setAttribute('data-id', \"tick-\".concat(name, \"-axis-line\"));\n\n      _this.g.appendChild(axisLine);\n    }\n\n    axisLine.setAttribute('stroke', _this.stroke);\n    axisLine.setAttribute('stroke-width', _this.strokeWidth);\n    axisLine.setAttribute('x1', _margins.left);\n    axisLine.setAttribute('x2', width - _margins.right);\n    var scaleY = scales[coords.y][coords.y] || Object.values(scales[coords.y])[0];\n    var zero = isNull(_this._zero) ? scaleY.domain[0] : _this._zero;\n    var axisLineY = scaleY.isLog() ? scaleY.range[1] : scaleY(zero) - (height - _margins.bottom);\n\n    if (scaleY.transformation === 'ordinal' && !~scaleY.domain.indexOf(zero)) {\n      axisLineY = 0;\n    } // console.log(this._zero, '->', scaleY(this._zero),'- (',height,'-',_margins.bottom,')')\n    // console.log('axisLineY', axisLineY)\n\n\n    axisLine.setAttribute('y1', !isNaN(axisLineY) ? axisLineY : 0);\n    axisLine.setAttribute('y2', !isNaN(axisLineY) ? axisLineY : 0); // if no axis remove the axis line after creating it\n\n    if (!_this.showAxisLine) {\n      axisLine.remove();\n    }\n\n    var title = _this.attr('title') ? _this.attr('title')() : null;\n\n    if (!isNull(title)) {\n      var axisTitleText = _this.g.querySelector('text.title');\n\n      if (isNull(axisTitleText)) {\n        axisTitleText = createSVG('text');\n        axisTitleText.classList.add('title');\n      }\n\n      axisTitleText.textContent = title;\n      var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? -1 : 1;\n      var y = (5 + _this.strokeWidth) * orientation;\n      axisTitleText.setAttribute('x', width - _margins.right);\n      axisTitleText.setAttribute('y', y);\n      axisTitleText.setAttribute('dy', \"\".concat(0.9 * ~orientation, \"em\")); // axisTitleText.setAttribute('dx', this.tickPosition === 'outside' ? `${5 * orientation}px` : `${-2 * orientation}px`)\n\n      axisTitleText.setAttribute('text-anchor', 'end'); // axisTitleText.setAttribute(\n      //   'text-anchor',\n      //   this.tickPosition === 'outside'\n      //     ? ~orientation\n      //       ? 'end'\n      //       : 'start'\n      //     : ~orientation\n      //     ? 'start'\n      //     : 'end'\n      // );\n\n      _this.g.appendChild(axisTitleText);\n    }\n\n    var isLog = scales[coords.x][name].isLog();\n\n    _this.g.querySelectorAll('g').forEach(function (d) {\n      var tickName = d.getAttribute('data-id');\n\n      var tick = _this._ticks.find(function (tick) {\n        return tickName === \"tick-\".concat(name, \"-\").concat(tick);\n      });\n\n      if (!tick) {\n        d.remove();\n      }\n    });\n\n    generateTicks.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(\".concat(tick.position, \", 0)\"));\n      xAxisTick(tickGroup, tick.visible);\n    });\n    generateLabels.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(\".concat(tick.position, \", 0)\"));\n      xAxisTick(tickGroup, tick.visibleLabel);\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nxAxis.prototype = Object.create(chrtAxis.prototype);\nxAxis.prototype.constructor = xAxis;\nxAxis.parent = chrtAxis.prototype; // export default xAxis;\n\nfunction xAxis$1 (ticksNumber, customName) {\n  return new xAxis(ticksNumber, customName);\n}\n\nfunction yAxis() {\n  var _this = this;\n\n  var ticksNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n  var customName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';\n\n  // ticksNumber = isNull(ticksNumber) ? TICKS_DEFAULT : ticksNumber;\n  // console.log('Y AXIS', arguments)\n  if (typeof arguments[0] === 'string') {\n    customName = arguments[0];\n    ticksNumber = TICKS_DEFAULT;\n  }\n\n  chrtAxis.call(this, customName, 'y');\n  var name = this.name;\n  this._name = 'y';\n  this._coordinates = 'y';\n  this.orientation = DEFAULT_ORIENTATION[this._name];\n  this._classNames = [].concat(_toConsumableArray(this._classNames), ['chrt-y-axis']);\n  var coords = {\n    x: 'x',\n    y: 'y'\n  };\n\n  var yAxisTick = function yAxisTick(tickGroup, visible) {\n    _this._name = coords.y;\n    name = _this.parentNode.scales[coords.y][_this.name].getName();\n    tickGroup.style.display = visible ? 'block' : 'none';\n    var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? 1 : -1;\n    var tickLine = tickGroup.querySelector('line');\n\n    if (tickLine) {\n      tickLine.setAttribute('x1', 0);\n      tickLine.setAttribute('x2', (_this.tickPosition === 'outside' ? -_this.tickLength : _this.tickLength) * orientation);\n    }\n\n    var label = tickGroup.querySelector('text');\n\n    if (label) {\n      label.setAttribute('text-anchor', _this.labelPosition === 'outside' ? ~orientation ? 'end' : 'start' : ~orientation ? 'start' : 'end');\n      label.setAttribute('x', (_this.labelPosition === 'outside' ? -_this.tickLength : 0) * orientation);\n      label.setAttribute('dx', \"\".concat((_this.labelPosition === 'outside' ? -5 : 5) * orientation, \"px\"));\n      label.setAttribute('dy', _this.labelPosition === 'outside' ? '0.25em' : '-0.3em');\n      label.setAttribute('fill', _this.stroke);\n    }\n  };\n\n  this.draw = function () {\n    _this._name = coords.y; // console.log('Y AXIS this.name', this.name)\n\n    name = _this.parentNode.scales[coords.y][_this.name].getName();\n\n    if (!_this.parentNode.scales[coords.y][name]) {\n      return _this.parentNode;\n    }\n\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        scales = _this$parentNode.scales,\n        width = _this$parentNode.width,\n        height = _this$parentNode.height;\n\n    _this.g.setAttribute('id', \"\".concat(name, \"Axis-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var axisX = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? _margins.left : width - _margins.right;\n\n    _this.g.setAttribute('transform', \"translate(\".concat(axisX, \",0)\"));\n\n    if (_this._label) {\n      _this._label.tickIndex = -1;\n    }\n\n    var ticks = scales[coords.y][name].ticks(_this._fixedTicks || ticksNumber * 2, _this._interval);\n\n    if (_this._label && _this._label.position === 'last') {\n      ticks.reverse();\n    }\n\n    _this._ticks = ticks.map(function (tick, i, arr) {\n      tick.position = scales[coords.y][name](tick.value);\n      var visible = tick.position >= _margins.top && tick.position <= height - _margins.bottom;\n      visible = visible && (_this.showMinorTicks || tick.isZero && _this.showZero || !tick.isMinor);\n      visible = visible && (!isLog || isLog && !tick.isMinor);\n      tick.visible = visible;\n\n      if (_this.ticksFilter) {\n        tick.visible = tick.visible && _this.ticksFilter(tick.value, i, arr);\n      }\n\n      tick.visibleLabel = visible;\n\n      if (_this.labelsFilter) {\n        tick.visibleLabel = tick.visibleLabel && _this.labelsFilter(tick.value, i, arr);\n      } // console.log('---->','tick.visibleLabel', tick.visibleLabel, tick)\n\n\n      tick.label = null;\n\n      if (tick.visibleLabel && _this._label) {\n        if (!isNull(_this._label.value) && _this._label.value === tick.value) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      if (tick.visibleLabel && _this._label && isNull(_this._label.value) && (_this._label.position === 'all' || _this._label.tickIndex === -1)) {\n        if (!isNull(_this._label.position)) {\n          tick.label = _this._label;\n          _this._label.tickIndex = tick.index;\n        }\n      }\n\n      return tick;\n    }).filter(function (d) {\n      return d.visible || d.visibleLabel;\n    }); // decrease the number of ticks rendered in the DOM\n    // console.log('Y AXIS TICKS', ticks)\n\n    var axisLine = _this.g.querySelector(\"[data-id='tick-\".concat(name, \"-axis-line']\"));\n\n    if (!axisLine) {\n      axisLine = createSVG('line');\n      axisLine.setAttribute('data-id', \"tick-\".concat(name, \"-axis-line\"));\n\n      _this.g.appendChild(axisLine);\n    }\n\n    axisLine.setAttribute('stroke', _this.stroke);\n    axisLine.setAttribute('stroke-width', _this.labelPosition === 'outside' ? _this.strokeWidth : 0);\n    axisLine.setAttribute('x1', 0);\n    axisLine.setAttribute('x2', 0);\n    axisLine.setAttribute('y1', _margins.top);\n    axisLine.setAttribute('y2', height - _margins.bottom); // if no axis remove the axis line after creating it\n\n    if (!_this.showAxisLine) {\n      axisLine.remove();\n    }\n\n    var title = _this.attr('title') ? _this.attr('title')() : null;\n\n    if (!isNull(title)) {\n      var axisTitleText = _this.g.querySelector('text.title');\n\n      if (isNull(axisTitleText)) {\n        axisTitleText = createSVG('text');\n        axisTitleText.classList.add('title');\n      }\n\n      axisTitleText.textContent = title;\n      var orientation = _this.orientation === DEFAULT_ORIENTATION[_this._name] ? 1 : -1;\n      var x = (_this.labelPosition === 'outside' ? _this.tickLength : 0) * orientation;\n      axisTitleText.setAttribute('x', x);\n      axisTitleText.setAttribute('y', _margins.top);\n      axisTitleText.setAttribute('dy', _this.labelPosition === 'outside' ? '0.9em' : '-0.9em');\n      axisTitleText.setAttribute('dx', _this.labelPosition === 'outside' ? \"\".concat(5 * orientation, \"px\") : \"\".concat(-2 * orientation, \"px\"));\n      axisTitleText.setAttribute('text-anchor', ~orientation ? 'start' : 'end'); // axisTitleText.setAttribute('text-anchor','start');\n      // axisTitleText.setAttribute(\n      //   'text-anchor',\n      //   this.tickPosition === 'outside'\n      //     ? ~orientation\n      //       ? 'end'\n      //       : 'start'\n      //     : ~orientation\n      //     ? 'start'\n      //     : 'end'\n      // );\n\n      _this.g.appendChild(axisTitleText);\n    }\n\n    var isLog = scales[coords.y][name].isLog();\n\n    _this.g.querySelectorAll('g').forEach(function (d) {\n      var tickName = d.getAttribute('data-id');\n\n      var tick = _this._ticks.find(function (tick) {\n        return tickName === \"tick-\".concat(name, \"-\").concat(tick);\n      });\n\n      if (!tick) {\n        d.remove();\n      }\n    });\n\n    generateTicks.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(0, \".concat(tick.position, \")\"));\n      yAxisTick(tickGroup, tick.visible);\n    });\n    generateLabels.call(_this, _this._ticks, name, function (tickGroup, tick) {\n      // console.log('generateTick', name, tick)\n      tickGroup.setAttribute('transform', \"translate(0, \".concat(tick.position, \")\"));\n      yAxisTick(tickGroup, tick.visibleLabel);\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nyAxis.prototype = Object.create(chrtAxis.prototype);\nyAxis.prototype.constructor = yAxis;\nyAxis.parent = chrtAxis.prototype; // export default yAxis;\n\nfunction yAxis$1 (ticksNumber, customName) {\n  return new yAxis(ticksNumber, customName);\n}\n\nfunction index (name) {\n  return new chrtAxis(name);\n}\n\nfunction color(value) {\n  return this.attr('fill', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction range(values) {\n  if (isNull(values)) {\n    return this;\n  }\n\n  if (typeof values === 'function') ; else {\n    this._range = Object.assign({}, this._range, values);\n  }\n\n  return this;\n}\nfunction from(value) {\n  return range.call(this, {\n    from: value\n  });\n}\nfunction to(value) {\n  return range.call(this, {\n    to: value\n  });\n}\n\nfunction stroke(value) {\n  return this.attr('stroke', value); // if(!value) {\n  //   return this._stroke;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._stroke = value;\n  // }\n  // return this;\n}\n\nfunction strokeWidth(value) {\n  return this.attr('strokeWidth', value); // if(!value) {\n  //   return this._strokeWidth;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._strokeWidth = value;\n  // }\n  // return this;\n}\n\nfunction lineStyle(value) {\n  return this.attr('lineStyle', value); // return;\n  // if(!value) {\n  //   return this._strokeStyle;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   const strokeWidth = this.attr('strokeWidth')();\n  //   switch(value) {\n  //     case 'dashed':\n  //       this._strokeStyle = `${strokeWidth * 4} ${strokeWidth * 4}`;\n  //       break;\n  //     case 'dotted':\n  //       this._strokeStyle = `${strokeWidth} ${strokeWidth}`;\n  //       break;\n  //     case 'solid':\n  //     default:\n  //       this._strokeStyle = null;\n  //   }\n  // }\n  // return this;\n}\n\nfunction fillOpacity(value) {\n  return this.attr('fillOpacity', value); // if(!value) {\n  //   return this._strokeWidth;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._strokeWidth = value;\n  // }\n  // return this;\n}\n\nvar DEFAULT_FILL_COLOR = '#ddd';\nvar DEFAULT_STROKE = '#000';\nvar DEFAULT_STROKE_OPACITY = 1;\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtAxisRange() {\n  var _this = this;\n\n  // console.log('chrtAxisRange', this)\n  chrtGeneric.call(this);\n  this.type = 'axis-range';\n  this.g = null;\n  this.attr('fill', DEFAULT_FILL_COLOR);\n  this.attr('stroke', DEFAULT_STROKE);\n  this.attr('fillOpacity', DEFAULT_FILL_OPACITY);\n  this.attr('strokeOpacity', DEFAULT_STROKE_OPACITY);\n  this.attr('strokeWidth', DEFAULT_STROKE_WIDTH);\n  this.attr('lineStyle', 'solid');\n  this._range = {};\n  this._classNames = ['chrt-axis-range'];\n\n  this.draw = function () {\n    return _this.parentNode;\n  };\n\n  this.solid = function () {\n    return lineStyle.call(_this, 'solid');\n  };\n\n  this.dashed = function () {\n    return lineStyle.call(_this, 'dashed');\n  };\n\n  this.dotted = function () {\n    return lineStyle.call(_this, 'dotted');\n  };\n\n  this.strokeOpacity = function (value) {\n    return _this.attr('strokeOpacity', value);\n  };\n\n  return this.parentNode;\n}\n\nchrtAxisRange.prototype = Object.create(chrtGeneric.prototype);\nchrtAxisRange.prototype.constructor = chrtAxisRange;\nchrtAxisRange.parent = chrtGeneric.prototype;\nchrtAxisRange.prototype = Object.assign(chrtAxisRange.prototype, {\n  color: color,\n  fill: color,\n  stroke: stroke,\n  strokeWidth: strokeWidth,\n  fillOpacity: fillOpacity,\n  lineStyle: lineStyle,\n  range: range,\n  from: from,\n  to: to\n});\n//   return new chrtAxisRange();\n// }\n\nfunction yAxisRange() {\n  var _this = this;\n\n  chrtAxisRange.call(this);\n  this[\"class\"]('chrt-y-axis-range');\n\n  this.draw = function () {\n    // console.log('chrtAxisRange draw', this);\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.g.setAttribute('data-id', _this._id);\n\n      _this.g.setAttribute('data-name', 'axis-range');\n    }\n\n    if (!_this.parentNode.g.querySelector(\"\".concat(name, \"AxisRange-\").concat(_this.id()))) {\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', \"\".concat(name, \"AxisRange-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var fill = _this.attr('fill')();\n\n    var fillOpacity = _this.attr('fillOpacity')();\n\n    var stroke = _this.attr('stroke')();\n\n    var strokeOpacity = _this.attr('strokeOpacity')();\n\n    var strokeWidth = _this.attr('strokeWidth')();\n\n    var orientation = _this.parentNode.orientation === DEFAULT_ORIENTATION[_this.parentNode._name] ? 1 : -1;\n    var _this$parentNode$pare = _this.parentNode.parentNode,\n        scales = _this$parentNode$pare.scales,\n        width = _this$parentNode$pare.width,\n        _margins = _this$parentNode$pare._margins;\n    var from = null;\n    var to = null;\n\n    if (scales && scales.y[_this.parentNode.name]) {\n      var _scale = scales.y[_this.parentNode.name];\n      from = isNull(_this._range.from) ? from : _scale(_this._range.from);\n      to = isNull(_this._range.to) ? to : _scale(_this._range.to);\n    }\n\n    if (!_this.path) {\n      _this.path = createSVG('path');\n\n      _this.g.appendChild(_this.path);\n    }\n\n    if (isNull(from) && isNull(to)) {\n      return;\n    }\n\n    _this.g.setAttribute('transform', \"translate(\".concat(orientation > 0 ? 0 : -(width - (_margins.right + _margins.left)), \",0)\")); // the range should be at least 1px thick\n\n\n    from = isNull(from) ? to : from;\n    to = isNull(to) ? from : to;\n\n    if (from === to) {\n      _this.path.remove();\n\n      _this.path = null;\n    } else {\n      var d = [[_this.parentNode.strokeWidth, from], [_this.parentNode.strokeWidth, to], [width - (_margins.right + _margins.left), to], [width - (_margins.right + _margins.left), from]];\n\n      _this.path.setAttribute('d', \"M\".concat(d.join('L'), \"z\"));\n\n      _this.path.setAttribute('fill', fill);\n\n      _this.path.setAttribute('fill-opacity', fillOpacity);\n    }\n\n    var strokeStyle = _this.attr('lineStyle')();\n\n    if (!isNull(strokeStyle)) {\n      switch (strokeStyle) {\n        case 'dashed':\n          _this._strokeStyle = \"\".concat(strokeWidth * 4, \" \").concat(strokeWidth * 4);\n          break;\n\n        case 'dotted':\n          _this._strokeStyle = \"\".concat(strokeWidth, \" \").concat(strokeWidth);\n          break;\n\n        case 'solid':\n        default:\n          _this._strokeStyle = null;\n      }\n    }\n\n    var lines = _toConsumableArray(new Set([from, to]));\n\n    if (isNull(_this.lines)) {\n      _this.lines = [];\n    }\n\n    lines.forEach(function (position, index) {\n      if (!_this.lines[index]) {\n        _this.lines[index] = createSVG('line');\n\n        _this.g.appendChild(_this.lines[index]);\n      }\n\n      var line = _this.lines[index];\n      line.setAttribute('x1', _this.parentNode.strokeWidth);\n      line.setAttribute('x2', width - (_margins.left + _margins.right));\n      line.setAttribute('y1', position);\n      line.setAttribute('y2', position);\n      line.setAttribute('stroke', stroke);\n      line.setAttribute('stroke-width', strokeWidth);\n      line.setAttribute('stroke-opacity', strokeOpacity);\n\n      if (!isNull(_this._strokeStyle)) {\n        line.setAttribute('stroke-dasharray', _this._strokeStyle);\n      }\n    });\n    return _this.parentNode;\n  };\n}\n\nyAxisRange.prototype = Object.create(chrtAxisRange.prototype);\nyAxisRange.prototype.constructor = yAxisRange;\nyAxisRange.parent = chrtAxisRange.prototype;\nfunction yAxisRange$1 () {\n  return new yAxisRange();\n}\n\nfunction xAxisRange() {\n  var _this = this;\n\n  chrtAxisRange.call(this);\n  this[\"class\"]('chrt-y-axis-range');\n\n  this.draw = function () {\n    // console.log('chrtAxisRange draw', this);\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.g.setAttribute('data-id', _this._id);\n\n      _this.g.setAttribute('data-name', 'axis-range');\n    }\n\n    if (!_this.parentNode.g.querySelector(\"\".concat(name, \"AxisRange-\").concat(_this.id()))) {\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', \"\".concat(name, \"AxisRange-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var fill = _this.attr('fill')();\n\n    var fillOpacity = _this.attr('fillOpacity')();\n\n    var stroke = _this.attr('stroke')();\n\n    var strokeOpacity = _this.attr('strokeOpacity')();\n\n    var strokeWidth = _this.attr('strokeWidth')();\n\n    var orientation = _this.parentNode.orientation === DEFAULT_ORIENTATION[_this.parentNode._name] ? 1 : -1;\n    var _this$parentNode$pare = _this.parentNode.parentNode,\n        scales = _this$parentNode$pare.scales,\n        height = _this$parentNode$pare.height,\n        _margins = _this$parentNode$pare._margins;\n    var from = null;\n    var to = null;\n\n    if (scales && scales.x[_this.parentNode.name]) {\n      var _scale = scales.x[_this.parentNode.name];\n      from = isNull(_this._range.from) ? from : _scale(_this._range.from);\n      to = isNull(_this._range.to) ? to : _scale(_this._range.to);\n    }\n\n    if (!_this.path) {\n      _this.path = createSVG('path');\n\n      _this.g.appendChild(_this.path);\n    }\n\n    if (isNull(from) && isNull(to)) {\n      return;\n    }\n\n    _this.g.setAttribute('transform', \"translate(0, \".concat(orientation > 0 ? 0 : height - (_margins.top + _margins.bottom) + _this.parentNode.strokeWidth, \")\")); // the range should be at least 1px thick\n\n\n    from = isNull(from) ? to : from;\n    to = isNull(to) ? from : to;\n\n    if (from === to) {\n      _this.path.remove();\n\n      _this.path = null;\n    } else {\n      var d = [[from, -_this.parentNode.strokeWidth], [to, -_this.parentNode.strokeWidth], [to, -(height - (_margins.top + _margins.bottom))], [from, -(height - (_margins.top + _margins.bottom))]];\n\n      _this.path.setAttribute('d', \"M\".concat(d.join('L'), \"z\"));\n\n      _this.path.setAttribute('fill', fill);\n\n      _this.path.setAttribute('fill-opacity', fillOpacity);\n    }\n\n    var strokeStyle = _this.attr('lineStyle')();\n\n    if (!isNull(strokeStyle)) {\n      switch (strokeStyle) {\n        case 'dashed':\n          _this._strokeStyle = \"\".concat(strokeWidth * 4, \" \").concat(strokeWidth * 4);\n          break;\n\n        case 'dotted':\n          _this._strokeStyle = \"\".concat(strokeWidth, \" \").concat(strokeWidth);\n          break;\n\n        case 'solid':\n        default:\n          _this._strokeStyle = null;\n      }\n    }\n\n    var lines = _toConsumableArray(new Set([from, to]));\n\n    if (isNull(_this.lines)) {\n      _this.lines = [];\n    }\n\n    lines.forEach(function (position, index) {\n      if (!_this.lines[index]) {\n        _this.lines[index] = createSVG('line');\n\n        _this.g.appendChild(_this.lines[index]);\n      }\n\n      var line = _this.lines[index];\n      line.setAttribute('x1', position);\n      line.setAttribute('x2', position);\n      line.setAttribute('y1', -_this.parentNode.strokeWidth);\n      line.setAttribute('y2', -(height - (_margins.top + _margins.bottom)));\n      line.setAttribute('stroke', stroke);\n      line.setAttribute('stroke-width', strokeWidth);\n      line.setAttribute('stroke-opacity', strokeOpacity);\n\n      if (!isNull(_this._strokeStyle)) {\n        line.setAttribute('stroke-dasharray', _this._strokeStyle);\n      }\n    });\n    return _this.parentNode;\n  };\n}\n\nxAxisRange.prototype = Object.create(chrtAxisRange.prototype);\nxAxisRange.prototype.constructor = xAxisRange;\nxAxisRange.parent = chrtAxisRange.prototype;\nfunction xAxisRange$1 () {\n  return new xAxisRange();\n}\n\nfunction index$1 () {\n  return new chrtAxisRange();\n}\n\nfunction color$1(value) {\n  return this.attr('fill', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction align(value) {\n  return this.attr('align', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction valign(value) {\n  return this.attr('valign', value); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nfunction offset(value) {\n  var currentOffset = this.attr('offset')();\n  return this.attr('offset', Object.assign({}, currentOffset || {}, value)); // if(!value) {\n  //   return this._fill;\n  // }\n  //\n  // if (typeof value === 'function') {\n  //   // something will go here\n  // } else {\n  //   this._fill = value;\n  // }\n  // return this;\n}\n\nvar DEFAULT_COLOR = '#000';\nvar DEFAULT_ALIGNMENT = 'right';\nvar DEFAULT_VERTICAL_ALIGNMENT = 'top';\n\nfunction chrtAxisTitle(text) {\n  var _this = this;\n\n  // console.log('chrtAxisTitle', this, 'text ->', text);\n  chrtGeneric.call(this);\n  this.type = 'axis-title';\n  this.g = null;\n  this.attr('fill', DEFAULT_COLOR);\n  this.attr('align', DEFAULT_ALIGNMENT);\n  this.attr('valign', DEFAULT_VERTICAL_ALIGNMENT);\n  this.attr('offset', {\n    x: 0,\n    y: 0\n  });\n  this._classNames = ['chrt-axis-title'];\n\n  var xAxisDraw = function xAxisDraw() {\n    var fill = _this.attr('fill')(); // const fillOpacity = this.attr('fillOpacity')();\n    // const stroke = this.attr('stroke')();\n    // const strokeOpacity = this.attr('strokeOpacity')();\n    // const strokeWidth = this.attr('strokeWidth')();\n\n\n    var _this$parentNode$pare = _this.parentNode.parentNode,\n        width = _this$parentNode$pare.width,\n        _margins = _this$parentNode$pare._margins;\n    var x = 0;\n    var textAnchor = 'start';\n\n    switch (_this.attr('align')()) {\n      case 'left':\n        x = _margins.left;\n        textAnchor = 'start';\n        break;\n\n      case 'center':\n        x = width / 2;\n        textAnchor = 'middle';\n        break;\n\n      case 'right':\n      default:\n        x = width - _margins.right;\n        textAnchor = 'end';\n    }\n\n    var dy = '0.25em';\n    var y = 0;\n\n    switch (_this.attr('valign')()) {\n      case 'bottom':\n        y = 0;\n        dy = '1em';\n        break;\n\n      case 'middle':\n        y = 0;\n        dy = '0.25em';\n        break;\n\n      case 'top':\n      default:\n        y = 0;\n        dy = '-1em';\n    }\n\n    var offset = _this.attr('offset')();\n\n    _this.text.textContent = text;\n\n    _this.text.setAttribute('text-anchor', textAnchor);\n\n    _this.text.setAttribute('x', x + offset.x);\n\n    _this.text.setAttribute('y', y + offset.y);\n\n    _this.text.setAttribute('dy', dy);\n\n    _this.text.setAttribute('fill', fill);\n  };\n\n  var yAxisDraw = function yAxisDraw() {\n    var fill = _this.attr('fill')(); // const fillOpacity = this.attr('fillOpacity')();\n    // const stroke = this.attr('stroke')();\n    // const strokeOpacity = this.attr('strokeOpacity')();\n    // const strokeWidth = this.attr('strokeWidth')();\n\n\n    var _this$parentNode$pare2 = _this.parentNode.parentNode,\n        height = _this$parentNode$pare2.height,\n        _margins = _this$parentNode$pare2._margins;\n    var x = 0;\n    var textAnchor = 'start';\n\n    switch (_this.attr('align')()) {\n      case 'left':\n        x = -5;\n        textAnchor = 'end';\n        break;\n\n      case 'center':\n      case 'middle':\n        x = 0;\n        textAnchor = 'middle';\n        break;\n\n      case 'right':\n      default:\n        x = 5;\n        textAnchor = 'start';\n    }\n\n    var dy = '0.25em';\n    var y = 0;\n\n    switch (_this.attr('valign')()) {\n      case 'bottom':\n        y = height - _margins.bottom;\n        dy = '0';\n        break;\n\n      case 'center':\n      case 'middle':\n        y = 0;\n        dy = '0.25em';\n        break;\n\n      case 'top':\n      default:\n        y = _margins.top - 1;\n        dy = '0';\n    }\n\n    var offset = _this.attr('offset')();\n\n    _this.text.textContent = text;\n\n    _this.text.setAttribute('text-anchor', textAnchor);\n\n    _this.text.setAttribute('x', x + offset.x);\n\n    _this.text.setAttribute('y', y + offset.y);\n\n    _this.text.setAttribute('dy', dy);\n\n    _this.text.setAttribute('fill', fill);\n  };\n\n  this.draw = function () {\n    // console.log('chrtAxisTitle draw', this);\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.g.setAttribute('data-id', _this._id);\n\n      _this.g.setAttribute('data-name', 'axis-title');\n    }\n\n    if (!_this.parentNode.g.querySelector(\"\".concat(name, \"AxisTitle-\").concat(_this.id()))) {\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', \"\".concat(name, \"AxisTitle-\").concat(_this.id()));\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    }); // if (scales && scales.x[this.parentNode.name]) {\n    //   const _scale = scales.x[this.parentNode.name];\n    //   from = isNull(this._range.from) ? from : _scale(this._range.from);\n    //   to = isNull(this._range.to) ? to : _scale(this._range.to);\n    // }\n\n\n    if (!_this.text) {\n      _this.text = createSVG('text');\n\n      _this.g.appendChild(_this.text);\n    }\n\n    if (_this.parentNode._name === 'x') {\n      xAxisDraw();\n    } else {\n      yAxisDraw();\n    }\n\n    return _this.parentNode;\n  };\n}\n\nchrtAxisTitle.prototype = Object.create(chrtGeneric.prototype);\nchrtAxisTitle.prototype.constructor = chrtAxisTitle;\nchrtAxisTitle.parent = chrtGeneric.prototype;\nchrtAxisTitle.prototype = Object.assign(chrtAxisTitle.prototype, {\n  color: color$1,\n  fill: color$1,\n  align: align,\n  valign: valign,\n  offset: offset\n});\n//   return new chrtAxisTitle();\n// }\n\nfunction index$2 (text) {\n  return new chrtAxisTitle(text);\n}\n\nexport { index as chrtAxis, index$1 as chrtAxisRange, index$2 as chrtAxisTitle, xAxis$1 as xAxis, xAxisRange$1 as xAxisRange, yAxis$1 as yAxis, yAxisRange$1 as yAxisRange };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.13 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nvar TICKS_DEFAULT = 10;\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction lineWidth(value) {\n  if (!value) {\n    return this.strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction lineColor(value) {\n  if (!value) {\n    return this.stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.stroke = value;\n  }\n\n  return this;\n}\n\nfunction lineStyle(value) {\n  this._lineStyle = value;\n\n  if (!value) {\n    return this.strokeStyle;\n  }\n\n  if (typeof value === 'function') ; else {\n    switch (value) {\n      case 'dashed':\n        this.strokeStyle = \"\".concat(this.strokeWidth * 4, \" \").concat(this.strokeWidth * 4);\n        break;\n\n      case 'dotted':\n        this.strokeStyle = \"\".concat(this.strokeWidth, \" \").concat(this.strokeWidth);\n        break;\n\n      case 'solid':\n      default:\n        this.strokeStyle = null;\n    }\n  }\n\n  return this;\n}\n\nfunction minor() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (typeof value === 'function') ; else {\n    this.showMinorTicks = value;\n  }\n\n  return this;\n}\n\nfunction showTicks(filter) {\n  this._filter = filter; // default true\n\n  if (isNull(filter)) {\n    this.ticksFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showTicks((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.ticksFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all ticks\n  // showTicks(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.ticksFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one tick\n  // showTicks(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.ticksFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showTicks([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.ticksFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n} // hideTicks is the opposite of showTicks and it filters out\n\nfunction hideTicks(filter) {\n  showTicks.call(this, filter);\n  var ticksFilter = this.ticksFilter;\n\n  this.ticksFilter = function (d, i, arr) {\n    return !ticksFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  // // console.log('FIRST TICK', this, show)\n  if (show) {\n    showTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideTicks.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastTick() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideTicks.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nvar DEFAULT_LINE_WIDTH = 1;\nvar DEAULT_LINE_COLOR = '#000';\n\nfunction chrtGrid(type) {\n  var _this = this;\n\n  var ticksNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var name = arguments.length > 2 ? arguments[2] : undefined;\n  chrtGeneric.call(this);\n  this.type = 'grid'; // ticksNumber *= 2;\n  // console.log('GRID', type, ticksNumber, name);\n  // this.type = type;\n\n  this.name = name || type;\n  this.strokeWidth = DEFAULT_LINE_WIDTH;\n  this.stroke = DEAULT_LINE_COLOR;\n  this.showMinorTicks = false;\n  this.ticksFilter = null;\n  this._interval = null;\n\n  var verticalGridLine = function verticalGridLine(gridLine, position, y1, y2) {\n    var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    gridLine.style.display = visible ? 'block' : 'none';\n    gridLine.setAttribute('x1', position);\n    gridLine.setAttribute('x2', position);\n    gridLine.setAttribute('y1', y1);\n    gridLine.setAttribute('y2', y2);\n  };\n\n  var horizontalGridLine = function horizontalGridLine(gridLine, position, x1, x2) {\n    var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    gridLine.style.display = visible ? 'block' : 'none';\n    gridLine.setAttribute('x1', x1);\n    gridLine.setAttribute('x2', x2);\n    gridLine.setAttribute('y1', position);\n    gridLine.setAttribute('y2', position);\n  };\n\n  this.draw = function () {\n    if (!_this.parentNode.scales[type][_this.name]) {\n      return;\n    }\n\n    var _scale = _this.parentNode.scales[type][_this.name];\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        width = _this$parentNode.width,\n        height = _this$parentNode.height;\n\n    var isLog = _scale.isLog();\n\n    var interval = _this._interval;\n\n    var axis = _this.parentNode.getAxis(type);\n\n    if (axis) {\n      interval = axis.interval();\n    }\n\n    var ticks = _scale.ticks(ticksNumber * 2, interval).map(function (tick, i, arr) {\n      tick.position = _scale(tick.value);\n      var visible = tick.position >= _margins.top && tick.position <= height - _margins.bottom;\n\n      if (type === 'x') {\n        visible = tick.position >= _margins.left && tick.position <= width - _margins.right;\n      }\n\n      visible = visible && (_this.showMinorTicks || tick.isZero && _this.showZero || !tick.isMinor);\n      visible = visible && (!isLog || isLog && !tick.isMinor);\n\n      if (_this.ticksFilter) {\n        visible = visible && _this.ticksFilter(tick.value, i, arr);\n      }\n\n      tick.visible = visible;\n      return tick;\n    }); // console.log('GRID!', type, name, 'TICKS', ticks)\n    // .filter(tick => tick.visible) // TO BE REVIEWED\n    // .filter((tick, i, arr) => this.ticksFilter ? this.ticksFilter(tick.value, i, arr) : true);\n    // const ticks = this.parentNode.scales[type].ticks(\n    //   //ticksNumber * (this.showMinorTicks ? 2 : 1)\n    //   ticksNumber * 2\n    // )\n    // // .filter((tick, i, arr) => this.ticksFilter(tick.value, i, arr));\n    // .filter((tick, i, arr) => this.ticksFilter ? this.ticksFilter(tick.value, i, arr) : true);\n    // console.log('got this ticks', type, ticksNumber, ticks);\n\n\n    _this.g.setAttribute('id', \"\".concat(type, \"Grid-\").concat(_this.id()));\n\n    _this.g.querySelectorAll('line').forEach(function (gridLine) {\n      return gridLine.setAttribute('toBeHidden', true);\n    });\n\n    ticks.forEach(function (tick) {\n      var gridLine = _this.g.querySelector(\"[data-id='gridLine-\".concat(type, \"-\").concat(tick.value, \"']\"));\n\n      if (!gridLine) {\n        gridLine = createSVG('line');\n        gridLine.setAttribute('data-id', \"gridLine-\".concat(type, \"-\").concat(tick.value));\n\n        if (tick.isMinor) {\n          gridLine.classList.add('tick-minor');\n        }\n\n        _this.g.appendChild(gridLine);\n      }\n\n      gridLine.setAttribute('stroke', _this.stroke);\n      gridLine.setAttribute('stroke-width', _this.strokeWidth);\n      gridLine.setAttribute('shape-rendering', 'crispEdges');\n\n      if (!isNull(_this.strokeStyle)) {\n        gridLine.setAttribute('stroke-dasharray', _this.strokeStyle);\n      }\n\n      gridLine.removeAttribute('toBeHidden');\n\n      var position = _scale(tick.value);\n\n      if (type === 'x') {\n        // const isLog = this.parentNode.scales[type][name].isLog();\n        // const visible =\n        //   this.showMinorTicks || (!isLog && !tick.isMinor) || (isLog && !tick.isMinor); // TODO: improve this check\n        verticalGridLine(gridLine, position, height - _margins.bottom, _margins.top, tick.visible);\n      }\n\n      if (type === 'y') {\n        // const isLog = this.parentNode.scales[type][name].isLog();\n        // let visible =\n        //   position >= _margins.top && position <= height - _margins.bottom;\n        // visible = visible && (this.showMinorTicks || (tick.isZero && this.showZero) || !tick.isMinor);\n        // visible = visible && ((!isLog) || (isLog && !tick.isMinor));\n        // if(this.ticksFilter) {\n        //   visible = this.ticksFilter(tick.value, i, arr);\n        // }\n        horizontalGridLine(gridLine, position, _margins.left, width - _margins.right, tick.visible);\n      }\n    });\n\n    _this.g.querySelectorAll('line[toBeHidden=true]').forEach(function (gridLine) {\n      return gridLine.remove();\n    });\n\n    return _this.parentNode;\n  };\n\n  this.solid = function () {\n    return lineStyle.call(_this, 'solid');\n  };\n\n  this.dashed = function () {\n    return lineStyle.call(_this, 'dashed');\n  };\n\n  this.dotted = function () {\n    return lineStyle.call(_this, 'dotted');\n  };\n}\n\nfunction grid(type, ticksNumber) {\n  return new chrtGrid(type, ticksNumber);\n}\n\nchrtGrid.prototype = Object.create(chrtGeneric.prototype);\nchrtGrid.prototype.constructor = chrtGrid;\nchrtGrid.parent = chrtGeneric.prototype;\nchrtGrid.prototype = Object.assign(chrtGrid.prototype, {\n  //chrtGrid.prototype = grid.prototype = {\n  width: lineWidth,\n  color: lineColor,\n  minor: minor,\n  firstTick: firstTick,\n  lastTick: lastTick,\n  filter: showTicks\n});\n // export default chrtGrid;\n\nfunction verticalGrid(ticksNumber, name) {\n  return grid.call(this, 'x', ticksNumber, name);\n}\nfunction horizontalGrid(ticksNumber, name) {\n  return grid.call(this, 'y', ticksNumber, name);\n}\n\nexport { grid as chrtGrid, horizontalGrid, verticalGrid };\n","// chrt-line v0.0.17 Copyright 2020-2021 chrt chrt.io\nimport { chrtGeneric } from 'chrt-core';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction lineWidth(value) {\n  if (isNull(value)) {\n    return this.strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction lineColor(value) {\n  if (isNull(value)) {\n    return this.stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.stroke = value;\n  }\n\n  return this;\n}\n\nfunction lineOpacity(value) {\n  if (isNull(value)) {\n    return this.strokeOpacity;\n  }\n\n  if (typeof value === 'function') ; else {\n    this.strokeOpacity = value;\n  }\n\n  return this;\n}\n\nfunction fillColor(value) {\n  if (isNull(value)) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction fillOpacity(value) {\n  if (isNull(value)) {\n    return this._fillOpacity;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fillOpacity = value;\n  }\n\n  return this;\n}\n\nfunction area() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'bottom';\n\n  if (typeof value === 'function') ; else {\n    this._area = value;\n  }\n\n  return this;\n}\n\nfunction zero(value) {\n  if (isNull(value)) {\n    return this._zero;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._zero = value;\n  }\n\n  return this;\n}\n\nfunction sort(value) {\n  if (isNull(value)) {\n    return this._sortedData;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._sortedData = value;\n  }\n\n  return this;\n}\n\nvar DEFAULT_LINE_WIDTH = 1;\nvar DEAULT_LINE_COLOR = '#000';\nvar DEFAULT_LINE_OPACITY = 1;\nvar DEAULT_FILL_COLOR = '#000';\nvar DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtLine() {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log(chrtGeneric)\n  // console.log(this.render)\n\n  this.type = 'series';\n  this._area = false;\n  this._stacked = null;\n  this._sortedData = true;\n  var coords = {\n    x: 'x',\n    y: 'y',\n    x0: 'x0',\n    y0: 'y0'\n  }; // this.fields.y0 = 'y0';\n\n  this.strokeWidth = DEFAULT_LINE_WIDTH;\n  this.stroke = DEAULT_LINE_COLOR;\n  this.strokeOpacity = DEFAULT_LINE_OPACITY;\n  this._fill = DEAULT_FILL_COLOR;\n  this._fillOpacity = DEFAULT_FILL_OPACITY;\n  this.paths = [];\n  this.areaPaths = [];\n  this._classNames = ['chrt-line'];\n\n  this.draw = function () {\n    var _data = _this._data.length ? _this._data : _this.parentNode._data;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    }); //console.log('LINECHART FIELDS', this.fields)\n\n\n    if (isNull(_this.fields[coords.x])) {\n      _this.fields[coords.x] = _this.parentNode.scales[coords.x][_this.scales[coords.x]].field;\n    }\n\n    if (isNull(_this.fields[coords.y])) {\n      //console.log('this.scales', this.scales)\n      //console.log('this.parentNode.scales', this.parentNode.scales)\n      _this.fields[coords.y] = _this.parentNode.scales[coords.y][_this.scales[coords.y]].field;\n    }\n\n    if (isNull(_this.fields[coords.y0])) {\n      _this.fields[coords.y0] = \"\".concat(_this.parentNode.scales[coords.y][_this.scales[coords.y]].field, \"0\");\n    } // console.log('LINECHART FIELDS', this.fields)\n    // console.log('LINECHART COORDS:', coords)\n\n\n    if (!isNull(_data)) {\n      var yDomain = _this.parentNode.scales[coords.y][_this.scales[coords.y]].domain;\n      var xDomain = _this.parentNode.scales[coords.x][_this.scales[coords.x]].domain; // console.log(this.fields.x,coords.x,this.scales,'---->',this.scales[coords.x])\n\n      var _zero = 0;\n\n      switch (_this._area) {\n        case 'left':\n          _zero = xDomain[0] < 0 || xDomain[1] < 0 ? 0 : Math.min.apply(Math, _toConsumableArray(xDomain));\n          break;\n\n        case 'right':\n          _zero = xDomain[0] < 0 || xDomain[1] < 0 ? 0 : Math.max.apply(Math, _toConsumableArray(xDomain));\n          break;\n\n        case 'top':\n          _zero = yDomain[0] < 0 || yDomain[1] < 0 ? 0 : Math.max.apply(Math, _toConsumableArray(yDomain));\n          break;\n\n        case 'bottom':\n        default:\n          _zero = yDomain[0] < 0 || yDomain[1] < 0 ? 0 : Math.min.apply(Math, _toConsumableArray(yDomain));\n      } // let zero = yDomain[0] < 0 || yDomain[1] < 0 ? 0 : Math.min(...yDomain);\n\n\n      _zero = !isNull(_this._zero) ? _this._zero : _zero;\n      _this.hasCustomBaseline = _this._area && _data.some(function (d) {\n        return !isNull(d[_this.fields[coords.y0]]);\n      }); // console.log('hasCustomBaseline', this.hasCustomBaseline)\n\n      var datasetsForLine = _data.reduce(function (acc, d) {\n        var _ref;\n\n        if (isNull(d[_this.fields[coords.y]])) {\n          acc.push([]);\n          return acc;\n        }\n\n        if (!acc.length) {\n          acc.push([]);\n        }\n\n        var datumForLine = _this._stacked || _this.hasCustomBaseline ? (_ref = {}, _defineProperty(_ref, _this.fields[coords.x], d[_this.fields[coords.x]]), _defineProperty(_ref, _this.fields[coords.y], d[_this.fields[coords.y]]), _defineProperty(_ref, \"x\", d[_this.fields[coords.x]]), _defineProperty(_ref, \"y\", _this._stacked ? d[\"stacked_\".concat(_this.fields[coords.y])] : d[_this.fields[coords.y]]), _defineProperty(_ref, \"y0\", !isNull(d[_this.fields[coords.y0]]) ? d[_this.fields[coords.y0]] : _zero), _ref) : d;\n        acc[acc.length - 1].push(datumForLine);\n        return acc;\n      }, []);\n\n      if (_this._sortedData) {\n        var _scaleX = _this.parentNode.scales[coords.x][_this.scales[coords.x]];\n        datasetsForLine.forEach(function (dataset) {\n          dataset.sort(function (a, b) {\n            if (_scaleX.transformation === 'ordinal') {\n              return ( 1) * (_scaleX.domain.indexOf(a[_this.fields[coords.x]]) - _scaleX.domain.indexOf(b[_this.fields[coords.x]]));\n            } else {\n              return ( 1) * (a[_this.fields[coords.x]] - b[_this.fields[coords.x]]);\n            }\n          });\n        });\n      }\n\n      var datasetsForPoints = datasetsForLine.filter(function (dataset) {\n        return dataset.length === 1;\n      });\n      datasetsForLine = datasetsForLine.filter(function (dataset) {\n        return dataset.length > 1;\n      });\n      datasetsForLine.forEach(function (dataset, i) {\n        if (!_this.paths[i]) {\n          _this.paths[i] = createSVG('path');\n\n          _this.paths[i].setAttribute('data-id', \"path-\".concat(i));\n\n          _this.g.appendChild(_this.paths[i]);\n        }\n\n        if (_this._area && !_this.areaPaths[i]) {\n          _this.areaPaths[i] = createSVG('path');\n\n          _this.areaPaths[i].setAttribute('data-id', \"area-path-\".concat(i));\n\n          _this.g.appendChild(_this.areaPaths[i]);\n        }\n      });\n      var datasetsForArea = [];\n\n      if (_this._area) {\n        var horizontalArea = ['left', 'right'].indexOf(_this._area) > -1; // console.log(\n        //   \"AREA\",\n        //   this._area,\n        //   \"zero\",\n        //   zero,\n        //   \"xDomain:\",\n        //   xDomain,\n        //   \"yDomain:\",\n        //   yDomain\n        // );\n\n        datasetsForLine.forEach(function (dataset) {\n          var _ref4, _ref5, _ref6, _ref7;\n\n          var dataForAreaBaseline = _this._stacked || _this.hasCustomBaseline ? _toConsumableArray(dataset).reverse().map(function (d) {\n            var _ref2, _ref3;\n\n            return horizontalArea ? (_ref2 = {\n              x: d[_this.fields[coords.x0]],\n              y: d[_this.fields[coords.y]]\n            }, _defineProperty(_ref2, _this.fields[coords.x0], d[_this.fields[coords.x0]]), _defineProperty(_ref2, _this.fields[coords.y], d[_this.fields[coords.y]]), _ref2) : (_ref3 = {\n              x: d[_this.fields[coords.x]],\n              y: d[_this.fields[coords.y0]]\n            }, _defineProperty(_ref3, _this.fields[coords.x], d[_this.fields[coords.x]]), _defineProperty(_ref3, _this.fields[coords.y0], d[_this.fields[coords.y0]]), _ref3);\n          }) : [horizontalArea ? (_ref4 = {\n            x: _zero,\n            y: dataset[dataset.length - 1][_this.fields[coords.y]]\n          }, _defineProperty(_ref4, _this.fields[coords.x], _zero), _defineProperty(_ref4, _this.fields[coords.y], dataset[dataset.length - 1][_this.fields[coords.y]]), _ref4) : (_ref5 = {\n            x: dataset[dataset.length - 1][_this.fields[coords.x]],\n            y: _zero\n          }, _defineProperty(_ref5, _this.fields[coords.x], dataset[dataset.length - 1][_this.fields[coords.x]]), _defineProperty(_ref5, _this.fields[coords.y], _zero), _ref5), horizontalArea ? (_ref6 = {\n            x: _zero,\n            y: dataset[0][_this.fields[coords.y]]\n          }, _defineProperty(_ref6, _this.fields[coords.x], _zero), _defineProperty(_ref6, _this.fields[coords.y], dataset[0][_this.fields[coords.y]]), _ref6) : (_ref7 = {\n            x: dataset[0][_this.fields[coords.x]],\n            y: _zero\n          }, _defineProperty(_ref7, _this.fields[coords.x], dataset[0][_this.fields[coords.x]]), _defineProperty(_ref7, _this.fields[coords.y], _zero), _ref7)];\n          datasetsForArea.push(dataForAreaBaseline);\n        });\n      }\n\n      if (_this._area && _this.areaPaths.length > 0) {\n        // console.log(\"datasetsForArea\", datasetsForArea);\n        datasetsForArea.forEach(function (dataset, i) {\n          var areaPath = _this.areaPaths[i]; // console.log(\"areaPath\", areaPath);\n\n          var dArea = _this.interpolationFunction([].concat(datasetsForLine[i], dataset)); // console.log(\"dArea\", dArea, 'from', datasetsForLine[i], dataset);\n\n\n          areaPath.setAttribute('d', dArea.join(''));\n          areaPath.setAttribute('fill', _this._fill);\n          areaPath.setAttribute('fill-opacity', _this._fillOpacity);\n          areaPath.setAttribute('stroke', 'none');\n        });\n      } // console.log('LINE CHART', datasetsForLine)\n      // console.log(this)\n\n\n      datasetsForLine.forEach(function (dataset, i) {\n        // console.log('interpolationFunction', this.interpolationFunction)\n        var d = _this.interpolationFunction([].concat(dataset)); // console.log('d', d)\n\n\n        var path = _this.paths[i];\n        path.setAttribute('d', d.join(''));\n        path.setAttribute('stroke', _this.stroke);\n        path.setAttribute('stroke-width', _this.strokeWidth);\n        path.setAttribute('stroke-opacity', _this.strokeOpacity);\n        path.setAttribute('stroke-linejoin', 'round');\n        path.setAttribute('fill', 'none');\n      });\n      datasetsForPoints.forEach(function (dataset) {\n        var singlePoints = dataset.filter(function (d, i, points) {\n          return (isNull(points[i - 1]) || isNull(points[i - 1][_this.fields[coords.y]])) && !isNull(d[_this.fields[coords.y]]) && (isNull(points[i + 1]) || isNull(points[i + 1][_this.fields[coords.y]]));\n        }); // TODO: if the data changes and new single points are added they won't be rendered\n\n        if (!_this.points) {\n          _this.points = [];\n          singlePoints.forEach(function (point) {\n            var circle = createSVG('circle');\n\n            _this.points.push({\n              circle: circle,\n              point: point\n            });\n\n            _this.g.appendChild(circle);\n          });\n        }\n\n        _this.points.forEach(function (d) {\n          d.circle.setAttribute('cx', _this.parentNode.scales[coords.x][_this.scales[coords.x]](d.point[_this.fields[coords.x]]));\n          d.circle.setAttribute('cy', _this.parentNode.scales[coords.y][_this.scales[coords.y]](d.point[_this.fields[coords.y]]));\n          d.circle.setAttribute('fill', _this.stroke);\n          d.circle.setAttribute('r', _this.strokeWidth);\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtLine.prototype = Object.create(chrtGeneric.prototype);\nchrtLine.prototype.constructor = chrtLine;\nchrtLine.parent = chrtGeneric.prototype;\nchrtLine.prototype = Object.assign(chrtLine.prototype, {\n  width: lineWidth,\n  color: lineColor,\n  opacity: lineOpacity,\n  area: area,\n  fill: fillColor,\n  fillOpacity: fillOpacity,\n  zero: zero,\n  sort: sort\n}); // export default chrtLine;\n\nfunction chrtLine$1 () {\n  return new chrtLine();\n}\n\nexport { chrtLine$1 as chrtLine };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.17 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction isInfinity(value) {\n  return !isFinite(value);\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction lineWidth(value) {\n  return this.attr('strokeWidth', value, function (value) {\n    return Math.max(0, value);\n  });\n}\n\nfunction lineColor(value) {\n  return this.attr('stroke', value);\n}\n\nfunction fillColor(value) {\n  return this.attr('fill', value);\n}\n\n// export default function width(value) {\n//   if(!value) {\n//     return this.barRatioWidth;\n//   }\n//\n//   if (typeof value === 'function') {\n//     // something will go here\n//   } else {\n//     this.barRatioWidth = value;\n//   }\n//   return this;\n// }\nfunction width(value) {\n  return this.attr('barRatioWidth', value, function (value) {\n    return Math.max(0, Math.min(value, 1));\n  });\n}\n\nvar DEFAULT_STROKE_WIDTH = 0;\nvar DEAULT_LINE_COLOR = '#000';\nvar DEAULT_FILL_COLOR = '#ddd';\nvar DEFAULT_BAR_WIDTH = 3;\nvar DEFAULT_BAR_RADIO_WIDTH = 1;\n\nfunction chrtBars() {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'series';\n  this._stacked = null;\n  this._grouped = 1;\n  this._groupIndex = 0; //this.strokeWidth = DEFAULT_STROKE_WIDTH;\n\n  var _barWidth = DEFAULT_BAR_WIDTH;\n  this.attr('barRatioWidth', DEFAULT_BAR_RADIO_WIDTH);\n  this.attr('stroke', DEAULT_LINE_COLOR);\n  this.attr('fill', DEAULT_FILL_COLOR);\n  this.attr('strokeWidth', DEFAULT_STROKE_WIDTH);\n  this._classNames = ['chrt-bars'];\n\n  this.getXScale = function () {\n    if (isNull(_this.fields.x)) {\n      _this.fields.x = _this.parentNode.scales.x[_this.scales.x].field;\n    }\n\n    return _this.parentNode.scales.x[_this.scales.x];\n  };\n\n  this.barWidth = function () {\n    return _barWidth;\n  };\n\n  this.draw = function () {\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        scales = _this$parentNode.scales;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    if (isNull(_this.fields.y)) {\n      _this.fields.y = scales.y[_this.scales.y].field;\n    }\n\n    if (isNull(_this.fields.x)) {\n      //console.log('this.scales', this.scales)\n      //console.log('this.parentNode.scales', this.parentNode.scales)\n      _this.fields.x = scales.x[_this.scales.x].field;\n    }\n\n    if (isNull(_this.fields.x0)) {\n      _this.fields.x0 = \"\".concat(scales.x[_this.scales.x].field, \"0\");\n    }\n\n    var _scaleX = scales.x[_this.scales.x];\n    var _scaleY = scales.y[_this.scales.y]; // console.log('_scaleY.barwidth', _scaleY.barwidth)\n\n    var _data = _this._data.length ? _this._data : _this.parentNode._data;\n\n    if (!isNull(_data)) {\n      _barWidth = _data.reduce(function (acc, d, i, arr) {\n        var next = arr[i + 1];\n\n        if (!isNull(d) && !isNull(d[_this.fields.y]) && !isNull(next) && !isNull(next[_this.fields.y])) {\n          var y1 = _scaleY(d[_this.fields.y]);\n\n          var y2 = _scaleY(next[_this.fields.y]);\n\n          var delta = Math.abs(y2 - y1);\n          acc = delta < acc ? delta : acc;\n        }\n\n        return acc;\n      }, Math.abs(_scaleY.barwidth)); // console.log('_barWidth', _barWidth)\n\n      var flooredBarWidth = Math.floor(_barWidth);\n      var barWidth = flooredBarWidth || _barWidth || 0;\n\n      if (isNaN(barWidth) || isInfinity(barWidth)) {\n        barWidth = 1;\n      }\n\n      barWidth = barWidth * (_this._group ? _this._group.width() : 1); //console.log('GROUP WIDTH', this._group ? this._group.width() : 1)\n\n      var _grouped = _this._stacked ? _this._stacked._grouped : _this._grouped || _this._grouped;\n\n      var _groupIndex = _this._stacked ? _this._stacked._groupIndex : _this._groupIndex || _this._groupIndex;\n\n      _barWidth = barWidth / _grouped * _this.attr('barRatioWidth')(); // this.g.setAttribute('transform', `translate(${barWidth / _grouped * _groupIndex + (barWidth/_grouped)/2 - barWidth/2}, 0)`)\n\n      _this.g.setAttribute('transform', \"translate(0, \".concat(barWidth / _grouped * _groupIndex + barWidth / _grouped / 2 - barWidth / 2, \")\")); // console.log(barWidth, _grouped, _groupIndex)\n\n\n      var yAxis = _this.parentNode.getAxis('y');\n\n      var axisLineWidth = yAxis ? yAxis.width() : 0;\n\n      _data.forEach(function (d, i, arr) {\n        // const point = points.find(p => )\n        var rect = _this.g.querySelector(\"[data-id='rect-\".concat(name, \"-\").concat(i, \"']\"));\n\n        if (!rect) {\n          rect = createSVG('rect');\n          rect.setAttribute('data-id', \"rect-\".concat(name, \"-\").concat(i)); // rect.setAttribute('shape-rendering', 'crispEdges');\n\n          _this.g.appendChild(rect);\n        }\n\n        var y = _scaleY(d[_this.fields.y]) - _barWidth / 2;\n\n        if (isNaN(y)) {\n          return;\n        }\n\n        var x = _scaleX(d[_this._stacked ? \"stacked_\".concat(_this.fields.x) : _this.fields.x]); // const y0 = _scaleY(0);\n\n\n        var x0 = !isNull(d[_this.fields.x0]) ? _scaleX.isLog() ? _scaleX.range[0] + _margins.left : _scaleX(d[_this.fields.x0]) : null;\n\n        if (isNull(x0)) {\n          x0 = _scaleX.isLog() ? _scaleX.range[0] + _margins.left : _scaleX(0);\n        }\n\n        x0 = !isNull(d[_this.fields.x0]) ? _scaleX(d[_this.fields.x0]) : _scaleX(_scaleX.domain[0]); // console.log('isLog', _scaleX.isLog(), x0,'<',x)\n        // console.log('--->', d, y0)\n\n        rect.setAttribute('x', x0); // > x0 ? x0 : x);\n\n        rect.setAttribute('y', y);\n        rect.setAttribute('width', Math.max(Math.abs(x - x0), Math.abs(x - x0) - axisLineWidth / 2));\n        rect.setAttribute('height', _barWidth);\n        rect.setAttribute('fill', _this.attr('fill')(d, i, arr));\n        rect.setAttribute('stroke', _this.attr('stroke')(d, i, arr));\n        rect.setAttribute('stroke-width', _this.attr('strokeWidth')(d, i, arr));\n      }); // // // console.log('points', points);\n\n    }\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtBars.prototype = Object.create(chrtGeneric.prototype);\nchrtBars.prototype.constructor = chrtBars;\nchrtBars.parent = chrtGeneric.prototype;\nchrtBars.prototype = Object.assign(chrtBars.prototype, {\n  width: width,\n  strokeWidth: lineWidth,\n  color: lineColor,\n  fill: fillColor\n}); // export default chrtBars;\n\nfunction chrtBars$1 () {\n  return new chrtBars();\n}\n\nvar DEFAULT_STROKE_WIDTH$1 = 0;\nvar DEAULT_LINE_COLOR$1 = '#000';\nvar DEAULT_FILL_COLOR$1 = '#ddd';\nvar DEFAULT_BAR_WIDTH$1 = 3;\nvar DEFAULT_BAR_RADIO_WIDTH$1 = 1;\n\nfunction chrtColumns() {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'series';\n  this._stacked = null;\n  this._grouped = 1;\n  this._groupIndex = 0; //this.strokeWidth = DEFAULT_STROKE_WIDTH;\n\n  var _barWidth = DEFAULT_BAR_WIDTH$1;\n  this.attr('barRatioWidth', DEFAULT_BAR_RADIO_WIDTH$1);\n  this.attr('stroke', DEAULT_LINE_COLOR$1);\n  this.attr('fill', DEAULT_FILL_COLOR$1);\n  this.attr('strokeWidth', DEFAULT_STROKE_WIDTH$1);\n  this._classNames = ['chrt-columns'];\n\n  this.getXScale = function () {\n    if (isNull(_this.fields.x)) {\n      _this.fields.x = _this.parentNode.scales.x[_this.scales.x].field;\n    }\n\n    return _this.parentNode.scales.x[_this.scales.x];\n  };\n\n  this.draw = function () {\n    var _this$parentNode = _this.parentNode,\n        _margins = _this$parentNode._margins,\n        scales = _this$parentNode.scales;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    if (isNull(_this.fields.x)) {\n      _this.fields.x = scales.x[_this.scales.x].field;\n    }\n\n    if (isNull(_this.fields.y)) {\n      //console.log('this.scales', this.scales)\n      //console.log('this.parentNode.scales', this.parentNode.scales)\n      _this.fields.y = scales.y[_this.scales.y].field;\n    }\n\n    if (isNull(_this.fields.y0)) {\n      _this.fields.y0 = \"\".concat(scales.y[_this.scales.y].field, \"0\");\n    }\n\n    var _scaleX = scales.x[_this.scales.x];\n    var _scaleY = scales.y[_this.scales.y];\n\n    var _data = _this._data.length ? _this._data : _this.parentNode._data;\n\n    if (!isNull(_data)) {\n      _barWidth = _data.reduce(function (acc, d, i, arr) {\n        var next = arr[i + 1];\n\n        if (!isNull(d) && !isNull(d[_this.fields.x]) && !isNull(next) && !isNull(next[_this.fields.x])) {\n          var x1 = _scaleX(d[_this.fields.x]);\n\n          var x2 = _scaleX(next[_this.fields.x]);\n\n          var delta = Math.abs(x2 - x1);\n          acc = delta < acc ? delta : acc;\n        }\n\n        return acc;\n      }, _scaleX.barwidth);\n      var flooredBarWidth = Math.floor(_barWidth);\n      var barWidth = flooredBarWidth || _barWidth || 0;\n\n      if (isNaN(barWidth) || isInfinity(barWidth)) {\n        barWidth = 1;\n      }\n\n      barWidth = barWidth * (_this._group ? _this._group.width() : 1); // console.log('GROUP WIDTH', this._group ? this._group.width() : 1)\n\n      var _grouped = _this._stacked ? _this._stacked._grouped : _this._grouped || _this._grouped;\n\n      var _groupIndex = _this._stacked ? _this._stacked._groupIndex : _this._groupIndex || _this._groupIndex;\n\n      _barWidth = barWidth / _grouped * _this.attr('barRatioWidth')();\n      var deltaX = barWidth / _grouped * _groupIndex + barWidth / _grouped / 2 - barWidth / 2;\n\n      _this.g.setAttribute('transform', \"translate(\".concat(deltaX, \", 0)\"));\n\n      var xAxis = _this.parentNode.getAxis('x');\n\n      var axisLineWidth = xAxis ? xAxis.width() : 0;\n\n      _data.forEach(function (d, i, arr) {\n        // const point = points.find(p => )\n        var rect = _this.g.querySelector(\"[data-id='rect-\".concat(name, \"-\").concat(i, \"']\"));\n\n        if (!rect) {\n          rect = createSVG('rect');\n          rect.setAttribute('data-id', \"rect-\".concat(name, \"-\").concat(i)); // rect.setAttribute('shape-rendering', 'crispEdges');\n\n          _this.g.appendChild(rect);\n        }\n\n        var x = _scaleX(d[_this.fields.x]) - _barWidth / 2;\n\n        if (isNaN(x)) {\n          return;\n        }\n\n        var y = _scaleY(d[_this._stacked ? \"stacked_\".concat(_this.fields.y) : _this.fields.y]); // const y0 = _scaleY(0);\n\n\n        var y0 = !isNull(d[_this.fields.y0]) ? _scaleY(d[_this.fields.y0]) : null;\n\n        if (isNull(y0)) {\n          y0 = _scaleY.isLog() ? _scaleY.range[0] - _margins.bottom : _scaleY(0);\n        } // console.log('--->', d, y0)\n\n\n        rect.setAttribute('x', x);\n        rect.setAttribute('y', y > y0 ? y0 : y);\n        rect.setAttribute('width', _barWidth);\n        rect.setAttribute('height', Math.max(Math.abs(y - y0), Math.abs(y - y0) - axisLineWidth / 2));\n        rect.setAttribute('fill', _this.attr('fill')(d, i, arr));\n        rect.setAttribute('stroke', _this.attr('stroke')(d, i, arr));\n        rect.setAttribute('stroke-width', _this.attr('strokeWidth')(d, i, arr));\n      }); // // // console.log('points', points);\n\n    }\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtColumns.prototype = Object.create(chrtGeneric.prototype);\nchrtColumns.prototype.constructor = chrtColumns;\nchrtColumns.parent = chrtGeneric.prototype;\nchrtColumns.prototype = Object.assign(chrtColumns.prototype, {\n  width: width,\n  strokeWidth: lineWidth,\n  color: lineColor,\n  fill: fillColor\n});\nfunction chrtColumns$1 () {\n  return new chrtColumns();\n}\n\nexport { chrtBars$1 as chrtBars, chrtColumns$1 as chrtColumns };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt.io v0.0.10 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction pointSize(value) {\n  return this.attr('radius', value);\n}\n\nfunction pointColor(value) {\n  return this.attr('fill', value);\n}\n\nfunction pointStroke(value) {\n  return this.attr('stroke', value);\n}\n\nfunction pointStrokeWidth(value) {\n  return this.attr('strokeWidth', value);\n}\n\nfunction pointOpacity(value) {\n  return this.attr('fillOpacity', value);\n}\n\nfunction strokeOpacity(value) {\n  return this.attr('strokeOpacity', value);\n}\n\nvar DEFAULT_POINT_SIZE = 3;\nvar DEFAULT_POINT_COLOR = '#000';\n\nfunction chrtPoints() {\n  var _this = this;\n\n  chrtGeneric.call(this);\n  this.type = 'series'; // this.size = DEFAULT_POINT_SIZE;\n  // this.fill = DEFAULT_POINT_COLOR;\n  // this.stroke = DEFAULT_POINT_COLOR;\n  // this.strokeWidth = 0;\n  // this._opacity = 1;\n\n  this.attr('radius', DEFAULT_POINT_SIZE);\n  this.attr('stroke', DEFAULT_POINT_COLOR);\n  this.attr('fill', DEFAULT_POINT_COLOR);\n  this.attr('strokeWidth', 0);\n  this.attr('strokeOpacity', 1);\n  this.attr('fillOpacity', 1);\n  this._classNames = ['chrt-points'];\n\n  this.draw = function () {\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    if (!isNull(_this._data)) {\n      if (isNull(_this.fields.x)) {\n        _this.fields.x = _this.parentNode.scales.x[_this.scales.x].field;\n      }\n\n      if (isNull(_this.fields.y)) {\n        //console.log('this.scales', this.scales)\n        //console.log('this.parentNode.scales', this.parentNode.scales)\n        _this.fields.y = _this.parentNode.scales.y[_this.scales.y].field;\n      }\n\n      _this._data.forEach(function (d, i, arr) {\n        // const point = points.find(p => )\n        var circle = _this.g.querySelector(\"[data-id='circle-\".concat(name, \"-\").concat(i, \"']\"));\n\n        if (!circle) {\n          circle = createSVG('circle');\n          circle.setAttribute('data-id', \"circle-\".concat(name, \"-\").concat(i));\n\n          _this.g.appendChild(circle);\n        }\n\n        if (!isNull(_this.parentNode.scales.x[_this.scales.x]) && !isNull(_this.parentNode.scales.y[_this.scales.y])) {\n          var x = _this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]);\n\n          var y = _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y]);\n\n          circle.setAttribute('cx', !isNaN(x) ? x : 0);\n          circle.setAttribute('cy', !isNaN(y) ? y : 0);\n          circle.setAttribute('r', _this.attr('radius')(d, i, arr));\n          circle.setAttribute('fill', _this.attr('fill')(d, i, arr));\n          circle.setAttribute('fill-opacity', _this.attr('fillOpacity')(d, i, arr) || 1);\n          circle.setAttribute('stroke', _this.attr('stroke')(d, i, arr));\n          circle.setAttribute('stroke-width', _this.attr('strokeWidth')(d, i, arr));\n          circle.setAttribute('stroke-opacity', _this.attr('strokeOpacity')(d, i, arr));\n        }\n      }); // // // console.log('points', points);\n\n    }\n\n    return _this.parentNode;\n  };\n}\n\nchrtPoints.prototype = Object.create(chrtGeneric.prototype);\nchrtPoints.prototype.constructor = chrtPoints;\nchrtPoints.parent = chrtGeneric.prototype;\nchrtPoints.prototype = Object.assign(chrtPoints.prototype, {\n  pointSize: pointSize,\n  size: pointSize,\n  radius: pointSize,\n  color: pointColor,\n  stroke: pointStroke,\n  width: pointStrokeWidth,\n  strokeWidth: pointStrokeWidth,\n  opacity: pointOpacity,\n  strokeOpacity: strokeOpacity\n}); // export default chrtPoints;\n\nfunction chrtPoints$1 () {\n  return new chrtPoints();\n}\n\nexport { chrtPoints$1 as chrtPoints };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt-label v0.0.17 Copyright 2020-2021 chrt chrt.io\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction color(value) {\n  if (isNull(value)) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction position(coords) {\n  if (isNull(coords)) {\n    return this._position;\n  }\n\n  if (typeof coords === 'function') ; else {\n    this._position = Object.assign({}, this._position, coords);\n  }\n\n  return this;\n}\nfunction top(y) {\n  if (isNull(y)) {\n    return this.position().y;\n  }\n\n  return position.call(this, {\n    y: y\n  });\n}\nfunction left(x) {\n  if (isNull(x)) {\n    return this.position().x;\n  }\n\n  return position.call(this, {\n    x: x\n  });\n}\n\nfunction alignment(align) {\n  if (isNull(align)) {\n    return this._alignment;\n  }\n\n  if (typeof coords === 'function') ; else {\n    this._alignment = Object.assign({}, this._alignment, align);\n  }\n\n  return this;\n}\nfunction valign(position) {\n  if (isNull(position)) {\n    return this._alignment.vertical;\n  }\n\n  var vertical = this._alignment.vertical;\n\n  switch (position) {\n    case 'top':\n      vertical = '-0.7em';\n      break;\n\n    case 'bottom':\n      vertical = '1em';\n      break;\n\n    case 'middle':\n    default:\n      vertical = '0.25em';\n  }\n\n  this._vposition = position;\n  return alignment.call(this, {\n    vertical: vertical\n  });\n}\nfunction align(position) {\n  if (isNull(position)) {\n    return this._alignment.horizontal;\n  }\n\n  var horizontal = this._alignment.horizontal;\n\n  switch (position) {\n    case 'end':\n    case 'right':\n      this._alignment.horizontal = 'end';\n      horizontal = 'end';\n      break;\n\n    case 'middle':\n    case 'center':\n      this._alignment.horizontal = 'middle';\n      horizontal = 'middle';\n      break;\n\n    case 'left':\n    default:\n      horizontal = 'start';\n  }\n\n  this._hposition = position;\n  return alignment.call(this, {\n    horizontal: horizontal\n  });\n}\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this;\n}\n\nfunction offset() {\n  for (var _len = arguments.length, offsets = new Array(_len), _key = 0; _key < _len; _key++) {\n    offsets[_key] = arguments[_key];\n  }\n\n  if (isNull(offsets)) {\n    return this._offsets;\n  }\n\n  var topOffset = offsets[0],\n      leftOffset = offsets[1];\n  var top = this._offsets[0];\n\n  if (!isNull(topOffset)) {\n    top = typeof topOffset === 'function' ? topOffset : function () {\n      return topOffset;\n    };\n  }\n\n  var left = this._offsets[1];\n\n  if (!isNull(leftOffset)) {\n    left = typeof leftOffset === 'function' ? leftOffset : function () {\n      return leftOffset;\n    };\n  }\n\n  this._offsets = [top, left];\n  /*\n  console.log('!!! offset', top, left)\n  if(!isNull(top) && typeof top === 'function') {\n   } else {\n    console.log('offset.top is not a f')\n    top = () => 123;\n  }\n  if(!isNull(left) && typeof left === 'function') {\n   } else {\n    left = () => left;\n  }\n  this._offsets[0] = !isNull(top) ? top  : this._offsets[0];\n  this._offsets[1] = !isNull(left) ? left  : this._offsets[1];\n   console.log('SO OFFSET', this._offsets)\n  */\n\n  return this;\n}\n\nfunction outside(value) {\n  return this.attr('outside', value);\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nvar DEFAULT_FILL_COLOR = '#000';\n\nfunction chrtLabel(text) {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log('chrtLabel', this);\n\n  this.type = 'label';\n  this.g = null;\n  this._fill = null;\n  this._position = {};\n  this._alignment = {\n    horizontal: 'start',\n    vertical: '0.25em'\n  };\n  this._vposition = 'middle';\n  this._hposition = 'start';\n  this._margins = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  this._offsets = [function () {\n    return 0;\n  }, function () {\n    return 0;\n  }];\n  this._classNames = ['chrt-label'];\n\n  this.value = function (text) {\n    return _this.attr('text', text);\n  };\n\n  this.value(text);\n\n  this.draw = function () {\n    if (!_this.parentNode.parentNode.scales) {\n      return _this.parentNode.parentNode;\n    }\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    _this.g.setAttribute('id', _this.id());\n\n    var scales = _this.parentNode.parentNode.scales;\n\n    _this._classNames.forEach(function (d) {\n      return _this.g.classList.add(d);\n    });\n\n    var getPosition = function getPosition(position) {\n      return function (field) {\n        // console.log('getPosition', position, field)\n        if (isNull(position[field])) {\n          if (!isNull(_this.parentNode._data) && _this.parentNode._data.length) {\n            // console.log('--->', this.parentNode._data)\n            return _this.parentNode._data[_this.parentNode._data.length - 1][field];\n          } else {\n            return 0;\n          }\n        }\n\n        return position[field];\n      };\n    };\n\n    if (scales && scales.x[_this.parentNode.scales.x]) {\n      var x = scales.x[_this.parentNode.scales.x](getPosition(_this._position)(_this.parentNode.fields.x)) + _this._margins.left - _this._margins.right + _this._offsets[1](); // console.log('x', x, this._margins)\n      // if y is not defined by the user, it should be calculated based on the closest Y value based on X\n\n\n      var y = scales.y[_this.parentNode.scales.y](getPosition(_this._position)(_this.parentNode.fields.y)) + _this._margins.top - _this._margins.bottom + _this._offsets[0]();\n\n      _this.g.setAttribute('transform', \"translate(\".concat(isNaN(x) ? 0 : x, \",\").concat(isNaN(y) ? 0 : y, \")\")); // console.log('drawing label', this._offsets[0](), this._offsets[1]())\n\n    }\n\n    var label = _this.g.querySelector('text');\n\n    if (!label) {\n      label = createSVG('text');\n      label.setAttribute('data-id', \"label-\".concat(_this.attr('text')()));\n\n      _this.g.appendChild(label);\n    }\n\n    label.setAttribute('fill', _this._fill || _this.parentNode.stroke || DEFAULT_FILL_COLOR);\n    label.textContent = _this.attr('text')();\n    var textAnchor = _this._alignment.horizontal;\n\n    if (_this.outside() && _this.outside()()) {\n      textAnchor = textAnchor === 'start' ? 'end' : 'start';\n    }\n\n    label.setAttribute('text-anchor', textAnchor);\n    label.setAttribute('dy', _this._alignment.vertical); // console.log('---->', chrtGeneric.prototype)\n    // console.log('--->', chrtGeneric.hasData.call(this))\n  };\n}\n\nchrtLabel.prototype = Object.create(chrtGeneric.prototype); // console.log('WHAT IS THIS?')\n// console.log(Object.create(chrtGeneric.prototype))\n\nchrtLabel.prototype.constructor = chrtLabel; // chrtLabel.parent = chrtGeneric.prototype;\n\nchrtLabel.prototype = Object.assign(chrtLabel.prototype, {\n  color: color,\n  position: position,\n  top: top,\n  left: left,\n  align: align,\n  valign: valign,\n  margins: setMargins,\n  offset: offset,\n  outside: outside\n}); // export default chrtLabel;\n\nfunction chrtLabel$1 (text) {\n  return new chrtLabel(text);\n}\n\n// const DEFAULT_FILL_COLOR = '#000';\n// const DEFAULT_STROKE = '#000';\n// const DEFAULT_STROKE_OPACITY = 1;\n// const DEFAULT_STROKE_WIDTH = 1;\n// const DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtLabels() {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log(\"HI WE ARE LABELS\", this);\n\n  this.type = 'labels';\n  this.labels = [];\n  this.g = null;\n\n  this.labelsFilter = function () {\n    return true;\n  };\n\n  this._alignment = {\n    horizontal: 'end',\n    vertical: 'middle'\n  };\n  this._hposition = 'middle';\n  this._vposition = 'top'; // const isOutside = () => {\n  //   return this.attrs['outside'];\n  // }\n\n  this.value = function (field) {\n    return _this.attr('textField', field);\n  };\n\n  this.position = function (position) {\n    return _this.attr('position', position);\n  };\n\n  this.draw = function () {\n    var parentData = _this.parentNode.data();\n\n    var data = parentData.length ? parentData : _this.parentNode.parentNode._data || [];\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    var isBars = _this.parentNode.constructor.name === 'chrtBars';\n    data.forEach(function (label, i) {\n      // console.log(this._alignment.horizontal, label);\n      // console.log(this.parentNode.fields.x0)\n      // console.log(this.parentNode.getXScale())\n      var top = label[_this.parentNode.fields.y];\n      var x0 = !isNull(label[_this.parentNode.fields.x0]) ? label[_this.parentNode.fields.x0] : _this.parentNode.getXScale().domain[0];\n      var left = x0;\n\n      switch (_this._alignment.horizontal) {\n        case 'start':\n          break;\n\n        case 'end':\n          left = label[_this.parentNode.fields.x] + x0;\n          break;\n\n        case 'center':\n        case 'middle':\n          left = (label[_this.parentNode.fields.x] + x0) / 2;\n          break;\n      }\n\n      left = isBars ? left : label[_this.parentNode.fields.x];\n      var offsets = {\n        top: function top() {\n          switch (_this._vposition) {\n            case 'top':\n              return isBars ? -(_this.parentNode.barWidth() || 0) / 2 : 0;\n\n            case 'bottom':\n              return isBars ? (_this.parentNode.barWidth() || 0) / 2 : 0;\n\n            case 'center':\n            case 'middle':\n              return 0;\n          }\n        }\n      };\n\n      if (!_this.labels[i]) {\n        // if the marker exists, just update its data\n        // this.markers[i].marker = marker;\n        _this.labels[i] = chrtLabel$1();\n\n        _this.parentNode.add(_this.labels[i]);\n      }\n\n      var textFieldAccessor = _this.attr('textField');\n\n      var textField = !isNull(textFieldAccessor) ? textFieldAccessor(label) : label[_this.parentNode.fields.y]; // console.log('LABELS CLASS', this.class().join(' '), this.class());\n\n      var classNames = _this[\"class\"]();\n\n      if (classNames.length) {\n        _this.labels[i][\"class\"](classNames.join(' '));\n      }\n\n      _this.labels[i].value(textField).top(top).left(left).align(_this._hposition).valign(_this._vposition).offset(offsets.top || 0,  0).outside(_this.outside());\n    });\n    return _this.parentNode;\n  };\n}\n\nchrtLabels.prototype = Object.create(chrtGeneric.prototype);\nchrtLabels.prototype.constructor = chrtLabels;\nchrtLabels.parent = chrtGeneric.prototype;\nchrtLabels.prototype = Object.assign(chrtLabels.prototype, {\n  align: align,\n  valign: valign,\n  outside: outside\n});\nfunction chrtLabels$1 () {\n  return new chrtLabels();\n}\n\nexport { chrtLabel$1 as chrtLabel, chrtLabels$1 as chrtLabels };\n","// chrt-core v0.0.25 Copyright 2020-2021 chrt chrt.io\n// Math.log() function returns the natural logarithm (base e) of a number,\n// generic function for log with multiple bases\nfunction baseLog() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  return base === Math.E ? Math.log : base === 10 && log10 || base === 2 && log2 || function (y) {\n    return getBaseLog(base, y);\n  };\n} // logarithm of y with base x:\n\nfunction getBaseLog(x, y) {\n  return Math.log(y) / Math.log(x);\n}\nvar log10 = Math.log10 = Math.log10 || function (x) {\n  return Math.log(x) * Math.LOG10E;\n};\nvar log2 = Math.log2 || function (x) {\n  return Math.log(x) * Math.LOG2E;\n};\nvar pow10 = function pow10(x) {\n  return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;\n};\nvar basePow = function basePow(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {\n    return Math.pow(base, x);\n  };\n};\n\nvar DEFAULT_WIDTH = 600;\nvar DEFAULT_HEIGHT = 300;\nvar TICKS_DEFAULT = 10;\nvar COMPONENTS_W_DATA = ['chrt', 'series'];\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\nfunction hasNaN(values) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  return values.some(function (value) {\n    return isNaN(value);\n  });\n}\nfunction uuid() {\n  return 'c' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\nfunction hasData(obj) {\n  return !isNull(obj.type) && COMPONENTS_W_DATA.indexOf(obj.type) > -1;\n}\nfunction isInfinity(value) {\n  if (typeof value === 'string') {\n    return false;\n  }\n\n  return !isFinite(value);\n}\nfunction arraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    console.warn('arraysEqual(array1, array2)', 'Both parameters should be arrays');\n    return false;\n  }\n\n  if (array1.length === 0 && array2.length === 0) {\n    return true;\n  }\n\n  return array1.length == array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction data (data, accessor) {\n  // console.log('---------------> data', data, accessor, this);\n  if (!data) {\n    // console.log('NO DATA return', hasData(this), this._data, hasData(this) ? this._data : this)\n    return hasData(this) ? this._data || [] : this;\n  } // TODO: not sure what this is doing...\n\n\n  if (!hasData(this)) {\n    return this;\n  } // // console.log('chrt or series', this.type)\n  // passing only accessor to inherit/reuse data\n\n\n  if (typeof arguments[0] === 'function') {\n    // // console.log('ACCESSOR FUNCTION')\n    this._accessor = arguments[0];\n    return this;\n  } // // console.log('DATA', this, this._data, data);\n  // data is passed\n\n\n  this._orginalData = data; // define accessor function to map values\n\n  var accessorFunction = accessor || this._accessor;\n  this._accessor = accessorFunction;\n  this._data = accessorFunction ? data.map(function (d, i, arr) {\n    if (d instanceof Object) {\n      return Object.assign({}, d, accessorFunction(d, i, arr));\n    }\n\n    return accessorFunction(d, i, arr);\n  }) : data; // console.log('DATA', this._data)\n\n  return this;\n}\n\n/**\n * node - Returns the DOM element that contains a chart element\n *\n * @param {type} node Set this as root node\n *\n * @return {type} Description\n */\nfunction node (node) {\n  if (!node) {\n    return this.g || this.root;\n  }\n\n  this.root = node;\n  this.currentNode = this.root;\n  return this;\n}\n\nfunction parent (obj) {\n  if (!obj) {\n    return this.parentNode;\n  }\n\n  this.parentNode = obj;\n  return this;\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function () {\n    // // // console.log('CURRENT CACHE', cache);\n    var args = Array.prototype.slice.call(arguments);\n    var key = JSON.stringify({\n      func: func.name,\n      args: args\n    });\n\n    if (cache[key]) {\n      // // // console.log('MEMOIZE USING CACHE', arguments, cache);\n      return cache[key];\n    } else {\n      // // // console.log('MEMOIZE NO CACHE', arguments);\n      var val = func.apply(null, arguments);\n      cache[key] = val;\n      return val;\n    }\n  };\n}\n\nfunction add(obj) {\n  // console.log('LAYOUT ADD', obj)\n  var id = uuid(); // console.log('adding', obj.type, id);\n  // console.log('HERE!!!', obj.hasData(), obj.data())\n\n  obj.id(id).parent(this).node(this.currentNode).data(obj.hasData() ? obj.data() : this._orginalData, obj.accessor() || this._accessor) // .data.apply(\n  //   COMPONENTS_W_DATA.indexOf(obj.type) === -1 ? null : obj,\n  //   [obj.data() || this._orginalData, obj.accessor() || this._accessor]\n  // )\n  .render(obj._stacked || obj._group);\n  this.objects.push(obj); // TODO: verify if the obj.updater condition is needed\n  //if(hasData(obj) || obj.updater) {\n\n  if (hasData(obj)) {\n    // // console.log('BECAUSE THE OBJ HAS DATA > UPDATE')\n    return this.update();\n  }\n\n  return this;\n}\n\nfunction append(d) {\n  if (typeof d === 'string') {\n    var node = document.createElement(d);\n    var currentNode = this.currentNode || this.root;\n    currentNode.appendChild(node);\n    this.currentNode = node;\n  }\n\n  return this;\n}\n/*\nexport default function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n*/\n\nfunction border() {\n  if (this.currentNode) {\n    this.root.querySelector('svg').style.border = '1px solid #000';\n  }\n\n  return this;\n}\n\nfunction rollup() {\n  if (this.currentNode.parentNode) {\n    this.currentNode = this.currentNode.parentNode;\n  }\n\n  return this;\n}\n\nfunction size() {\n  for (var _len = arguments.length, dimensions = new Array(_len), _key = 0; _key < _len; _key++) {\n    dimensions[_key] = arguments[_key];\n  }\n\n  if (!dimensions.length) {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  var width = dimensions[0],\n      height = dimensions[1];\n  var oldWidth = this.width;\n  var oldHeight = this.height;\n  this.width = width || oldWidth || DEFAULT_WIDTH;\n  this.height = height || oldHeight || DEFAULT_HEIGHT;\n  var svg = this.root.querySelector('svg');\n\n  if (!svg) {\n    this.svg(false);\n  }\n\n  svg = this.root.querySelector('svg');\n  svg.setAttribute('viewBox', \"0 0 \".concat(this.width, \" \").concat(this.height));\n  svg.parentNode.style.width = \"\".concat(this.width, \"px\");\n  svg.parentNode.style.height = \"\".concat(this.height, \"px\"); // if(!oldWidth || !oldHeight || oldWidth !== width || oldHeight !== height) {\n\n  return this.update(); //}\n  //return this;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nfunction svg() {\n  var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var svgNode = this.root.querySelector('svg');\n\n  if (!svgNode) {\n    svgNode = createSVG('svg');\n    svgNode.setAttribute('preserveAspectRatio', 'none');\n    svgNode.setAttribute('width', '100%');\n    svgNode.setAttribute('height', '100%'); // svgNode.style.overflow = 'visible';\n\n    this.currentNode.appendChild(svgNode); // this.svg = svgNode;\n  }\n\n  var g = svgNode.querySelector('g:first-of-type');\n\n  if (!g) {\n    g = svgNode.appendChild(createSVG('g'));\n  }\n\n  this.currentNode = g;\n\n  if (update) {\n    this.update();\n  }\n\n  return this;\n} // Render the svg <path> element\n// I:  - points (array): points coordinates\n//     - command (function)\n//       I:  - point (array) [x,y]: current point coordinates\n//           - i (integer): index of 'point' in the array 'a'\n//           - a (array): complete array of points coordinates\n//       O:  - (string) a svg path command\n// O:  - (string): a Svg <path> element\n\nvar svgPath = function svgPath(points, command) {\n  var _ref;\n\n  // build the d attributes by looping over the points\n  var splitByNullPoints = points.reduce(function (acc, point) {\n    if (isNull(point[1])) {\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(point);\n    }\n\n    return acc;\n  }, [[]]);\n  var paths = splitByNullPoints.map(function (points) {\n    return points.reduce(function (acc, point, i, a) {\n      acc.push(i === 0 ? // if first point\n      \"M\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]) : // else\n      \"\".concat(command(point, i, a)));\n      return acc;\n    }, []);\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(paths));\n};\n\nfunction setMargins(margins) {\n  if (isNull(margins)) {\n    return this._margins;\n  }\n\n  var top = margins.top,\n      bottom = margins.bottom,\n      left = margins.left,\n      right = margins.right;\n  this._margins.top = !isNull(top) ? top : this._margins.top;\n  this._margins.bottom = !isNull(bottom) ? bottom : this._margins.bottom;\n  this._margins.left = !isNull(left) ? left : this._margins.left;\n  this._margins.right = !isNull(right) ? right : this._margins.right;\n  return this.update();\n}\n\nfunction setPadding(padding) {\n  if (isNull(padding)) {\n    return this._padding;\n  }\n\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  this._padding.top = !isNull(top) ? top : this._padding.top;\n  this._padding.bottom = !isNull(bottom) ? bottom : this._padding.bottom;\n  this._padding.left = !isNull(left) ? left : this._padding.left;\n  this._padding.right = !isNull(right) ? right : this._padding.right;\n  return this.update();\n}\n\nfunction ExtendedWilkinson(_ref) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var ticksN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TICKS_DEFAULT;\n  var Q = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 5, 2, 2.5, 4, 3];\n  var onlyLoose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var w = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0.25, 0.2, 0.5, 0.05];\n  var nice = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var eps = Number.EPSILON * 100;\n  this._ticks = [];\n\n  if (dmin > dmax) {\n    var temp = dmin;\n    dmin = dmax;\n    dmax = temp;\n  } // const n = Q.length;\n\n\n  var best = {\n    score: -2\n  };\n\n  this.ticks = function (ticksNumber) {\n    // // console.log('EWILKS CALLED TICKS WITH', ticksNumber)\n    if (dmax - dmin < eps) {\n      return range(dmin, dmax, (dmax - dmin) / ticksNumber);\n    } // // console.log('RUNNING TICKS WITH', ticksNumber)\n\n\n    best = {\n      score: -2\n    };\n    var j = 1;\n\n    while (j < Infinity) {\n      var _iterator = _createForOfIteratorHelper(Q),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          var sm = simplicity.max(q, Q, j);\n\n          if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n            j = Infinity;\n            break;\n          }\n\n          var k = 2;\n\n          while (k < Infinity) {\n            var dm = density.max(k, ticksNumber);\n\n            if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n              break;\n            }\n\n            var delta = (dmax - dmin) / (k + 1) / j / q;\n            var z = Math.ceil(Math.log10(delta));\n\n            while (z < Infinity) {\n              var step = j * q * Math.pow(10, z);\n              var cm = coverage.max(dmin, dmax, step * (k - 1));\n\n              if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                break;\n              }\n\n              var min_start = Math.floor(dmax / step) * j - (k - 1) * j;\n              var max_start = Math.ceil(dmin / step) * j;\n\n              if (min_start > max_start) {\n                z += 1;\n                continue;\n              } // const range = range(min_start, max_start);\n\n\n              for (var start = min_start; start <= max_start; start++) {\n                var lmin = start * (step / j);\n                var lmax = lmin + step * (k - 1);\n                var lstep = step;\n                var s = simplicity(q, Q, j, lmin, lmax, lstep);\n                var c = coverage(dmin, dmax, lmin, lmax);\n                var g = density(k, ticksNumber, dmin, dmax, lmin, lmax);\n                var l = legibility(lmin, lmax, lstep);\n                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n\n                if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {\n                  best.lmin = lmin;\n                  best.lmax = lmax;\n\n                  if (nice) {\n                    best.lmin = lmin < lmax ? Math.floor(dmin / lstep) * lstep : Math.ceil(dmin / lstep) * lstep;\n                    best.lmax = lmax > lmin ? Math.ceil(dmax / lstep) * lstep : Math.floor(dmax / lstep) * lstep;\n                  } // // console.log('lstep', lstep);\n\n\n                  best.lstep = lstep;\n                  best.score = score;\n                }\n              }\n\n              z += 1;\n            }\n\n            k += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      j += 1;\n    } // // console.log('range',best.lmin, best.lmax + best.lstep, best.lstep)\n\n\n    _this._ticks = range(best.lmin, best.lmax + best.lstep, best.lstep); // // console.log('E-WILK RETURNING', this._ticks)\n\n    return _this._ticks;\n  };\n\n  this.ticks(ticksN); // // console.log('BEST', best);\n  // best.ticks = d3.range(best.lmin, best.lmax + best.lstep, best.lstep);\n\n  this.getMin = function () {\n    return best.lmin;\n  };\n\n  this.getMax = function () {\n    return best.lmax;\n  };\n\n  this.getStep = function () {\n    return best.lstep;\n  };\n\n  return this;\n}\n\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var eps = Number.EPSILON * 100;\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = (lmin % lstep < eps || lstep - lmin % lstep < eps) && lmin <= 0 && lmin >= 0 ? 1 : 0;\n  return 1 - (i - 1) / (n - 1) - j + v;\n}\n\nsimplicity.max = function (q, Q, j) {\n  var n = Q.length;\n  var i = match(q, Q)[0];\n  var v = 1;\n  return 1 - (i - 1) / (n - 1) - j + v;\n};\n\nfunction coverage(dmin, dmax, lmin, lmax) {\n  var range = dmax - dmin;\n  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);\n}\n\ncoverage.max = function (dmin, dmax, span) {\n  var range = dmax - dmin;\n\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - 0.5 * (Math.pow(half, 2) + Math.pow(half, 2)) / Math.pow(0.1 * range, 2);\n  } else {\n    return 1;\n  }\n};\n\nfunction density(k, m, dmin, dmax, lmin, lmax) {\n  var r = (k - 1) / (lmax - lmin);\n  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\ndensity.max = function (k, m) {\n  return k >= m ? 2 - (k - 1) / (m - 1) : 1;\n};\n\nvar legibility = function legibility() {\n  return 1;\n};\n\nfunction match(a, b) {\n  if (Array.isArray(a)) {\n    return a.map(function (d) {\n      return b.indexOf(d);\n    }).map(function (d) {\n      return d > -1 ? d : null;\n    });\n  } else {\n    var index = b.indexOf(a);\n    return index > -1 ? [index + 1] : [null];\n  }\n}\n\nfunction range() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var arr = [];\n\n  for (var i = min; i < max; i += step) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction scale(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`LINEAR scale(${name}, ${type}, ${domain}, ${range}, ${field})`)\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, field, domainExtent)\n  } // // console.log('DOMAIN AFTER IMPROVEMENT', name, [...domainExtent])\n  // const numScale = new Heckbert(domainExtent);\n\n\n  var eNumScale = new ExtendedWilkinson(domainExtent); // // console.log('E WILK', eNumScale.ticks())\n  // re-assign domain based on, max/min of heckbert nice scale\n  // console.log(domainExtent[0],domainExtent[1],'after WILKINSON', eNumScale.getMin(), eNumScale.getMax())\n  // TODO: not sure which one is best between the 2 following:\n  // if(!currentDomain) {\n  //   domainExtent[0] = eNumScale.getMin();\n  //   domainExtent[1] = eNumScale.getMax();\n  // }\n  // console.log('fixedDomain', fixedDomain);\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], eNumScale.getMin()) : eNumScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], eNumScale.getMax()) : eNumScale.getMax();\n  } // console.log('new domain is ', domainExtent)\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var domainWidth = domainExtent[1] - domainExtent[0];\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - domainExtent[0]) / domainWidth;\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var fixedTicks = Array.isArray(n) && n.length;\n    _ticks = fixedTicks ? n : eNumScale.ticks(n); // TODO: Verify this, I can't remember why this was done.\n    // if (_ticks.length > 1 && _ticks[0] < _ticks[1]) {\n    // _ticks.reverse();\n    // }\n    // console.log('TICKS', _ticks);\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: fixedTicks ? 0 : index % 2,\n        isZero: value === 0\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'linear';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = eNumScale.getStep();\n  scalingFunction.barwidth = scalingFunction(domainExtent[0] + scalingFunction.step) - scalingFunction(domainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nvar DEFAULT_BASE = 10;\nvar DEFAULT_MIN = 1;\nvar DEFAULT_MAX = 10;\nfunction logTicks(_ref, ticksNumber) {\n  var _this = this;\n\n  var _ref2 = _slicedToArray(_ref, 2),\n      dmin = _ref2[0],\n      dmax = _ref2[1];\n\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BASE;\n  this.ticksNumber = ticksNumber || TICKS_DEFAULT;\n  this._ticks = [];\n  var log = baseLog(base);\n  var pow = basePow(base);\n\n  this.improveRange = function (range) {\n    var min = range[0];\n    var max = range[1];\n\n    if (min === max) {\n      if (min <= 0) {\n        // includes null\n        min = DEFAULT_MIN;\n        max = DEFAULT_MAX;\n      } else {\n        min = pow(Math.floor(log(min)) - 1);\n        max = pow(Math.floor(log(max)) + 1);\n      }\n    }\n\n    if (min <= 0) {\n      min = pow(Math.floor(log(max)) - 1);\n    }\n\n    if (max <= 0) {\n      max = pow(Math.floor(log(min)) + 1);\n    }\n\n    return [min, max];\n  };\n\n  this.ticks = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.ticksNumber;\n    // if(this._ticks.length && n === this.ticksNumber) {\n    //   return this._ticks;\n    // }\n    _this.ticksNumber = n; // // console.log('CALCULATING TICKS', dmin, dmax, this.ticksNumber)\n\n    _this._ticks = [];\n    _this.range = _this.improveRange([dmin, dmax]); // not working well, it keeps lowering and increasing bounds\n\n    _this.lmin = Math.floor(log(dmin)) !== log(dmin) ? pow(Math.floor(log(dmin)) - 1) : dmin;\n    _this.lmax = Math.floor(log(dmax)) !== log(dmax) ? pow(Math.floor(log(dmax)) + 1) : dmax; // this.lmin = this.range[0];\n    // this.lmax = this.range[1];\n    // console.log('TICKS', n, [dmin, dmax], this.range, [this.lmin, this.lmax]);\n\n    var ticksRange = [log(_this.lmin), log(_this.lmax)]; // // console.log('ticksRange', ticksRange)\n\n    if (ticksRange[0] > 0) {\n      for (var i = ticksRange[0]; i <= ticksRange[1]; ++i) {\n        for (var k = 1; k < base; ++k) {\n          var tick = pow(i) * k; // // console.log('k1',k,base,tick)\n          // if (tick > this.lmax) break;\n\n          if (tick >= _this.lmin) {\n            _this._ticks.push(tick);\n          }\n        }\n      }\n    } else for (var _i = ticksRange[0]; _i <= ticksRange[1]; ++_i) {\n      for (var _k = base - 1; _k >= 1; --_k) {\n        var _tick = pow(_i) * _k; // // console.log('k2',k,base,tick, this.lmax)\n        // if (tick > this.lmax) break;\n\n\n        if (_tick >= _this.lmin) {\n          _this._ticks.push(_tick);\n        }\n      }\n    } // // console.log('TICKS ARE', this._ticks)\n\n\n    return _this._ticks;\n  };\n\n  this.ticks(this.ticksNumber);\n\n  this.getMin = function () {\n    return _this.lmin;\n  };\n\n  this.getMax = function () {\n    return _this.lmax;\n  };\n\n  return this;\n}\n\nfunction scale$1(name, type, domain, range, field) {\n  var _this = this;\n\n  var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n  // console.log('LOG SCALE', name, type, domain, range, 'field:', field, transformation);\n  // console.log('this.scales[',name,'].domain','=',this.scales[name].domain, 'isLog?',this.scales[name].isLog())\n  var _scale = this.scales[type][name]; // console.log(`LOG: this.scales[${type}][${name}]=`,_scale, transformation);\n\n  var log = baseLog();\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null); // console.log('setting fixedDomain to', fixedDomain)\n\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = [];\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && _scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('using domainExtent', domainExtent[0], domainExtent[1]);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  }\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    this._data.filter(function (d) {\n      return d[field] > 0;\n    }).forEach(function (d) {\n      // console.log(name, d[name])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    });\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[obj.fields[field || name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[obj.fields[field || name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('2 domainExtent ->', domainExtent[0], domainExtent[1])\n  }\n\n  var numScale = new logTicks(domainExtent); // re-assign domain based on max/min of logTicks nice scale\n  // domainExtent[0] = numScale.getMin();\n  // domainExtent[1] = numScale.getMax();\n\n  if (isNull(fixedDomain)) {\n    // console.log('--->eNumScale',eNumScale.getMin(), eNumScale.getMax())\n    domainExtent[0] = !isNull(currentDomain[0]) ? Math.min(currentDomain[0], numScale.getMin()) : numScale.getMin();\n    domainExtent[1] = !isNull(currentDomain[1]) ? Math.max(currentDomain[1], numScale.getMax()) : numScale.getMax();\n  } // console.log('NEW domain extent', domainExtent[0], domainExtent[1])\n\n\n  var domainWidth = log(domainExtent[1]) - log(domainExtent[0]);\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (log(d) - log(domainExtent[0])) / domainWidth; //// // console.log('LOG scalingFunction',domainExtent, d,log(d),log(domainExtent[0]),log(domainExtent[1]),valueToDomain);\n    // // console.log('LOG', d, startCoord  + rangeWidth * valueToDomain)\n\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks(n) {\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = numScale.ticks(n).map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value),\n        isMinor: log(value) % 1\n      };\n    });\n    return _ticks;\n  }; // console.log('scaleLog NAME', name)\n  // console.log('scaleLog FIELD', field)\n  // console.log('scaleLog TRANSFORMATION', transformation)\n\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.getTransformation = function () {\n    return transformation;\n  };\n\n  scalingFunction.transformation = transformation;\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return true;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n//import Heckbert from './util/Heckbert';\n//import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nfunction scale$2(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log('scaleOrdinal', name, type, domain, range, field)\n  var _scale = this.scales[type][name];\n  var fixedDomain = domain || (_scale && _scale.transformation === 'ordinal' ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // // console.log('rrrrange', range)\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n  // console.log('ORDINAL', _scale, _scale.getName(), _scale.transformation)\n\n  var currentDomain = _scale && _scale.transformation === 'ordinal' ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('DOMAIN', name, [...domainExtent].join(','), this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain, hasNaN(currentDomain));\n\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      if (domainExtent.indexOf(d[field || name]) === -1) {\n        domainExtent.push(d[field || name]);\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        _data.forEach(function (d) {\n          if (domainExtent.indexOf(d[obj.fields[type]]) === -1) {\n            domainExtent.push(d[obj.fields[type]]);\n          }\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent)\n  }\n\n  var domainWidth = domainExtent.length;\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction;\n  var barwidth = rangeWidth / domainExtent.length;\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = domainExtent.indexOf(d) / domainWidth;\n    return startCoord + barwidth / 2 + rangeWidth * valueToDomain;\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : domainExtent.length;\n\n    // // console.log('LINEAR SCALE', 'ticks', n)\n    if (isNull(n) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    _ticks = domainExtent;\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'ordinal';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.field = field;\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.range = range;\n  scalingFunction.step = 1;\n  scalingFunction.barwidth = barwidth; // console.log(scalingFunction.domain)\n\n  scalingFunction.ticks = ticks;\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\n// import ExtendedWilkinson from './util/ExtendedWilkinson';\n\nvar DURATION_SECOND = 1000;\nvar UNITS = {\n  second: DURATION_SECOND,\n  minute: DURATION_SECOND * 60\n};\nUNITS.hour = UNITS.minute * 60;\nUNITS.day = UNITS.hour * 24;\nObject.keys(UNITS).forEach(function (unit) {\n  return UNITS[\"\".concat(unit, \"s\")] = UNITS[unit];\n});\nvar LONGER_UNITS = {\n  bidiurnal: UNITS.day * 2,\n  week: UNITS.day * 7,\n  fortnight: UNITS.day * 14,\n  month: UNITS.day * 30,\n  // depending on year/month\n  year: UNITS.day * 365 // depending on year\n\n};\nObject.keys(LONGER_UNITS).forEach(function (unit) {\n  return LONGER_UNITS[\"\".concat(unit, \"s\")] = LONGER_UNITS[unit];\n});\nfunction scale$3(name, type, domain) {\n  var _this = this;\n\n  var range = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, DEFAULT_WIDTH];\n  var field = arguments.length > 4 ? arguments[4] : undefined;\n  // console.log(`TIME scale(${name}, ${type}, [${domain ? domain.join(',') : 'null'}], ${range}, ${field})`)\n  // console.log('domain in date:', domain ? domain.join(',') : 'null')\n  var step = UNITS.day;\n  var _scale = this.scales[type][name]; // console.log(`LINEAR: this.scales[${type}][${name}]=`,_scale);\n\n  var fixedDomain = domain || (_scale ? _scale.fixedDomain : null);\n  var copyOfFixedDomain = !isNull(fixedDomain) ? _toConsumableArray(fixedDomain) : null; // console.log('CURRENT FIXED DOMAIN IS', fixedDomain)\n\n  var _ticks = []; // TODO: this should be removed and calculated somewhere else\n\n  range[0] += type === 'x' ? this._padding.left : -this._padding.bottom;\n  range[1] -= type === 'x' ? this._padding.right : -this._padding.top; // // console.log(name,'RANGE',range)\n\n  var currentDomain = _scale && !_scale.isLog() ? _scale.domain : [];\n  var domainExtent = copyOfFixedDomain || domain || currentDomain; // console.log('---------------------> DOMAIN', name, [...domainExtent], this.scales[name])\n  // console.log('FIXED DOMAIN', name, fixedDomain)\n  // console.log('CURRENT DOMAIN', name, currentDomain);\n\n  if (arguments.length === 1) {\n    return this.scales.x[arguments[0]] || this.scales.y[arguments[0]];\n  } // if no domain defined or new domain is different from current domain\n  // calculate the new domain based on all the data\n  // console.log(\"fixedDomain\", fixedDomain);\n  // console.log(\"domainExtent\", domainExtent);\n  // console.log(\"currentDomain\", currentDomain);\n\n\n  if (isNull(fixedDomain) || hasNaN(currentDomain) || !domainExtent || !domainExtent.length || domainExtent[0] !== currentDomain[0] || domainExtent[1] !== currentDomain[1]) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, field, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? +d[field || name] : Math.min.apply(Math, _toConsumableArray([+d[field || name], domainExtent[0], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? +d[field || name] : Math.max.apply(Math, _toConsumableArray([+d[field || name], domainExtent[1], +d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('AFTER DATA DOMAIN EXTENT', name, domainExtent)\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', name, field, this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj, _data)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? +d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[0], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([+d[field || obj.fields[name]], domainExtent[1], +d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('AFTER OBJS DOMAIN EXTENT', name, field, domainExtent)\n  }\n\n  if (isNull(fixedDomain) || !domainExtent || !domainExtent.length || !arraysEqual(domainExtent, currentDomain)) {\n    // if(isNull(fixedDomain)) {\n    // console.log('CALCULATE DOMAIN BASED ON THE DATA', name, this._data)\n    this._data.forEach(function (d) {\n      // // console.log(name, domainExtent[0],d[name],domainExtent[1])\n      domainExtent[0] = isNull(domainExtent[0]) ? d[field || name] : Math.min.apply(Math, _toConsumableArray([d[field || name], domainExtent[0], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n      domainExtent[1] = isNull(domainExtent[1]) ? d[field || name] : Math.max.apply(Math, _toConsumableArray([d[field || name], domainExtent[1], d[\"stacked_\".concat(field || name)]].filter(function (value) {\n        return !isNull(value);\n      })));\n    }); // console.log('DOMAIN EXTENT', name, domainExtent.join(','), domainExtent.map(d => new Date(d)).join(','))\n    // console.log('CALCULATE DOMAIN BASED ON OBJECTS', this.objects)\n\n\n    this.objects.forEach(function (obj) {\n      var _data = !isNull(obj._data) && obj._data.length ? obj._data : _this._data;\n\n      if (_data) {\n        // console.log('OBJ/CHART', obj)\n        _data.forEach(function (d) {\n          domainExtent[0] = isNull(domainExtent[0]) ? d[field || obj.fields[name]] : Math.min.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[0], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n          domainExtent[1] = isNull(domainExtent[1]) ? d[field || obj.fields[name]] : Math.max.apply(Math, _toConsumableArray([d[field || obj.fields[name]], domainExtent[1], d[\"stacked_\".concat(field || obj.fields[name])]].filter(function (value) {\n            return !isNull(value) && !hasNaN(value);\n          })));\n        });\n      }\n    }); // console.log('DOMAIN EXTENT', name, domainExtent, domainExtent.map(d => new Date(d)))\n  } // console.log('new domain is ', domainExtent, domainExtent.map(d => new Date(d)))\n  // console.log('AFTER WILK DOMAIN',  name, [...domainExtent])\n\n\n  var calculateTimeDomain = function calculateTimeDomain(interval) {\n    if (domainExtent.length) {\n      var _domainExtent = _toConsumableArray(domainExtent); // console.log('---->', interval, '_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      if (isNull(interval)) {\n        // console.log('NEED TO FIND BEST UNIT');\n        interval = UNITS.seconds;\n        Object.keys(UNITS).forEach(function (d) {\n          // console.log(domainWidth, '>=', d, UNITS[d])\n          // console.log('testing',d,_domainExtent[1] - _domainExtent[0],'>=',UNITS[d])\n          if (Math.abs(_domainExtent[1] - _domainExtent[0]) >= UNITS[d]) {\n            interval = d; // console.log('!!!', unit)\n          }\n        }); // console.log('FOUND', interval)\n        // step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day;\n      }\n\n      step = UNITS[interval] || LONGER_UNITS[interval] || UNITS.day; //domainExtent[0] = new Date(domainExtent)\n      // console.log('original dates', domainExtent.map(d => new Date(d)))\n\n      if (step > LONGER_UNITS.week) {\n        var d0 = new Date(_domainExtent[0]);\n        var d1 = new Date(_domainExtent[1]);\n\n        switch (interval) {\n          case 'month':\n          case 'months':\n            _domainExtent[0] = new Date(d0.getFullYear(), d0.getMonth(), 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), d1.getMonth() + 1, 1);\n            break;\n\n          case 'year':\n          case 'years':\n            _domainExtent[0] = new Date(d0.getFullYear(), 0, 1);\n            _domainExtent[1] = new Date(d1.getFullYear(), 0, 1);\n            break;\n        }\n\n        return _domainExtent;\n      } // console.log('new dates', domainExtent.map(d => new Date(d)))\n      // console.log('DEFINE DOMAIN EXTENTS WITH', interval, step)\n      // console.log('_domainExtent', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n      return [Math.floor(_domainExtent[0] / step) * step, Math.ceil(_domainExtent[1] / step) * step];\n    }\n\n    return [];\n  }; // console.log('domainExtent', domainExtent.map(d => new Date(d)))\n\n\n  var roundedDomainExtent = domainExtent;\n  roundedDomainExtent = calculateTimeDomain();\n  var direction = range[1] >= range[0] ? 1 : -1;\n  var rangeWidth = range[1] - range[0] - (type === 'x' ? this._margins.left + this._margins.right : this._margins.top + this._margins.bottom) * direction;\n  var startCoord = range[0] + (type === 'x' ? this._margins.left : this._margins.bottom) * direction; // console.log('roundedDomainExtent', roundedDomainExtent.map(d => new Date(d)))\n  // const domainWidth = roundedDomainExtent[1] - roundedDomainExtent[0];\n  // const barwidth = rangeWidth / Math.floor(domainWidth / step);\n  // console.log('barwidth', barwidth, 'domainWidth', domainWidth, step, Math.floor(domainWidth/step))\n  // // console.log('new this.scalingFunction', domainExtent, range, rangeWidth)\n\n  var scalingFunction = function scalingFunction(d) {\n    var valueToDomain = (d - roundedDomainExtent[0]) / (roundedDomainExtent[1] - roundedDomainExtent[0]);\n    return startCoord + rangeWidth * valueToDomain;\n  };\n\n  var setTimeInterval = function setTimeInterval(interval) {\n    if (isNull(interval)) {\n      return interval;\n    }\n\n    if (typeof interval === 'number') {\n      console.error('Please use a string for now');\n      return;\n    }\n\n    if (UNITS[interval] || LONGER_UNITS[interval]) {\n      roundedDomainExtent = calculateTimeDomain(interval);\n    } else {\n      console.error('The selected interval does not exists.');\n    }\n  };\n\n  var ticks = function ticks() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TICKS_DEFAULT;\n    var interval = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!domainExtent.length) {\n      return [];\n    }\n\n    var _domainExtent = calculateTimeDomain(interval); // console.log('time domain', _domainExtent, _domainExtent.map(d => new Date(d)))\n\n\n    var _domainWidth = _domainExtent[1] - _domainExtent[0]; // console.log(\"TICKS\", _domainExtent, _domainExtent.map(d => new Date(d)))\n    // console.log('TICKS TIME SCALE', 'ticks', n, interval)\n    // TODO: n can never be null...this needs to be reviews, it doesn't work well, _ticks?!?\n\n\n    if (isNull(n) && isNull(interval) && _ticks.length > 0) {\n      return _ticks;\n    }\n\n    var step = LONGER_UNITS[interval] || UNITS[interval] || UNITS.day;\n    var fixedTicks = Array.isArray(n) && n.length; // console.log('create array of', Math.floor(domainWidth / step), domainWidth, step)\n    // console.log('STEP IS', step, 'FROM', interval, UNITS, LONGER_UNITS)\n\n    if (step <= LONGER_UNITS.fortnight) {\n      _ticks = _toConsumableArray(Array(fixedTicks ? n : Math.floor(_domainWidth / step) + 1).keys()).map(function (d) {\n        return +_domainExtent[0] + d * step;\n      });\n    } else {\n      if (step === LONGER_UNITS.month) {\n        // console.log('OPTIONAL DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var d = _ticks[0];\n\n        var i = _ticks[0].getMonth();\n\n        var startingYear = new Date(_domainExtent[0]).getFullYear();\n\n        while (i < 10000 && +d < +_domainExtent[1]) {\n          d = new Date(startingYear, i, 1);\n\n          _ticks.push(d); // console.log('pushing', d, startingYear)\n\n\n          i++;\n        }\n      } else if (step === LONGER_UNITS.year) {\n        // console.log('YEAR DOMAIN', _domainExtent.map(d => new Date(d)))\n        _ticks = [new Date(_domainExtent[0])];\n        var _d = _ticks[0];\n\n        var _startingYear = _ticks[0].getFullYear();\n\n        var _i = _ticks[0].getFullYear(); // console.log('starting year', i)\n\n\n        while (+_d < +_domainExtent[1] && _i < _startingYear + 10000) {\n          _d = new Date(_i, 0, 1);\n\n          _ticks.push(_d); // console.log('pushing', d,  _ticks[0].getYear())\n\n\n          _i++;\n        } // console.log('_ticks', _ticks)\n\n      }\n    } // console.log('MY TICKS ARE', _ticks, _ticks.map(d => new Date(d)))\n\n\n    return _ticks.map(function (value, index) {\n      return {\n        index: index,\n        value: value,\n        x: scalingFunction(value)\n      };\n    }); // return _ticks;\n  };\n\n  scalingFunction.getName = function () {\n    return name;\n  };\n\n  scalingFunction.getType = function () {\n    return type;\n  };\n\n  scalingFunction.transformation = 'time';\n\n  scalingFunction.getField = function () {\n    return field;\n  };\n\n  scalingFunction.isLog = function () {\n    return false;\n  };\n\n  scalingFunction.fixedDomain = fixedDomain;\n  scalingFunction.interval = setTimeInterval;\n  scalingFunction.domain = domainExtent;\n  scalingFunction.roundedDomainExtent = roundedDomainExtent;\n  scalingFunction.field = field;\n  scalingFunction.range = range;\n  scalingFunction.step = step;\n  scalingFunction.barwidth = scalingFunction(roundedDomainExtent[0] + scalingFunction.step) - scalingFunction(roundedDomainExtent[0]);\n  scalingFunction.ticks = memoize(ticks);\n  this.scales[type][name] = scalingFunction;\n  return this;\n}\n\nfunction Chrt() {\n  var _this = this;\n\n  var _data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var _node = arguments.length > 1 ? arguments[1] : undefined;\n\n  // // console.log('CHRT', _data);\n  this.type = 'chrt';\n  this._data = _data;\n  this._orginalData = this._data;\n  this.root = _node;\n  this.currentNode = _node;\n\n  this._accessor = function (d, i) {\n    return {\n      x: !isNull(d) && Object.prototype.hasOwnProperty.call(d, 'x') ? d.x : i,\n      y: isNull(d) ? null : Object.prototype.hasOwnProperty.call(d, 'y') ? d.y : d\n    };\n  };\n\n  this.width = 500; // default width\n\n  this.height = 300; // default height\n\n  this._margins = {\n    top: 20,\n    bottom: 20,\n    left: 40,\n    right: 20\n  };\n  this._padding = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  };\n  this.scales = {\n    x: {},\n    y: {}\n  };\n  this.objects = [];\n\n  var _scaleLinear = function _scaleLinear(name, type, domain, range, field) {\n    // console.log('----> _scaleLinear name:',name,'type:',type,domain,range,field)\n    // console.log('this.scales', this.scales)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale.apply(_this, [name, type, domain, // || (this._data.length ? domain : null), // [0, 10] -> this messes up with the later assignement of data\n    range, field]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleLog = function _scaleLog(name, type, domain, range, field) {\n    var transformation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'log10';\n    // console.log('scaleLog', name, type, domain, range, 'field:', field, transformation)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$1.apply(_this, [name, type, // (domain || this._data.length) ? domain : [1, 10],\n    domain, range, field, transformation]);\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleOrdinal = function _scaleOrdinal(name, type, domain, range, field) {\n    // console.log('scaleOrdinal', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$2.apply(_this, [name, type, _this._data.length ? domain : [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  var _scaleTime = function _scaleTime(name, type, domain, range, field) {\n    // console.log('scaleTime', name, type, domain, range, 'field:', field)\n    var _scale = _this.scales[type][name];\n    var oldDomain = _scale ? _scale.domain : [];\n    var oldRange = _scale ? _scale.range : [];\n    scale$3.apply(_this, [name, type, domain || [], range, field]); // console.log('----->', this.scales)\n\n    if (!isNull(_scale) && (!arraysEqual(oldDomain, _scale.domain) || !arraysEqual(oldRange, _scale.range))) {\n      _this.objects.forEach(function (obj) {\n        return obj.update();\n      });\n    }\n\n    return _this;\n  };\n\n  this.x = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.x', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'ordinal':\n        //console.log('this.x','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'x', 'x', domain, range || [0, _this.width], options.field || 'x']);\n    }\n  };\n\n  this.y = function (domain, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // console.log('calling this.y', domain, range, options)\n    var transformation = options ? options.scale || 'linear' : 'linear';\n\n    switch (transformation) {\n      case 'log':\n      case 'log10':\n      case 'log2':\n        return _scaleLog(options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y', transformation);\n\n      case 'time':\n        // console.log('this.x','time', domain, options.name,options.field)\n        return _scaleTime.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'ordinal':\n        // console.log('this.y','ordinal', domain, options.name,options.field)\n        return _scaleOrdinal.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n\n      case 'linear':\n      default:\n        return _scaleLinear.apply(_this, [options.name || 'y', 'y', domain, range || [_this.height, 0], options.field || 'y']);\n    }\n  };\n\n  this.update = function () {\n    if (!Object.values(_this.scales.x).length) {\n      // console.log('no scales x -> create a default linear scale')\n      _this.x(null, [0, _this.width]);\n    } else {\n      Object.values(_this.scales.x).forEach(function (scale) {\n        // console.log('scale x exists:', scale.getName(), scale.getType(), scale.transformation)\n        _this.x(scale.fixedDomain, [0, _this.width], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    if (!Object.values(_this.scales.y).length) {\n      _this.y(null, [_this.height, 0]);\n    } else {\n      Object.values(_this.scales.y).forEach(function (scale) {\n        _this.y(scale.fixedDomain, [_this.height, 0], {\n          name: scale.getName(),\n          type: scale.getType(),\n          field: scale.field,\n          scale: scale.transformation\n        });\n      });\n    }\n\n    _this.objects.forEach(function (obj) {\n      obj.update();\n    });\n\n    return _this;\n  };\n\n  this.getAxis = function (name, orientation) {\n    return _this.objects.find(function (obj) {\n      return obj.type === 'axis' && obj.name === name && (!orientation || obj.orientation === orientation);\n    });\n  };\n\n  this[\"class\"] = function (prefix) {\n    if (!isNull(prefix) && typeof prefix !== 'string') {\n      console.warn('CSS prefix should be a string. Setting main class name to \\'chrt\\'.');\n      prefix = null;\n    }\n\n    _this._css = \"\".concat(prefix ? prefix.replace(/-$/, '') : '').concat(prefix ? '-' : '', \"chrt\");\n\n    _this.root.classList.add(_this._css);\n\n    return _this;\n  };\n\n  this.css = this[\"class\"];\n}\n\nfunction chrt(data, node) {\n  return new Chrt(data, node);\n}\n\nChrt.prototype = chrt.prototype = {\n  data: data,\n  node: node,\n  append: append,\n  add: add,\n  rollup: rollup,\n  svg: svg,\n  border: border,\n  size: size,\n  setWidth: function setWidth(width) {\n    return size(width);\n  },\n  setHeight: function setHeight(height) {\n    return size(null, height);\n  },\n  margins: setMargins,\n  padding: setPadding\n};\n\nfunction accessor() {\n  return this._accessor;\n}\n\nfunction render(parent) {\n  // console.log('RENDER', this, parent)\n  this.g = createSVG('g');\n\n  if (this._id) {\n    this.g.setAttribute('id', this._id);\n  } // console.log('RENDER', this, this.parentNode)\n\n\n  if (hasData(this)) {\n    // series\n    // in case of group or stack we want the chart to be added to svg g of the group/stack\n    if (parent) {\n      // if it's a stack we want the order of the charts in the dom to be opposite, so the stroke\n      // of the charts below is not covered by the area above\n      if (parent.type === 'stack' || parent.group === 'group') {\n        parent.g.prepend(this.g);\n      } else {\n        parent.g.append(this.g);\n      }\n    } else {\n      this.currentNode.append(this.g);\n    }\n  } else {\n    //   const grid = (this.parentNode.objects || []).slice().reverse().find(obj => obj.type === 'grid');\n    //   if(grid && this.type === 'axis') {\n    //       // // console.log('THIS IS AN',this.type,'AND THERE IS A GRID',grid,'INSERT BEFORE',grid.node(), grid.node().nextSibling)\n    //       this.currentNode.insertBefore(this.g, grid.node().nextSibling);\n    //   } else {\n    //     // console.log('THIS IS A', this.type, 'PREPEND')\n    //     this.currentNode.append(this.g);\n    //   }\n    this.currentNode.append(this.g);\n  }\n\n  this.update();\n  return this.parentNode;\n}\n\nfunction update() {\n  //if(this.parentNode.scales['x'] && this.parentNode.scales['y']) {\n  if (this.parentNode.scales.x[this.scales.x] && this.parentNode.scales.y[this.scales.y]) {\n    this.draw();\n  }\n}\n\nfunction curve(interpolationFunction) {\n  if (isNull(interpolationFunction)) {\n    return this.interpolationFunction;\n  }\n\n  this.interpolationFunction = interpolationFunction;\n  return this;\n}\n\nfunction add$1(obj) {\n  var prepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var id = obj._id || uuid(); // console.log('adding to', this, obj.type, id, obj);\n\n  obj.id(id).parent(this); // .render();\n\n  if (prepend) {\n    this.objects = [obj].concat(_toConsumableArray(this.objects));\n  } else {\n    this.objects.push(obj);\n  } //return this.update();\n\n\n  return this;\n}\n\nfunction attribute(name, fn) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (value) {\n    return value;\n  };\n\n  if (isNull(name)) {\n    console.warn('name missing: attr method requires a name for the attribute');\n    return this;\n  }\n\n  if (isNull(fn)) {\n    return this.attrs[name];\n  }\n\n  if (typeof fn === 'function') {\n    // something will go here\n    this.attrs[name] = accessor(fn);\n  } else {\n    // fn is a Boolean, String, Number or any other type but function\n    this.attrs[name] = function () {\n      return accessor(fn);\n    };\n  }\n\n  return this;\n}\n\nfunction linearInterpolation(data) {\n  var _this = this;\n\n  return svgPath(data.map(function (d) {\n    return [_this.parentNode.scales.x[_this.scales.x](d[_this.fields.x]), isNull(d[_this.fields.y]) || isInfinity(d[_this.fields.y]) ? null : _this.parentNode.scales.y[_this.scales.y](d[_this.fields.y])];\n  }), lineCommand);\n}\nvar lineCommand = function lineCommand(point) {\n  return \"L\".concat(isNaN(point[0]) ? 0 : point[0], \",\").concat(isNaN(point[1]) ? 0 : point[1]);\n};\n\nfunction chrtGeneric() {\n  var _this = this;\n\n  // console.log('chrtGeneric', this)\n  this._id = null;\n  this.objects = [];\n  this.fields = {\n    x: null,\n    y: null\n  };\n  this.scales = {\n    x: 'x',\n    y: 'y'\n  };\n  this._classNames = [];\n  this.interpolationFunction = linearInterpolation; // list of getter/setter function for custom attributes\n\n  this.attrs = [];\n\n  this.id = function (id) {\n    // console.log('chrtGeneric.id', id, this._id);\n    if (isNull(id)) {\n      return _this._id;\n    }\n\n    _this._id = id || _this._id;\n\n    if (_this.g) {\n      _this.g.setAttribute('id', _this._id);\n    }\n\n    return _this;\n  };\n\n  this[\"class\"] = function (className) {\n    if (isNull(className)) {\n      return _this._classNames;\n    }\n\n    var classNames = className.split(' ');\n    _this._classNames = [].concat(_toConsumableArray(_this._classNames.filter(function (d) {\n      return d !== className;\n    })), _toConsumableArray(classNames));\n\n    if (_this.g) {\n      classNames.forEach(function (d) {\n        return _this.g.classList.add(d);\n      });\n    }\n\n    return _this;\n  };\n\n  this.hasData = function () {\n    return hasData(_this);\n  };\n\n  var setScale = function setScale(scale, scaleName) {\n    if (!isNull(scaleName)) {\n      _this.scales[scale] = scaleName;\n    }\n  };\n\n  this.x = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';\n\n    if (isNull(scale)) {\n      return _this.scales.x;\n    }\n\n    setScale('x', scale);\n    return _this;\n  };\n\n  this.y = function () {\n    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'y';\n\n    if (isNull(scale)) {\n      return _this.scale.y;\n    }\n\n    setScale('y', scale);\n    return _this;\n  };\n\n  return this;\n}\n\nfunction chrt$1() {\n  return new chrtGeneric();\n}\n\nchrtGeneric.prototype = Object.create(chrt$1.prototype); // chrtGeneric.prototype = chrt.prototype = Object.assign(chrt.prototype, {\n\nchrtGeneric.prototype = Object.assign(chrtGeneric.prototype, {\n  node: node,\n  data: data,\n  add: add$1,\n  parent: parent,\n  accessor: accessor,\n  render: render,\n  update: update,\n  curve: curve,\n  attr: attribute\n});\n\nfunction chrtStack() {\n  var _this = this;\n\n  //console.log('chrtStack')\n  chrtGeneric.call(this);\n  this.type = 'stack';\n  this._grouped = 1;\n  this._groupIndex = 0;\n  this._orientation = 'bottom';\n  this._dataMap = {\n    x: {},\n    y: {}\n  };\n\n  this.orientation = function (orientation) {\n    if (isNull(orientation)) {\n      return _this._orientation;\n    }\n\n    var orientations = ['bottom', 'left'];\n    _this._orientation = orientations.indexOf(orientation) > -1 ? orientation : _this._orientation;\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtStack','add',chart, chart._area)\n    chart._stacked = _this;\n    add$1.call(_this, chart); // console.log('add', this.parentNode)\n\n    var dataFunction = chart.data;\n\n    chart.data = function (data, accessor) {\n      // console.log('chrtStack','data!', this._dataMap)\n      if (!isNull(data)) {\n        data = data.map(function (d) {\n          if (!_this._dataMap.x[d.x]) {\n            _this._dataMap.x[d.x] = {\n              x: d.x,\n              values: []\n            };\n          }\n\n          _this._dataMap.x[d.x].values.push(d);\n\n          var y0 = !isNull(_this._dataMap.x[d.x].y0) ? _this._dataMap.x[d.x].y0 : null;\n          _this._dataMap.x[d.x].y0 = _this._orientation !== 'bottom' ? null : (y0 || 0) + d.y;\n\n          if (!_this._dataMap.y[d.y]) {\n            _this._dataMap.y[d.y] = {\n              y: d.y,\n              values: []\n            };\n          }\n\n          _this._dataMap.y[d.y].values.push(d);\n\n          var x0 = !isNull(_this._dataMap.y[d.y].x0) ? _this._dataMap.y[d.y].x0 : null;\n          _this._dataMap.y[d.y].x0 = _this._orientation !== 'left' ? null : (x0 || 0) + d.x;\n          return Object.assign({}, d, {\n            stacked_y: (y0 || 0) + d.y,\n            y0: y0,\n            stacked_x: (x0 || 0) + d.x,\n            x0: x0\n          });\n        });\n      } // console.log('CALLING DATA ON',chart,'WITH', data)\n\n\n      return dataFunction.call(chart, data, accessor);\n    };\n\n    return _this;\n  };\n\n  this.draw = function () {\n    // console.log('chrtStack', 'draw', this.objects);\n    var parentNode = _this.parentNode.type === 'group' ? _this.parentNode.parentNode : _this.parentNode;\n\n    _this.objects.forEach(function (obj) {\n      if (parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return parentNode;\n  };\n}\n\nchrtStack.prototype = Object.create(chrtGeneric.prototype);\nchrtStack.prototype.constructor = chrtStack;\nchrtStack.parent = chrtGeneric.prototype;\nchrtStack.prototype = Object.assign(chrtStack.prototype, {});\nfunction chrtStack$1 () {\n  return new chrtStack();\n}\n\nfunction chrtGroup() {\n  var _this = this;\n\n  //console.log('chrtGroup')\n  chrtGeneric.call(this);\n  this.type = 'group';\n  this.attr('width', 1);\n\n  this.width = function (width) {\n    if (isNull(width)) {\n      return _this.attr('width')();\n    }\n\n    _this.attr('width', Math.min(Math.max(width, 0), 1));\n\n    return _this;\n  };\n\n  this.add = function (chart) {\n    // console.log('chrtGroup','add',chart)\n    add$1.call(_this, chart);\n    chart._groupIndex = _this.objects.length - 1;\n\n    _this.objects.forEach(function (obj) {\n      obj._group = _this;\n      obj._grouped = _this.objects.length;\n    });\n\n    return _this;\n  };\n\n  this.draw = function () {\n    _this.objects.forEach(function (obj) {\n      if (_this.parentNode.objects.map(function (d) {\n        return d._id;\n      }).indexOf(obj._id) === -1) {\n        _this.parentNode.add(obj);\n      } // console.log('--->', obj)\n\n    });\n\n    _this.objects.forEach(function (obj) {\n      return obj.draw();\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtGroup.prototype = Object.create(chrtGeneric.prototype);\nchrtGroup.prototype.constructor = chrtGroup;\nchrtGroup.parent = chrtGeneric.prototype;\nchrtGroup.prototype = Object.assign(chrtGroup.prototype, {});\nfunction chrtGroup$1 () {\n  return new chrtGroup();\n}\n\nexport default chrt;\nexport { chrt as Chrt, chrtGeneric, chrtGroup$1 as chrtGroup, chrtStack$1 as chrtStack };\n","// chrt-markers v0.0.11 Copyright 2020-2021 chrt chrt.io\nimport { chrtGeneric } from 'chrt-core';\n\nfunction size(value) {\n  if (!value) {\n    return this._radius * 2;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._radius = value / 2;\n  }\n\n  return this;\n}\n\nfunction fill(value) {\n  if (!value) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction stroke(value) {\n  if (!value) {\n    return this._stroke;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._stroke = value;\n  }\n\n  return this;\n}\n\nfunction strokeWidth(value) {\n  if (!value) {\n    return this._strokeWidth;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._strokeWidth = value;\n  }\n\n  return this;\n}\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction showMarkers(filter) {\n  // default true\n  if (isNull(filter)) {\n    this.markersFilter = function () {\n      return true;\n    };\n\n    return this;\n  } // filter-in with a function\n  // showMarkers((d,i) => !(i % 2))\n\n\n  if (typeof filter === 'function') {\n    this.markersFilter = function (d, i, arr) {\n      return filter(d, i, arr);\n    };\n\n    return this;\n  } // show/hide all markers\n  // showMarkers(false|true)\n\n\n  if (typeof filter === 'boolean') {\n    this.markersFilter = function () {\n      return filter;\n    };\n\n    return this;\n  } // show only one marker\n  // showMarkers(10)\n\n\n  if (Number.isFinite(filter)) {\n    this.markersFilter = function (d) {\n      return filter === d;\n    };\n\n    return this;\n  } // show based on an array of values\n  // showMarkers([10, 20, 30])\n\n\n  if (Array.isArray(filter)) {\n    this.markersFilter = function (d) {\n      return filter.indexOf(d) > -1;\n    };\n\n    return this;\n  }\n\n  return this;\n}\nfunction hideMarkers(filter) {\n  showMarkers.call(this, filter);\n  var markersFilter = this.markersFilter;\n\n  this.markersFilter = function (d, i, arr) {\n    return !markersFilter(d, i, arr);\n  };\n\n  return this;\n}\nfunction firstMarker() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  // // console.log('FIRST TICK', this, show)\n  if (show) {\n    showMarkers.call(this, function (d, i) {\n      return i === 0;\n    });\n  } else {\n    hideMarkers.call(this, function (d, i) {\n      return i === 0;\n    });\n  }\n\n  return this;\n}\nfunction lastMarker() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showMarkers.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  } else {\n    hideMarkers.call(this, function (d, i, arr) {\n      return i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\nfunction firstAndLastMarkers() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  if (show) {\n    showMarkers.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  } else {\n    hideMarkers.call(this, function (d, i, arr) {\n      return i === 0 || i === arr.length - 1;\n    });\n  }\n\n  return this;\n}\n\nfunction createSVG(tag) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n\nvar DEFAULT_RADIUS = 2;\nvar DEFAULT_FILL_COLOR = '#000';\nvar DEFAULT_STROKE = '#000';\nvar DEFAULT_STROKE_OPACITY = 1;\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_FILL_OPACITY = 1;\n\nfunction chrtMarkers() {\n  var _this = this;\n\n  chrtGeneric.call(this); // console.log('HI WE ARE MARKERS', this);\n\n  this.type = 'markers';\n  this.markers = [];\n  this.g = null;\n\n  this.markersFilter = function () {\n    return true;\n  };\n\n  this.draw = function () {\n    // console.log('DRAW MARKERS', this.parentNode.data(), this.parentNode.parentNode._data);\n    // console.log(this)\n    var parentData = _this.parentNode.data(); // this might be broken when only local data to the component is updated - to be tested\n\n\n    var data = parentData.length ? parentData : _this.parentNode.parentNode._data || [];\n    var radius = _this._radius || DEFAULT_RADIUS;\n    var fill = _this._fill || _this.parentNode.stroke || DEFAULT_FILL_COLOR;\n    var opacity = _this._opacity || _this.parentNode.strokeOpacity || DEFAULT_FILL_OPACITY;\n    var stroke = _this._stroke || _this.parentNode.stroke || DEFAULT_STROKE;\n    var strokeOpacity = _this._strokeOpacity || _this.parentNode.strokeOpacity || DEFAULT_STROKE_OPACITY;\n    var strokeWidth = _this._strokeWidth || _this.parentNode.strokeWidth || DEFAULT_STROKE_WIDTH;\n\n    if (!_this.g) {\n      _this.g = createSVG('g');\n\n      _this.parentNode.g.appendChild(_this.g);\n    }\n\n    data.forEach(function (marker, i) {\n      if (_this.markers[i]) {\n        // if the marker exists, just update its data\n        _this.markers[i].marker = marker;\n      } else {\n        // if the marker does not exists, create a new one\n        var circle = createSVG('circle');\n\n        _this.markers.push({\n          circle: circle,\n          marker: marker\n        });\n\n        _this.g.appendChild(circle);\n      }\n    });\n\n    _this.markers.filter(function (marker, i, arr) {\n      return _this.markersFilter(marker.marker, i, arr);\n    }).forEach(function (d) {\n      var cx = _this.parentNode.parentNode.scales.x[_this.parentNode.scales.x](d.marker[_this.parentNode.fields.x]);\n\n      d.circle.setAttribute('cx', isNaN(cx) ? 0 : cx);\n\n      var cy = _this.parentNode.parentNode.scales.y[_this.parentNode.scales.y](d.marker[_this.parentNode.fields.y]);\n\n      d.circle.setAttribute('cy', isNaN(cy) ? 0 : cy);\n      d.circle.setAttribute('fill', fill);\n      d.circle.setAttribute('fill-opacity', opacity);\n      d.circle.setAttribute('r', radius);\n      d.circle.setAttribute('stroke', stroke);\n      d.circle.setAttribute('stroke-width', strokeWidth);\n      d.circle.setAttribute('stroke-opacity', strokeOpacity);\n    });\n\n    return _this.parentNode;\n  };\n}\n\nchrtMarkers.prototype = Object.create(chrtGeneric.prototype);\nchrtMarkers.prototype.constructor = chrtMarkers;\nchrtMarkers.parent = chrtGeneric.prototype;\nchrtMarkers.prototype = Object.assign(chrtMarkers.prototype, {\n  fill: fill,\n  size: size,\n  stroke: stroke,\n  strokeWidth: strokeWidth,\n  showMarkers: showMarkers,\n  hideMarkers: hideMarkers,\n  firstMarker: firstMarker,\n  lastMarker: lastMarker,\n  firstAndLastMarkers: firstAndLastMarkers\n}); // export default chrtMarkers;\n\nfunction chrtMarkers$1 () {\n  return new chrtMarkers();\n}\n\nexport { chrtMarkers$1 as chrtMarkers };\n","// chrt.io v0.0.11 Copyright 2021 chrt\nimport { chrtGeneric } from 'chrt-core';\n\nfunction isNull(value) {\n  return value === null || value == null || typeof value === 'undefined';\n}\n\nfunction color(value) {\n  if (!value) {\n    return this._fill;\n  }\n\n  if (typeof value === 'function') ; else {\n    this._fill = value;\n  }\n\n  return this;\n}\n\nfunction position(coords) {\n  if (isNull(coords)) {\n    return this;\n  } // console.log('position', coords)\n\n\n  if (typeof coords === 'function') ; else {\n    this._position = Object.assign({}, this._position, coords);\n  }\n\n  return this;\n}\nfunction top(y) {\n  return position.call(this, {\n    y: y\n  });\n}\nfunction left(x) {\n  return position.call(this, {\n    x: x\n  });\n}\n\nfunction alignment(align) {\n  if (isNull(align)) {\n    return this;\n  }\n\n  console.log('alignment', align);\n\n  if (typeof coords === 'function') ; else {\n    this._alignment = Object.assign({}, this._alignment, align);\n  }\n\n  return this;\n}\nfunction valign(position) {\n  var vertical = this._alignment.vertical;\n\n  switch (position) {\n    case 'top':\n      vertical = '-0.7em';\n      break;\n\n    case 'bottom':\n      vertical = '1em';\n      break;\n\n    default:\n      vertical = '0.25em';\n  }\n\n  return alignment.call(this, {\n    vertical: vertical\n  });\n}\nfunction align(position) {\n  var horizontal = this._alignment.horizontal;\n\n  switch (position) {\n    case 'right':\n      horizontal = 'end';\n      break;\n\n    case 'center':\n      horizontal = 'middle';\n      break;\n\n    default:\n      horizontal = 'start';\n  }\n\n  return alignment.call(this, {\n    horizontal: horizontal\n  });\n}\n\nfunction offset() {\n  for (var _len = arguments.length, offsets = new Array(_len), _key = 0; _key < _len; _key++) {\n    offsets[_key] = arguments[_key];\n  }\n\n  if (isNull(offsets)) {\n    return this._offsets;\n  }\n\n  var top = offsets[0],\n      left = offsets[1];\n  this._offsets[0] = !isNull(top) ? top : this._offsets[0];\n  this._offsets[1] = !isNull(left) ? left : this._offsets[1];\n  return this;\n}\n\nfunction create(tag) {\n  return document.createElement(tag);\n}\n\nfunction chrtAnnotation(text) {\n  var _this = this;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    x: 'x',\n    y: 'y'\n  };\n  chrtGeneric.call(this);\n  this.type = 'annnotation';\n  this.div = null;\n  this.text = text;\n  this._fill = null;\n  this._position = {};\n  this._alignment = {\n    horizontal: 'start',\n    vertical: '0.25em'\n  };\n  this._offsets = [0, 0];\n  this._classNames = ['chrt-annotation']; // console.log('chrtAnnotation', options)\n\n  this.draw = function () {\n    if (!_this.parentNode.scales) {\n      return _this.parentNode;\n    } // TODO: probably should be the last one\n\n\n    var scales = {\n      x: _this.parentNode.scales.x[options.x] || Object.values(_this.parentNode.scales.x)[0],\n      y: _this.parentNode.scales.y[options.y] || Object.values(_this.parentNode.scales.y)[0]\n    }; // console.log('options', options)\n    // console.log('scales', scales)\n\n    if (!_this.div) {\n      _this.div = create('div');\n\n      _this.parentNode.root.appendChild(_this.div);\n\n      _this.div.style.position = 'absolute';\n    }\n\n    _this.div.setAttribute('id', _this.id());\n\n    _this._classNames.forEach(function (d) {\n      return _this.div.classList.add(d);\n    });\n\n    if (scales && scales['x']) {\n      var x = isNull(_this._position.x) ? 0 : scales.x(_this._position.x); // if y is not defined by the user, it should be calculated based on the closest Y value based on X\n\n      var y = isNull(_this._position.y) ? 0 : scales.y(_this._position.y);\n      _this.div.style.left = \"\".concat(x + _this._offsets[0], \"px\");\n      _this.div.style.top = \"\".concat(y + _this._offsets[1], \"px\");\n    }\n\n    var label = _this.div.querySelector('span');\n\n    if (!label) {\n      label = create('span');\n\n      _this.div.appendChild(label);\n    }\n\n    label.innerHTML = text;\n  };\n}\n\nchrtAnnotation.prototype = Object.create(chrtGeneric.prototype);\nchrtAnnotation.prototype.constructor = chrtAnnotation;\nchrtAnnotation.parent = chrtGeneric.prototype;\nchrtAnnotation.prototype = Object.assign(chrtAnnotation.prototype, {\n  color: color,\n  position: position,\n  top: top,\n  left: left,\n  align: align,\n  valign: valign,\n  offset: offset\n}); // export default chrtAnnotation;\n\nfunction chrtAnnotation$1 (text, options) {\n  return new chrtAnnotation(text, options);\n}\n\nexport { chrtAnnotation$1 as chrtAnnotation };\n","<script>\n  import { onMount } from \"svelte\";\n  \n  import * as chrt from \"chrt\";\n  import {yAxis, xAxis, yAxisRange} from 'chrt-axis';\n  import { chrtAnnotation } from \"chrt-annotation\";\n  \n  export let data;\n  export let id;\n  export let label;\n  // export let title;\n  export let charts;\n  export let position;\n\n  const W = 750;\n  const H = 150;\n  const MONTHS = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'];\n\n  let el;\n\n  const chart = chrt.Chrt();\n\n  const labelFormat = (d) => `${d === 0 ? 'Week' : 'W.'} ${new Date(data[id][d].startDay).getMonth() + 1}/${new Date(data[id][d].startDay).getDate()}`;\n\n  onMount(() => {\n    const max = Math.max(... data[id].map(d => d.value));\n    const maxObj = data[id].find(d => d.value === max);\n    const maxIndex = data[id].findIndex(d => d.value === max);\n    const min = Math.min(... data[id].map(d => d.value));\n    const minObj = data[id].find(d => d.value === min);\n    const minIndex = data[id].findIndex(d => d.value === min);\n    \n    // console.log('CHART', id, data[id], max, maxObj);\n\n    chart\n      .node(el)\n      .svg()\n      .size(W, H)\n      .margins({\n        bottom: 30,\n        left: 0,\n        right: 0,\n      })\n      .padding({\n        left: 30,\n        right: 30,\n        top: 30,\n      })\n      .x(null, null)\n      .y([Math.min(0, ...data[id].map(d => d.value)), null]);\n\n    chart.add(\n      chrt\n        .chrtColumns()\n        .fill(d => ((d.value === max) ? 'url(#stripes2)' : ((d.value === min) ? 'url(#stripes3)' : 'url(#stripes)')))\n        .color(d => ((d.value === max) ? '#444' : '#444'))\n        .strokeWidth(1)\n        .width(.6)\n        .data(data[id], (d, i) => ({\n          x: i, //new Date(d.startDay),\n          y: d.value,\n          startDay: new Date(d.startDay),\n          endDay: new Date(d.endDay),\n        }))\n    );\n    if (position == 0) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('top')\n          .setTickPosition(\"outside\")\n          .setLabelPosition('outside')\n          .class('axis-label')\n          .format((d) => labelFormat(d))\n          .color('#444')\n          .width(1)\n      ).add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .hideTicks()\n          .hideLabels()\n          .color('#444')\n          .width(1)\n      );\n    }\n    if (position < charts - 1 && position > 0) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .hideTicks()\n          .hideLabels()\n          .color('#444')\n          .width(1)\n      )\n    } \n    if (position == charts - 1) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .setTickPosition(\"outside\")\n          .setLabelPosition('outside')\n          .class('axis-label')\n          .format((d) => labelFormat(d))\n          .color('#444')\n          .width(1)\n      );\n    }\n\n    chart.add(\n      yAxis()\n        .hideAxis()\n        .hideLabels()\n        .hideTicks()\n        .add(yAxisRange()\n          .dashed()\n          .stroke('#444')\n          .strokeWidth(1)\n          .from(max)\n        )\n        // ).add(\n        //   chrt.chrtAxisTitle(title)\n        //   .class('title')\n        //   .offset({ x:5, y:-5 })\n        //   .align('right')\n        // )\n    );\n\n    chart.add(\n      chrtAnnotation(`<div>${label}: ${new Intl.NumberFormat('en-EN').format(maxObj.value)}</div>`)\n      .top(max)\n      .left(maxIndex)\n    );\n\n    chart.add(\n      chrtAnnotation(`<div>${new Intl.NumberFormat('en-EN').format(data[id][data[id].length -1].value)}</div>`)\n      .top(data[id][data[id].length -1].value)\n      .left(data[id].length -1)\n      .class('thisWeek')\n    );\n  });\n</script>\n\n<div class=\"chart\" id=\"{id}\" bind:this={el}>\n  <div class=\"axis-label\"><g><text /></g></div>\n</div>\n\n<style>\n  .chart {\n    display: block;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n  }\n</style>\n","<script>\n  import { onMount } from \"svelte\";\n  \n  import * as chrt from \"chrt\";\n  import {yAxis, xAxis, yAxisRange, xAxisRange} from 'chrt-axis';\n  import { chrtAnnotation } from \"chrt-annotation\";\n  \n  export let data2020;\n  export let data2021;\n  export let id;\n  export let label;\n  export let charts;\n  export let position;\n\n  const W = 950;\n  const H = position === 0 ? 250 : (position === 4 ? 180 : 150);\n  const labelFormat = (d) => ((d > 0 && d <= 50) ? `Week ${d}` : null);\n\n  \n  let el;\n  const chart = chrt.Chrt();\n\n  onMount(() => {\n    const max = Math.max(... data2020[id].map(d => d.value), ... data2021[id].map(d => d.value));\n    const maxObj = data2020[id].find(d => d.value === max) || data2021[id].find(d => d.value === max);\n    const maxIndex = data2020[id].findIndex(d => d.value === max) || data2021[id].findIndex(d => d.value === max);\n    const min = Math.min(... data2020[id].map(d => d.value), ... data2021[id].map(d => d.value));\n    const minObj = data2020[id].find(d => d.value === min) || data2021[id].find(d => d.value === min);\n    const minIndex = data2020[id].findIndex(d => d.value === min) || data2021[id].findIndex(d => d.value === min);\n    \n    chart\n      .node(el)\n      .svg()\n      .size(W, H)\n      .margins({\n        bottom: (position === 4) ? 30 : 0,\n        left: 0,\n        right: 0,\n        top: (position === 0) ? 30 : 0,\n      })\n      .padding({\n        left: 10,\n        right: 10,\n        top: (position === 0) ? 60 : 40,\n      })\n      .x([1, 53])\n      .y([Math.min(0, ...data2020[id].map(d => d.value), ...data2021[id].map(d => d.value)), null]);\n\n    chart.add(\n      chrt\n        .chrtLine()\n        .area()\n        .fill('url(#dots)')\n        .color('#9a9a9a')\n        .width(1)\n        .data(data2020[id], (d, i) => ({\n          x: d.week,\n          y: d.value,\n        }))\n    );\n\n\n    chart.add(\n      chrt\n        .chrtLine()\n        .fill('transparent')\n        .color('#444')\n        .width(2)\n        .data(data2021[id], (d, i) => ({\n          x: d.week,\n          y: d.value,\n        }))\n    );\n    if (position == 0) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('top')\n          .setTickPosition(\"outside\")\n          .setLabelPosition('outside')\n          .class('axis-label')\n          .format((d) => labelFormat(d))\n          .color('#444')\n          .width(1)\n      ).add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .hideTicks()\n          .hideLabels()\n          .color('#444')\n          .width(1)\n      );\n    }\n    if (position < charts - 1 && position > 0) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .hideTicks()\n          .hideLabels()\n          .color('#444')\n          .width(1)\n      )\n    } \n    if (position == charts - 1) {\n      chart.add(\n        xAxis()\n          .zero(0)\n          .orient('bottom')\n          .setTickPosition(\"outside\")\n          .setLabelPosition('outside')\n          .class('axis-label')\n          .format((d) => labelFormat(d))\n          .color('#444')\n          .width(1)\n      );\n    }\n\n    chart.add(\n      yAxis()\n        .hideAxis()\n        .hideLabels()\n        .hideTicks()\n        .add(yAxisRange()\n          .dashed()\n          .stroke('#444')\n          .strokeWidth(1)\n          .from(max)\n        )\n    );\n\n    chart.add(\n      xAxis()\n        .hideAxis()\n        .hideLabels()\n        .hideTicks()\n        .add(xAxisRange()\n          .dashed()\n          .stroke('#9a9a9a')\n          .strokeWidth(1)\n          .from(21)\n        )\n        .add(xAxisRange()\n          .dashed()\n          .stroke('#9a9a9a')\n          .strokeWidth(1)\n          .from(9)\n        )\n        .add(xAxisRange()\n          .dashed()\n          .stroke('#9a9a9a')\n          .strokeWidth(1)\n          .from(45)\n        )\n        .add(xAxisRange()\n          .dashed()\n          .stroke('#9a9a9a')\n          .strokeWidth(1)\n          .from(53)\n        )\n    );\n\n    chart.add(\n      chrtAnnotation(`<div>${label}:<br />${new Intl.NumberFormat('en-EN').format(maxObj.value)} Week of ${new Date(maxObj.datetime).getMonth() + 1}/${new Date(maxObj.datetime).getDate()}/${new Date(maxObj.datetime).getFullYear()}</div>`)\n      .top(max)\n      .left(maxObj.week)\n      .class('marker')\n      .class(position === 1 ? 'reverse' : 'normal')\n    );\n\n    if (position === 0) {\n      chart.add(\n        chrtAnnotation(`<div>Week of 5/18/2020:<br />End of Lockdown</div>`)\n        .top(max / 2)\n        .left(21)\n        .class('milestone')\n      );\n      chart.add(\n        chrtAnnotation(`<div>Week of 2/24/2020:<br />First Official<br />Covid Case in Italy</div>`)\n        .top(1)\n        .left(9)\n        .class('milestone-3')\n      );\n      chart.add(\n        chrtAnnotation(`<div>Week of 11/2/2020:<br />Lockdowns are now<br />Region-Based</div>`)\n        .top(max / 2)\n        .left(45)\n        .class('milestone-2')\n      );\n      chart.add(\n        chrtAnnotation(`<div>Week of 12/25/2020:<br />Vaccination Campaign begins</div>`)\n        .top(max / 2)\n        .left(53)\n        .class('milestone-2')\n      );\n    }\n    \n    chart.add(\n      chrtAnnotation(`<div>2021</div>`)\n      .top(data2021[id][0].value)\n      .left(data2021[id][0].week)\n      .class('title')\n      .class('title2021')\n    );\n    \n    chart.add(\n      chrtAnnotation(`<div>2020</div>`)\n      .top(data2020[id][0].value)\n      .left(data2020[id][0].week)\n      .class('title')\n      .class('title2020')\n    );\n\n    // chart.add(\n    //   chrtAnnotation(`<div>${new Intl.NumberFormat('en-EN').format(data[id][data[id].length -1].value)}</div>`)\n    //   .top(data[id][data[id].length -1].value)\n    //   .left(data[id].length -1)\n    //   .class('thisWeek')\n    // );\n  });\n</script>\n\n<div class=\"chart chart-{id}\" id=\"{id}\" bind:this={el}>\n  <div class=\"axis-label\"><g><text /></g></div>\n</div>\n\n<style>\n  .chart {\n    display: block;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n  }\n</style>\n","<script>\n\timport { onMount } from 'svelte';\n\timport axios from 'axios';\n\n\timport Chart from './Chart.svelte';\n\timport Line from './Line.svelte';\n\n\tconst DATA_SOURCE = 'https://corona.elezioni.io/data';\n\tconst START_DATE = '2020-12-25'; // First Friday of the year\n\tconst CHARTS = [\n\t\t{\n\t\t\tid: 'cases',\n\t\t\tlabel: 'Highest Number of<br /><span>New Cases</span>',\n\t\t\tlabel2: 'Highest Number<br />of <span>New Cases</span>',\n\t\t\ttitle: 'New Cases',\n\t\t},\n\t\t{\n\t\t\tid: 'hospitals',\n\t\t\tlabel: 'Highest Increment of<br /><span>Hospital Bed occupancy</span>',\n\t\t\tlabel2: 'Highest Number of Weekly<br />Average <span>Hospital Bed occupancy</span>',\n\t\t\ttitle: 'Hospital Bed occupancy',\n\t\t},\n\t\t{\n\t\t\tid: 'icus',\n\t\t\tlabel: 'Highest Increment of<br /><span>ICU Beds occupancy</span>',\n\t\t\tlabel2: 'Highest Number<br />of Weekly Average <span>ICU Beds occupancy</span>',\n\t\t\ttitle: 'ICU Bed occupancy',\n\t\t},\n\t\t{\n\t\t\tid: 'fatalities',\n\t\t\tlabel: 'Highest Number of<br /><span>Fatalities</span>',\n\t\t\tlabel2: 'Highest Number of <span>Fatalities</span>',\n\t\t\ttitle: 'Fatalities',\n\t\t},\n\t\t{\n\t\t\tid: 'tests',\n\t\t\tlabel: 'Highest Number of<br /><span>Tests Performed</span>',\n\t\t\tlabel2: 'Highest Number of <span>Tests Performed</span>',\n\t\t\ttitle: 'Tests',\n\t\t},\n\t];\n\n\tDate.prototype.getWeek = function (dowOffset) {\n\t\t/*getWeek() was developed by Nick Baicoianu at MeanFreePath: http://www.meanfreepath.com */\n\n\t\tdowOffset = typeof(dowOffset) == 'int' ? dowOffset : 0; //default dowOffset to zero\n\t\tlet newYear = new Date(this.getFullYear(),0,1);\n\t\tlet day = newYear.getDay() - dowOffset; //the day of week the year begins on\n\t\tday = (day >= 0 ? day : day + 7);\n\t\tlet daynum = Math.floor((this.getTime() - newYear.getTime() - \n\t\t(this.getTimezoneOffset()-newYear.getTimezoneOffset())*60000)/86400000) + 1;\n\t\tlet weeknum;\n\t\t//if the year starts before the middle of a week\n\t\tif(day < 4) {\n\t\t\t\tweeknum = Math.floor((daynum+day-1)/7) + 1;\n\t\t\t\tif(weeknum > 52) {\n\t\t\t\t\tlet nYear = new Date(this.getFullYear() + 1,0,1);\n\t\t\t\t\tlet nday = nYear.getDay() - dowOffset;\n\t\t\t\t\tnday = nday >= 0 ? nday : nday + 7;\n\t\t\t\t\t/*if the next year starts before the middle of\n\t\t\t\t\t\tthe week, it is week #1 of that year*/\n\t\t\t\t\tweeknum = nday < 4 ? 1 : 53;\n\t\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\tweeknum = Math.floor((daynum+day-1)/7);\n\t\t}\n\t\treturn weeknum;\n\t};\n\t\n\tlet data;\n\tlet data2020 = {\n\t\tcases: [],\n\t\tfatalities: [],\n\t\ttests: [],\n\t\ticus: [],\n\t\thospitals: [],\n\t};\n\tlet data2021 = {\n\t\tcases: [],\n\t\tfatalities: [],\n\t\ttests: [],\n\t\ticus: [],\n\t\thospitals: [],\n\t};\n\n\tonMount(async () => {\n\t\tconst rawData = {\n\t\t\tepicenters: [],\n\t\t\tgenerated: '',\n\t\t\titaly: {\n\t\t\t\tglobal: [],\n\t\t\t\tprovinces: [],\n\t\t\t\tregions: [],\n\t\t\t},\n\t\t\ttested: [],\n\t\t};\n\n\t\tconst italy = {\n\t\t\tcases: [],\n\t\t\tfatalities: [],\n\t\t\ttests: [],\n\t\t\ticus: [],\n\t\t\thospitals: [],\n\t\t};\n\n\t\tconst fetchData = async () => {\n\t\t\tconst getItalia = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/italia`);\n\t\t\t}\n\n\t\t\tconst getRegioni = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/regioni`);\n\t\t\t}\n\n\t\t\tconst getRegioni2020 = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/regioni2020`);\n\t\t\t}\n\n\t\t\tconst getProvince = () => {\n\t\t\t\t\treturn axios.get(`${DATA_SOURCE}/province`);\n\t\t\t}\n\n      Promise.all([getItalia(), getRegioni(), getProvince(), getRegioni2020()]).then((results) => {\n\t\t\t\tif (!results[0].data.error) {\n\t\t\t\t\t\trawData.italy.global = results[0].data.data.italy.global;\n\t\t\t\t\t\trawData.tested = results[0].data.data.tested;\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\t\t\t\tif (!results[1].data.error) {\n\t\t\t\t\t\trawData.italy.regions = results[1].data.data.italy.regions;\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\t\t\t\tif (!results[2].data.error) {\n\t\t\t\t\t\trawData.italy.provinces = results[2].data.data.italy.provinces;\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\t\t\t\tif (!results[3].data.error) {\n\t\t\t\t\t\trawData.italy.regions = rawData.italy.regions.concat(results[3].data.data.italy.regions).sort((a,b) => a.datetime > b.datetime ? 1 : -1);\n\t\t\t\t\t\trawData.generated = results[0].data.data.generated;\n\t\t\t\t}\n\n\t\t\t\tconst italy_filtered = rawData.italy.global.filter(d => d.datetime >= START_DATE);\n\t\t\t\tlet tmpCases = {};\n\t\t\t\tlet tmpFatalities = {};\n\t\t\t\tlet tmpIcus = {};\n\t\t\t\tlet tmpHospitals = {};\n\t\t\t\tlet tmpTests = {};\n\n\t\t\t\t// console.log('italy_filtered', italy_filtered);\n\n\t\t\t\titaly_filtered.forEach((d, i) => {\n\t\t\t\t\tconst startDay = new Date(d.datetime);\n\t\t\t\t\tconst thisDay = startDay.getDay();\n\t\t\t\t\tif (thisDay === 5) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\titaly.cases.push(tmpCases);\n\t\t\t\t\t\t\titaly.fatalities.push(tmpFatalities);\n\t\t\t\t\t\t\titaly.icus.push(tmpIcus);\n\t\t\t\t\t\t\titaly.hospitals.push(tmpHospitals);\n\t\t\t\t\t\t\titaly.tests.push(tmpTests);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst endDay = new Date(d.datetime);\n\t\t\t\t\t\tendDay.setDate(endDay.getDate() + 6);\n\t\t\t\t\t\ttmpCases = {\n\t\t\t\t\t\t\tavg: d.new_tested_positive,\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: d.new_tested_positive,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpFatalities = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.deaths : d.deaths - (italy_filtered[i -1].deaths),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.deaths : d.deaths - (italy_filtered[i -1].deaths),\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpIcus = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.icu : d.icu - (italy_filtered[i -1].icu),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.icu : d.icu - (italy_filtered[i -1].icu),\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpHospitals = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.hospital : d.hospital - (italy_filtered[i -1].hospital),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.hospital : d.hospital - (italy_filtered[i -1].hospital),\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpTests = {\n\t\t\t\t\t\t\tavg: (i === 0) ? d.tested : d.tested - (italy_filtered[i -1].tested),\n\t\t\t\t\t\t\tendDay,\n\t\t\t\t\t\t\tstartDay,\n\t\t\t\t\t\t\tvalue: (i === 0) ? d.tested : d.tested - (italy_filtered[i -1].tested),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmpCases.avg = (tmpCases.avg + d.new_tested_positive) / 7;\n\t\t\t\t\t\ttmpCases.value = tmpCases.value + d.new_tested_positive;\n\t\t\t\t\t\ttmpFatalities.avg = (tmpFatalities.avg + d.deaths - (italy_filtered[i -1].deaths)) / 7;\n\t\t\t\t\t\ttmpFatalities.value = tmpFatalities.value + d.deaths - (italy_filtered[i -1].deaths);\n\t\t\t\t\t\ttmpIcus.avg = (tmpIcus.avg + d.icu - (italy_filtered[i -1].icu)) / 7;\n\t\t\t\t\t\ttmpIcus.value = tmpIcus.value + d.icu - (italy_filtered[i -1].icu);\n\t\t\t\t\t\ttmpHospitals.avg = (tmpHospitals.avg + d.hospital - (italy_filtered[i -1].hospital)) / 7;\n\t\t\t\t\t\ttmpHospitals.value = tmpHospitals.value + d.hospital - (italy_filtered[i -1].hospital);\n\t\t\t\t\t\ttmpTests.avg = (tmpTests.avg + d.tested - (italy_filtered[i -1].tested)) / 7;\n\t\t\t\t\t\ttmpTests.value = tmpTests.value + d.tested - (italy_filtered[i -1].tested);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// console.log('italy', italy);\n\n\t\t\t\titaly.cases.shift();\n\t\t\t\titaly.hospitals.shift();\n\t\t\t\titaly.icus.shift();\n\t\t\t\titaly.fatalities.shift();\n\t\t\t\titaly.tests.shift();\n\t\t\t\tdata = JSON.parse(JSON.stringify(italy));\n\t\t\t\tlet week = -10;\n\t\t\t\tlet refYear = 0;\n\n\t\t\t\ttmpCases = {};\n\t\t\t\ttmpFatalities = {};\n\t\t\t\ttmpIcus = {};\n\t\t\t\ttmpHospitals = {};\n\t\t\t\ttmpTests = {};\n\t\t\t\tlet numberOfDays = 0;\n\n\t\t\t\trawData.italy.global.forEach((d, i) => {\n\t\t\t\t\tconst currentDay = new Date(d.datetime);\n\t\t\t\t\tconst year = currentDay.getFullYear();\n\t\t\t\t\tconst thisWeek = currentDay.getWeek();\n\t\t\t\t\tif (week !== thisWeek || year !== refYear) {\n\t\t\t\t\t\tif (week > 0) {\n\t\t\t\t\t\t\tif (refYear === 2020) {\n\t\t\t\t\t\t\t\tdata2020.cases.push(tmpCases);\n\t\t\t\t\t\t\t\tdata2020.fatalities.push(tmpFatalities);\n\t\t\t\t\t\t\t\tdata2020.hospitals.push((() => {\n\t\t\t\t\t\t\t\t\ttmpHospitals.value = tmpHospitals.value > 0 ? Math.floor(tmpHospitals.value / numberOfDays) : 0;\n\t\t\t\t\t\t\t\t\treturn tmpHospitals;\n\t\t\t\t\t\t\t\t})());\n\t\t\t\t\t\t\t\tdata2020.icus.push((() => {\n\t\t\t\t\t\t\t\t\ttmpIcus.value = tmpIcus.value > 0 ? Math.floor(tmpIcus.value / numberOfDays) : 0;\n\t\t\t\t\t\t\t\t\treturn tmpIcus;\n\t\t\t\t\t\t\t\t})());\n\t\t\t\t\t\t\t\tdata2020.tests.push(tmpTests);\n\t\t\t\t\t\t\t} else if (refYear === 2021) {\n\t\t\t\t\t\t\t\tdata2021.cases.push(tmpCases);\n\t\t\t\t\t\t\t\tdata2021.fatalities.push(tmpFatalities);\n\t\t\t\t\t\t\t\tdata2021.hospitals.push((() => {\n\t\t\t\t\t\t\t\t\ttmpHospitals.value = tmpHospitals.value > 0 ? Math.floor(tmpHospitals.value / numberOfDays) : 0;\n\t\t\t\t\t\t\t\t\treturn tmpHospitals;\n\t\t\t\t\t\t\t\t})());\n\t\t\t\t\t\t\t\tdata2021.icus.push((() => {\n\t\t\t\t\t\t\t\t\ttmpIcus.value = tmpIcus.value > 0 ? Math.floor(tmpIcus.value / numberOfDays) : 0;\n\t\t\t\t\t\t\t\t\treturn tmpIcus;\n\t\t\t\t\t\t\t\t})());\n\t\t\t\t\t\t\t\tdata2021.tests.push(tmpTests);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trefYear = year;\n\t\t\t\t\t\tweek = thisWeek;\n\t\t\t\t\t\tnumberOfDays = 0;\n\n\t\t\t\t\t\ttmpCases = {\n\t\t\t\t\t\t\tdatetime: currentDay,\n\t\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t\t\tweek,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpFatalities = {\n\t\t\t\t\t\t\tdatetime: currentDay,\n\t\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t\t\tweek,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpHospitals = {\n\t\t\t\t\t\t\tdatetime: currentDay,\n\t\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t\t\tweek,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpIcus = {\n\t\t\t\t\t\t\tdatetime: currentDay,\n\t\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t\t\tweek,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttmpTests = {\n\t\t\t\t\t\t\tdatetime: currentDay,\n\t\t\t\t\t\t\tvalue: 0,\n\t\t\t\t\t\t\tweek,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\ttmpCases.value = (() => {\n\t\t\t\t\t\tif (d.new_tested_positive) {\n\t\t\t\t\t\t\treturn tmpCases.value + d.new_tested_positive;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn tmpCases.value;\n\t\t\t\t\t})();\n\t\t\t\t\ttmpFatalities.value = (() => {\n\t\t\t\t\t\tif (d.deaths) {\n\t\t\t\t\t\t\treturn tmpFatalities.value + ((i === 0) ? d.deaths : d.deaths - (rawData.italy.global[i - 1].deaths));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn tmpFatalities.value;\n\t\t\t\t\t})();\n\t\t\t\t\ttmpHospitals.value = (() => {\n\t\t\t\t\t\tif (d.hospital) {\n\t\t\t\t\t\t\treturn tmpHospitals.value + d.hospital;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn tmpHospitals.value;\n\t\t\t\t\t})();\n\t\t\t\t\ttmpIcus.value = (() => {\n\t\t\t\t\t\tif (d.icu) {\n\t\t\t\t\t\t\treturn tmpIcus.value + d.icu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn tmpIcus.value;\n\t\t\t\t\t})();\n\t\t\t\t\ttmpTests.value = (() => {\n\t\t\t\t\t\tif (d.tested) {\n\t\t\t\t\t\t\treturn tmpTests.value + ((i === 0) ? d.tested : d.tested - (rawData.italy.global[i - 1].tested));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn tmpTests.value;\n\t\t\t\t\t})();\n\t\t\t\t\tnumberOfDays += 1;\n\t\t\t\t});\n\n\t\t\t\tconsole.log(data2020, data2021);\n\n      }).catch((e) => {\n\t\t\t\tconsole.log(\"error\", e);\n\t\t\t});\n\t\t}\n\n\t\tfetchData();\n  });\n</script>\n\n<main>\n\t<div class=\"wrapper\">\n\t\t<h1>Italy: Weekly Covid19 Progression since January 1<span>st</span>, 2021</h1>\n\t\t{#if data !== undefined}\n\t\t\t{#each CHARTS as chart, i}\n\t\t\t\t<div class=\"chart\" id=\"wrapper-{chart.id}\">\n\t\t\t\t\t<Chart id=\"{chart.id}\" data=\"{data}\" label=\"{chart.label}\" position=\"{i}\" charts=\"{CHARTS.length}\" />\n\t\t\t\t</div>\n\t\t\t{/each}\n\t\t{/if}\n\t\t<h4>Data from Italian Civil Protection.\n\t\t\tWeeks are computed from Friday to Friday, the day the Italian Government and the Italian Scientific Committee review COVID-Related Data.</h4>\n\t</div>\n\t<br />\n\t<br />\n\t<br />\n\t<br />\n\t<hr />\n\t<br />\n\t<br />\n\t<br />\n\t<br />\n\t<div class=\"wrapper wrapper2\">\n\t\t<h1>Italy: Comparing Weekly Covid19 Progression Years <span class=\"y2020\">2020</span> vs <span class=\"y2021\">2021</span></h1>\n\t\t{#if data !== undefined}\n\t\t\t{#each CHARTS as chart, i}\n\t\t\t\t<div class=\"chart chart2\" id=\"wrapper-{chart.id}\">\n\t\t\t\t\t<Line id=\"{chart.id}\" data2020=\"{data2020}\" data2021=\"{data2021}\" label=\"{chart.label2}\" position=\"{i}\" charts=\"{CHARTS.length}\" />\n\t\t\t\t</div>\n\t\t\t{/each}\n\t\t{/if}\n\t\t<h4>Data from Italian Civil Protection.</h4>\n\t</div>\n\n\t<div class=\"assets\">\n\t\t<svg>\n\t\t\t<defs>\n\t\t\t\t<pattern\n\t\t\t\t\tid=\"stripes\"\n\t\t\t\t\twidth=\"5px\"\n\t\t\t\t\theight=\"5px\"\n\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\tpatternContentUnits=\"userSpaceOnUse\"\n\t\t\t\t\tviewBox=\"0 0 100 100\"\n\t\t\t\t\tpreserveAspectRatio=\"none\"\n\t\t\t\t\tpatternTransform=\"rotate(-45)\"\n\t\t\t\t>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"100\"\n\t\t\t\t\t\ty1=\"46\"\n\t\t\t\t\t\ty2=\"46\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"100\"\n\t\t\t\t\t\ty1=\"92\"\n\t\t\t\t\t\ty2=\"92\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"46\"\n\t\t\t\t\t\tx2=\"46\"\n\t\t\t\t\t\ty1=\"0\"\n\t\t\t\t\t\ty2=\"100\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"92\"\n\t\t\t\t\t\tx2=\"92\"\n\t\t\t\t\t\ty1=\"0\"\n\t\t\t\t\t\ty2=\"100\"\n\t\t\t\t\t\tstroke-width=\"20\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t</pattern>\n\t\t\t\t<pattern\n\t\t\t\t\tid=\"stripes2\"\n\t\t\t\t\twidth=\"5px\"\n\t\t\t\t\theight=\"5px\"\n\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\tpatternContentUnits=\"userSpaceOnUse\"\n\t\t\t\t\tviewBox=\"0 0 140 140\"\n\t\t\t\t\tpreserveAspectRatio=\"none\"\n\t\t\t\t\tpatternTransform=\"rotate(-45)\"\n\t\t\t\t>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"140\"\n\t\t\t\t\t\ty1=\"70\"\n\t\t\t\t\t\ty2=\"70\"\n\t\t\t\t\t\tstroke-width=\"30\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t</pattern>\n\t\t\t\t<pattern\n\t\t\t\t\tid=\"stripes3\"\n\t\t\t\t\twidth=\"5px\"\n\t\t\t\t\theight=\"5px\"\n\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\tpatternContentUnits=\"userSpaceOnUse\"\n\t\t\t\t\tviewBox=\"0 0 140 140\"\n\t\t\t\t\tpreserveAspectRatio=\"none\"\n\t\t\t\t\tpatternTransform=\"rotate(45)\"\n\t\t\t\t>\n\t\t\t\t\t<line\n\t\t\t\t\t\tx1=\"0\"\n\t\t\t\t\t\tx2=\"140\"\n\t\t\t\t\t\ty1=\"70\"\n\t\t\t\t\t\ty2=\"70\"\n\t\t\t\t\t\tstroke-width=\"30\"\n\t\t\t\t\t\tstroke=\"#444\"\n\t\t\t\t\t/>\n\t\t\t\t</pattern>\n\t\t\t\t<pattern\n\t\t\t\t\tid=\"dots\"\n\t\t\t\t\twidth=\"3px\"\n\t\t\t\t\theight=\"3px\"\n\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\tpatternContentUnits=\"userSpaceOnUse\"\n\t\t\t\t\tviewBox=\"0 0 5 5\"\n\t\t\t\t\tpreserveAspectRatio=\"none\"\n\t\t\t\t\tpatternTransform=\"rotate(45)\"\n\t\t\t\t>\n\t\t\t\t\t<circle\n\t\t\t\t\t\tr=\"1\"\n\t\t\t\t\t\tcx=\"3\"\n\t\t\t\t\t\tcy=\"3\"\n\t\t\t\t\t\tfill=\"#bcbcbc\"\n\t\t\t\t\t\tstroke=\"transparent\"\n\t\t\t\t\t\tstroke-width=\"0\" />\n\t\t\t\t</pattern>\n\t\t\t</defs>\n\t\t</svg>\n\t</div>\n</main>\n\n<style>\n\n\t.wrapper {\n\t\tbackground: #fff;\n\t\tborder: 1px solid #444;\n\t\tdisplay: block;\n\t\theight: auto;\n\t\tmargin: 40px auto;\n\t\tposition: relative;\n\t\twidth: 750px;\n\t}\n\n\t.wrapper2 {\n\t\twidth: 950px;\n\t}\n\n\th1 {\n\t\tdisplay: block;\n\t\tfont-size: 18px;\n\t\tfont-weight: 400;\n\t\theight: 50px;\n\t\tletter-spacing: .1em;\n\t\tline-height: 30px;\n\t\tmargin:0;\n\t\ttext-align: center;\n\t\ttext-transform: uppercase;\n\t}\n\n\th4 {\n\t\tdisplay: block;\n\t\tfont-size: 10px;\n\t\tfont-weight: 400;\n\t\tletter-spacing: .1em;\n\t\tline-height: 1.25;\n\t\tmargin: 0;\n\t\tpadding: 20px 40px;\n\t\ttext-align: center;\n\t}\n\n\th1 span {\n\t\ttext-transform: lowercase;\n\t}\n\n\t.chart {\n\t\t/* border-bottom: 1px solid #444; */\n\t\tdisplay: block;\n\t\theight: auto;\n\t\tmin-height: 150px;\n\t\tposition: relative;\n\t\twidth: 750px;\n\t}\n\n\t.chart2 {\n\t\twidth: 950px;\n\t}\n\n\t.chart:nth-child(odd) {\n\t\tbackground: #fcfcfc;\n\t}\n\n\t.chart:last-child {\n\t\tborder-bottom: inherit;\n\t}\n\n\t.assets {\n\t\theight: 0;\n\t\topacity: 0;\n\t\toverflow: hidden;\n\t\twidth: 0;\n\t}\n\n\t.y2020 {\n\t\tcolor: #9a9a9a;\n\t\tfont-weight: 700;\n\t}\n\n\t.y2021 {\n\t\tfont-weight: 700;\n\t}\n</style>","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","attr","attribute","value","removeAttribute","getAttribute","setAttribute","current_component","set_current_component","component","onMount","Error","get_current_component","$$","on_mount","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","create_component","mount_component","customElement","on_destroy","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","[object Object]","this","$destroy","type","index","indexOf","splice","$$props","obj","$$set","keys","thisArg","args","arguments","apply","toString","prototype","isArray","val","call","isUndefined","isObject","isPlainObject","getPrototypeOf","isFunction","key","hasOwnProperty","isArrayBuffer","isBuffer","constructor","isFormData","FormData","isArrayBufferView","ArrayBuffer","isView","buffer","isString","isNumber","isDate","isFile","isBlob","isStream","pipe","isURLSearchParams","URLSearchParams","isStandardBrowserEnv","navigator","product","window","merge","result","assignValue","slice","extend","bind","trim","str","replace","stripBOM","content","charCodeAt","encode","encodeURIComponent","url","params","paramsSerializer","serializedParams","utils","parts","v","toISOString","JSON","stringify","join","hashmarkIndex","InterceptorManager","handlers","use","fulfilled","rejected","eject","id","h","headers","__CANCEL__","normalizedName","toUpperCase","message","config","code","request","response","error","isAxiosError","toJSON","description","number","fileName","lineNumber","columnNumber","stack","enhanceError","write","expires","path","domain","secure","cookie","Date","toGMTString","read","match","RegExp","decodeURIComponent","remove","now","ignoreDuplicateOf","originURL","msie","test","userAgent","urlParsingNode","resolveURL","href","protocol","host","search","hash","hostname","port","pathname","charAt","location","requestURL","parsed","reject","requestData","requestHeaders","XMLHttpRequest","auth","username","password","unescape","Authorization","btoa","baseURL","requestedURL","fullPath","relativeURL","combineURLs","open","method","buildURL","timeout","onreadystatechange","readyState","status","responseURL","responseHeaders","getAllResponseHeaders","split","line","substr","toLowerCase","concat","responseType","responseText","statusText","validateStatus","createError","settle","onabort","onerror","ontimeout","timeoutErrorMessage","xsrfValue","withCredentials","isURLSameOrigin","xsrfCookieName","cookies","undefined","xsrfHeaderName","setRequestHeader","e","onDownloadProgress","addEventListener","onUploadProgress","upload","cancelToken","promise","cancel","abort","send","DEFAULT_CONTENT_TYPE","Content-Type","setContentTypeIfUnset","adapter","defaults","process","require$$0","transformRequest","normalizeHeaderName","transformResponse","parse","maxContentLength","maxBodyLength","common","Accept","throwIfCancellationRequested","throwIfRequested","transformData","reason","isCancel","config1","config2","valueFromConfig2Keys","mergeDeepPropertiesKeys","defaultToConfig2Keys","directMergeKeys","getMergedValue","source","mergeDeepProperties","prop","axiosKeys","otherKeys","Axios","instanceConfig","interceptors","mergeConfig","chain","dispatchRequest","interceptor","unshift","shift","getUri","Cancel","CancelToken","executor","TypeError","resolvePromise","token","createInstance","defaultConfig","axios","require$$1","require$$2","all","promises","spread","arr","payload","baseLog","base","Math","E","log","log10","log2","y","getBaseLog","x","LOG10E","LOG2E","pow10","isFinite","basePow","exp","pow","DEFAULT_WIDTH","TICKS_DEFAULT","COMPONENTS_W_DATA","isNull","hasNull","values","some","hasNaN","isNaN","uuid","random","substring","hasData","arraysEqual","array1","array2","every","console","warn","accessor","_data","_accessor","_orginalData","accessorFunction","assign","root","currentNode","g","memoize","func","cache","size","_len","dimensions","_key","width","height","oldWidth","oldHeight","svg","querySelector","style","_slicedToArray","_arrayWithHoles","Symbol","iterator","_arr","_n","_d","_e","_s","_i","next","done","err","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayLikeToArray","_arrayWithoutHoles","iter","_iterableToArray","_nonIterableSpread","minLen","n","len","arr2","_createForOfIteratorHelper","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","return","createSVG","tag","createElementNS","ExtendedWilkinson","_ref","_this","_ref2","dmin","dmax","ticksN","Q","onlyLoose","w","nice","eps","Number","EPSILON","_ticks","temp","best","score","ticks","ticksNumber","range","j","Infinity","_step","_iterator","q","sm","simplicity","max","k","dm","density","delta","z","ceil","cm","coverage","min_start","floor","max_start","start","lmin","lmax","lstep","legibility","getMin","getMax","getStep","rt","min","span","half","scale","field","_scale","scales","fixedDomain","copyOfFixedDomain","_padding","left","bottom","right","top","currentDomain","isLog","domainExtent","objects","fields","eNumScale","domainWidth","direction","rangeWidth","_margins","startCoord","scalingFunction","valueToDomain","fixedTicks","isMinor","isZero","getName","getType","transformation","getField","barwidth","logTicks","improveRange","ticksRange","tick","_k","_tick","scale$1","numScale","getTransformation","scale$2","UNITS","second","minute","DURATION_SECOND","hour","day","unit","LONGER_UNITS","bidiurnal","week","fortnight","month","year","scale$3","calculateTimeDomain","interval","_domainExtent","seconds","abs","d0","d1","getFullYear","getMonth","roundedDomainExtent","setTimeInterval","_domainWidth","startingYear","_startingYear","Chrt","_node","_scaleLinear","oldDomain","oldRange","_scaleLog","_scaleOrdinal","_scaleTime","getAxis","orientation","find","prefix","_css","classList","css","chrt","add$1","prepend","_id","parent","linearInterpolation","points","command","paths","lineCommand","reduce","acc","point","render","_stacked","_group","rollup","svgNode","border","setWidth","setHeight","margins","padding","chrtGeneric","_classNames","interpolationFunction","attrs","className","classNames","setScale","scaleName","chrtStack","_grouped","_groupIndex","_orientation","_dataMap","chart","dataFunction","y0","x0","stacked_y","stacked_x","draw","chrtGroup","generateTicks","tickGroup","showAxisLine","tickLine","stroke","strokeWidth","group","curve","ORIENTATIONS","DEFAULT_ORIENTATION","showAxis","showTicks","ticksFilter","hideTicks","showLabels","labelsFilter","hideLabels","chrtAxis","updater","tickTextColor","tickLength","tickPosition","labelPosition","labelFormat","showMinorTicks","_zero","showZero","_label","_fixedTicks","_interval","_coordinates","generateLabels","labels","labelGroup","label","textContent","labelTextColor","xAxis","customName","_name","coords","xAxisTick","visible","display","_this$parentNode","tickIndex","position","reverse","visibleLabel","axisY","axisLine","scaleY","zero","axisLineY","title","axisTitleText","querySelectorAll","tickName","xAxis$1","yAxis","yAxisTick","axisX","yAxis$1","color","_range","lineStyle","setTickLength","setTickPosition","setLabelPosition","hideAxis","filterTicks","firstTick","show","lastTick","firstAndLastTicks","_labels","_fixedLabels","filterLabels","firstLabel","lastLabel","firstAndLastLabels","orient","format","minor","hideZero","chrtAxisRange","solid","dashed","dotted","strokeOpacity","yAxisRange","fillOpacity","_this$parentNode$pare","to","strokeStyle","_strokeStyle","lines","yAxisRange$1","xAxisRange","xAxisRange$1","color$1","chrtAxisTitle","textAnchor","dy","offset","xAxisDraw","_this$parentNode$pare2","yAxisDraw","align","valign","currentOffset","_lineStyle","_filter","DEAULT_LINE_COLOR","chrtGrid","verticalGridLine","gridLine","y1","y2","horizontalGridLine","x1","x2","axis","_defineProperty","defineProperty","enumerable","configurable","writable","chrtLine","_area","_sortedData","_fill","_fillOpacity","areaPaths","yDomain","xDomain","hasCustomBaseline","datasetsForLine","datumForLine","_scaleX","dataset","sort","datasetsForPoints","datasetsForArea","horizontalArea","_ref4","_ref5","_ref6","_ref7","dataForAreaBaseline","_ref3","areaPath","dArea","singlePoints","circle","chrtLine$1","opacity","area","isInfinity","lineWidth","lineColor","fillColor","chrtBars","_barWidth","getXScale","barWidth","_scaleY","axisLineWidth","rect","chrtColumns","deltaX","pointSize","pointStrokeWidth","DEFAULT_POINT_COLOR","chrtPoints","radius","_position","alignment","_alignment","vertical","_vposition","horizontal","_hposition","outside","chrtLabel","_offsets","getPosition","chrtLabels","parentData","isBars","offsets","chrtLabel$1","textFieldAccessor","textField","topOffset","leftOffset","showMarkers","markersFilter","hideMarkers","chrtMarkers","markers","_radius","_opacity","_stroke","_strokeOpacity","_strokeWidth","marker","cx","cy","chrtAnnotation","div","innerHTML","chrtAnnotation$1","firstMarker","lastMarker","firstAndLastMarkers","el","charts","chrt.Chrt","startDay","getDate","maxObj","maxIndex","findIndex","endDay","class","Intl","NumberFormat","data2020","data2021","H","chrt.chrtLine","datetime","label2","DATA_SOURCE","getWeek","dowOffset","newYear","getDay","weeknum","daynum","getTime","getTimezoneOffset","nday","cases","fatalities","tests","icus","hospitals","rawData","epicenters","generated","italy","global","provinces","regions","tested","get","results","italy_filtered","tmpCases","tmpFatalities","tmpIcus","tmpHospitals","tmpTests","setDate","avg","new_tested_positive","deaths","icu","hospital","refYear","numberOfDays","currentDay","thisWeek","catch","fetchData","body"],"mappings":"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"}